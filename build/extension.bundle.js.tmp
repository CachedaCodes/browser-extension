(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
/*!
 * is-equal-shallow <https://github.com/jonschlinkert/is-equal-shallow>
 *
 * Copyright (c) 2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

var isPrimitive = require('is-primitive');

module.exports = function isEqual(a, b) {
  if (!a && !b) { return true; }
  if (!a && b || a && !b) { return false; }

  var numKeysA = 0, numKeysB = 0, key;
  for (key in b) {
    numKeysB++;
    if (!isPrimitive(b[key]) || !a.hasOwnProperty(key) || (a[key] !== b[key])) {
      return false;
    }
  }
  for (key in a) {
    numKeysA++;
  }
  return numKeysA === numKeysB;
};

},{"is-primitive":2}],2:[function(require,module,exports){
/*!
 * is-primitive <https://github.com/jonschlinkert/is-primitive>
 *
 * Copyright (c) 2014-2015, Jon Schlinkert.
 * Licensed under the MIT License.
 */

'use strict';

// see http://jsperf.com/testing-value-is-primitive/7
module.exports = function isPrimitive(value) {
  return value == null || (typeof value !== 'function' && typeof value !== 'object');
};

},{}],3:[function(require,module,exports){
'use strict';
var strictUriEncode = require('strict-uri-encode');

exports.extract = function (str) {
	return str.split('?')[1] || '';
};

exports.parse = function (str) {
	if (typeof str !== 'string') {
		return {};
	}

	str = str.trim().replace(/^(\?|#|&)/, '');

	if (!str) {
		return {};
	}

	return str.split('&').reduce(function (ret, param) {
		var parts = param.replace(/\+/g, ' ').split('=');
		// Firefox (pre 40) decodes `%3D` to `=`
		// https://github.com/sindresorhus/query-string/pull/37
		var key = parts.shift();
		var val = parts.length > 0 ? parts.join('=') : undefined;

		key = decodeURIComponent(key);

		// missing `=` should be `null`:
		// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
		val = val === undefined ? null : decodeURIComponent(val);

		if (!ret.hasOwnProperty(key)) {
			ret[key] = val;
		} else if (Array.isArray(ret[key])) {
			ret[key].push(val);
		} else {
			ret[key] = [ret[key], val];
		}

		return ret;
	}, {});
};

exports.stringify = function (obj) {
	return obj ? Object.keys(obj).sort().map(function (key) {
		var val = obj[key];

		if (val === undefined) {
			return '';
		}

		if (val === null) {
			return key;
		}

		if (Array.isArray(val)) {
			return val.slice().sort().map(function (val2) {
				return strictUriEncode(key) + '=' + strictUriEncode(val2);
			}).join('&');
		}

		return strictUriEncode(key) + '=' + strictUriEncode(val);
	}).filter(function (x) {
		return x.length > 0;
	}).join('&') : '';
};

},{"strict-uri-encode":12}],4:[function(require,module,exports){
function RavenConfigError(message) {
  this.name = 'RavenConfigError';
  this.message = message;
}
RavenConfigError.prototype = new Error();
RavenConfigError.prototype.constructor = RavenConfigError;

module.exports = RavenConfigError;

},{}],5:[function(require,module,exports){
var utils = require('./utils');

var wrapMethod = function(console, level, callback) {
  var originalConsoleLevel = console[level];
  var originalConsole = console;

  if (!(level in console)) {
    return;
  }

  var sentryLevel = level === 'warn' ? 'warning' : level;

  console[level] = function() {
    var args = [].slice.call(arguments);

    var msg = utils.safeJoin(args, ' ');
    var data = {level: sentryLevel, logger: 'console', extra: {arguments: args}};

    if (level === 'assert') {
      if (args[0] === false) {
        // Default browsers message
        msg =
          'Assertion failed: ' + (utils.safeJoin(args.slice(1), ' ') || 'console.assert');
        data.extra.arguments = args.slice(1);
        callback && callback(msg, data);
      }
    } else {
      callback && callback(msg, data);
    }

    // this fails for some browsers. :(
    if (originalConsoleLevel) {
      // IE9 doesn't allow calling apply on console functions directly
      // See: https://stackoverflow.com/questions/5472938/does-ie9-support-console-log-and-is-it-a-real-function#answer-5473193
      Function.prototype.apply.call(originalConsoleLevel, originalConsole, args);
    }
  };
};

module.exports = {
  wrapMethod: wrapMethod
};

},{"./utils":8}],6:[function(require,module,exports){
(function (global){
/*global XDomainRequest:false */

var TraceKit = require('../vendor/TraceKit/tracekit');
var stringify = require('../vendor/json-stringify-safe/stringify');
var md5 = require('../vendor/md5/md5');
var RavenConfigError = require('./configError');

var utils = require('./utils');
var isErrorEvent = utils.isErrorEvent;
var isDOMError = utils.isDOMError;
var isDOMException = utils.isDOMException;
var isError = utils.isError;
var isObject = utils.isObject;
var isPlainObject = utils.isPlainObject;
var isUndefined = utils.isUndefined;
var isFunction = utils.isFunction;
var isString = utils.isString;
var isArray = utils.isArray;
var isEmptyObject = utils.isEmptyObject;
var each = utils.each;
var objectMerge = utils.objectMerge;
var truncate = utils.truncate;
var objectFrozen = utils.objectFrozen;
var hasKey = utils.hasKey;
var joinRegExp = utils.joinRegExp;
var urlencode = utils.urlencode;
var uuid4 = utils.uuid4;
var htmlTreeAsString = utils.htmlTreeAsString;
var isSameException = utils.isSameException;
var isSameStacktrace = utils.isSameStacktrace;
var parseUrl = utils.parseUrl;
var fill = utils.fill;
var supportsFetch = utils.supportsFetch;
var supportsReferrerPolicy = utils.supportsReferrerPolicy;
var serializeKeysForMessage = utils.serializeKeysForMessage;
var serializeException = utils.serializeException;
var sanitize = utils.sanitize;

var wrapConsoleMethod = require('./console').wrapMethod;

var dsnKeys = 'source protocol user pass host port path'.split(' '),
  dsnPattern = /^(?:(\w+):)?\/\/(?:(\w+)(:\w+)?@)?([\w\.-]+)(?::(\d+))?(\/.*)/;

function now() {
  return +new Date();
}

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window =
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
var _document = _window.document;
var _navigator = _window.navigator;

function keepOriginalCallback(original, callback) {
  return isFunction(callback)
    ? function(data) {
        return callback(data, original);
      }
    : callback;
}

// First, check for JSON support
// If there is no JSON, we no-op the core features of Raven
// since JSON is required to encode the payload
function Raven() {
  this._hasJSON = !!(typeof JSON === 'object' && JSON.stringify);
  // Raven can run in contexts where there's no document (react-native)
  this._hasDocument = !isUndefined(_document);
  this._hasNavigator = !isUndefined(_navigator);
  this._lastCapturedException = null;
  this._lastData = null;
  this._lastEventId = null;
  this._globalServer = null;
  this._globalKey = null;
  this._globalProject = null;
  this._globalContext = {};
  this._globalOptions = {
    // SENTRY_RELEASE can be injected by https://github.com/getsentry/sentry-webpack-plugin
    release: _window.SENTRY_RELEASE && _window.SENTRY_RELEASE.id,
    logger: 'javascript',
    ignoreErrors: [],
    ignoreUrls: [],
    whitelistUrls: [],
    includePaths: [],
    headers: null,
    collectWindowErrors: true,
    captureUnhandledRejections: true,
    maxMessageLength: 0,
    // By default, truncates URL values to 250 chars
    maxUrlLength: 250,
    stackTraceLimit: 50,
    autoBreadcrumbs: true,
    instrument: true,
    sampleRate: 1,
    sanitizeKeys: []
  };
  this._fetchDefaults = {
    method: 'POST',
    // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
    // https://caniuse.com/#feat=referrer-policy
    // It doesn't. And it throw exception instead of ignoring this parameter...
    // REF: https://github.com/getsentry/raven-js/issues/1233
    referrerPolicy: supportsReferrerPolicy() ? 'origin' : ''
  };
  this._ignoreOnError = 0;
  this._isRavenInstalled = false;
  this._originalErrorStackTraceLimit = Error.stackTraceLimit;
  // capture references to window.console *and* all its methods first
  // before the console plugin has a chance to monkey patch
  this._originalConsole = _window.console || {};
  this._originalConsoleMethods = {};
  this._plugins = [];
  this._startTime = now();
  this._wrappedBuiltIns = [];
  this._breadcrumbs = [];
  this._lastCapturedEvent = null;
  this._keypressTimeout;
  this._location = _window.location;
  this._lastHref = this._location && this._location.href;
  this._resetBackoff();

  // eslint-disable-next-line guard-for-in
  for (var method in this._originalConsole) {
    this._originalConsoleMethods[method] = this._originalConsole[method];
  }
}

/*
 * The core Raven singleton
 *
 * @this {Raven}
 */

Raven.prototype = {
  // Hardcode version string so that raven source can be loaded directly via
  // webpack (using a build step causes webpack #1617). Grunt verifies that
  // this value matches package.json during build.
  //   See: https://github.com/getsentry/raven-js/issues/465
  VERSION: '3.27.2',

  debug: false,

  TraceKit: TraceKit, // alias to TraceKit

  /*
     * Configure Raven with a DSN and extra options
     *
     * @param {string} dsn The public Sentry DSN
     * @param {object} options Set of global options [optional]
     * @return {Raven}
     */
  config: function(dsn, options) {
    var self = this;

    if (self._globalServer) {
      this._logDebug('error', 'Error: Raven has already been configured');
      return self;
    }
    if (!dsn) return self;

    var globalOptions = self._globalOptions;

    // merge in options
    if (options) {
      each(options, function(key, value) {
        // tags and extra are special and need to be put into context
        if (key === 'tags' || key === 'extra' || key === 'user') {
          self._globalContext[key] = value;
        } else {
          globalOptions[key] = value;
        }
      });
    }

    self.setDSN(dsn);

    // "Script error." is hard coded into browsers for errors that it can't read.
    // this is the result of a script being pulled in from an external domain and CORS.
    globalOptions.ignoreErrors.push(/^Script error\.?$/);
    globalOptions.ignoreErrors.push(/^Javascript error: Script error\.? on line 0$/);

    // join regexp rules into one big rule
    globalOptions.ignoreErrors = joinRegExp(globalOptions.ignoreErrors);
    globalOptions.ignoreUrls = globalOptions.ignoreUrls.length
      ? joinRegExp(globalOptions.ignoreUrls)
      : false;
    globalOptions.whitelistUrls = globalOptions.whitelistUrls.length
      ? joinRegExp(globalOptions.whitelistUrls)
      : false;
    globalOptions.includePaths = joinRegExp(globalOptions.includePaths);
    globalOptions.maxBreadcrumbs = Math.max(
      0,
      Math.min(globalOptions.maxBreadcrumbs || 100, 100)
    ); // default and hard limit is 100

    var autoBreadcrumbDefaults = {
      xhr: true,
      console: true,
      dom: true,
      location: true,
      sentry: true
    };

    var autoBreadcrumbs = globalOptions.autoBreadcrumbs;
    if ({}.toString.call(autoBreadcrumbs) === '[object Object]') {
      autoBreadcrumbs = objectMerge(autoBreadcrumbDefaults, autoBreadcrumbs);
    } else if (autoBreadcrumbs !== false) {
      autoBreadcrumbs = autoBreadcrumbDefaults;
    }
    globalOptions.autoBreadcrumbs = autoBreadcrumbs;

    var instrumentDefaults = {
      tryCatch: true
    };

    var instrument = globalOptions.instrument;
    if ({}.toString.call(instrument) === '[object Object]') {
      instrument = objectMerge(instrumentDefaults, instrument);
    } else if (instrument !== false) {
      instrument = instrumentDefaults;
    }
    globalOptions.instrument = instrument;

    TraceKit.collectWindowErrors = !!globalOptions.collectWindowErrors;

    // return for chaining
    return self;
  },

  /*
     * Installs a global window.onerror error handler
     * to capture and report uncaught exceptions.
     * At this point, install() is required to be called due
     * to the way TraceKit is set up.
     *
     * @return {Raven}
     */
  install: function() {
    var self = this;
    if (self.isSetup() && !self._isRavenInstalled) {
      TraceKit.report.subscribe(function() {
        self._handleOnErrorStackInfo.apply(self, arguments);
      });

      if (self._globalOptions.captureUnhandledRejections) {
        self._attachPromiseRejectionHandler();
      }

      self._patchFunctionToString();

      if (self._globalOptions.instrument && self._globalOptions.instrument.tryCatch) {
        self._instrumentTryCatch();
      }

      if (self._globalOptions.autoBreadcrumbs) self._instrumentBreadcrumbs();

      // Install all of the plugins
      self._drainPlugins();

      self._isRavenInstalled = true;
    }

    Error.stackTraceLimit = self._globalOptions.stackTraceLimit;
    return this;
  },

  /*
     * Set the DSN (can be called multiple time unlike config)
     *
     * @param {string} dsn The public Sentry DSN
     */
  setDSN: function(dsn) {
    var self = this,
      uri = self._parseDSN(dsn),
      lastSlash = uri.path.lastIndexOf('/'),
      path = uri.path.substr(1, lastSlash);

    self._dsn = dsn;
    self._globalKey = uri.user;
    self._globalSecret = uri.pass && uri.pass.substr(1);
    self._globalProject = uri.path.substr(lastSlash + 1);

    self._globalServer = self._getGlobalServer(uri);

    self._globalEndpoint =
      self._globalServer + '/' + path + 'api/' + self._globalProject + '/store/';

    // Reset backoff state since we may be pointing at a
    // new project/server
    this._resetBackoff();
  },

  /*
     * Wrap code within a context so Raven can capture errors
     * reliably across domains that is executed immediately.
     *
     * @param {object} options A specific set of options for this context [optional]
     * @param {function} func The callback to be immediately executed within the context
     * @param {array} args An array of arguments to be called with the callback [optional]
     */
  context: function(options, func, args) {
    if (isFunction(options)) {
      args = func || [];
      func = options;
      options = {};
    }

    return this.wrap(options, func).apply(this, args);
  },

  /*
     * Wrap code within a context and returns back a new function to be executed
     *
     * @param {object} options A specific set of options for this context [optional]
     * @param {function} func The function to be wrapped in a new context
     * @param {function} _before A function to call before the try/catch wrapper [optional, private]
     * @return {function} The newly wrapped functions with a context
     */
  wrap: function(options, func, _before) {
    var self = this;
    // 1 argument has been passed, and it's not a function
    // so just return it
    if (isUndefined(func) && !isFunction(options)) {
      return options;
    }

    // options is optional
    if (isFunction(options)) {
      func = options;
      options = undefined;
    }

    // At this point, we've passed along 2 arguments, and the second one
    // is not a function either, so we'll just return the second argument.
    if (!isFunction(func)) {
      return func;
    }

    // We don't wanna wrap it twice!
    try {
      if (func.__raven__) {
        return func;
      }

      // If this has already been wrapped in the past, return that
      if (func.__raven_wrapper__) {
        return func.__raven_wrapper__;
      }
    } catch (e) {
      // Just accessing custom props in some Selenium environments
      // can cause a "Permission denied" exception (see raven-js#495).
      // Bail on wrapping and return the function as-is (defers to window.onerror).
      return func;
    }

    function wrapped() {
      var args = [],
        i = arguments.length,
        deep = !options || (options && options.deep !== false);

      if (_before && isFunction(_before)) {
        _before.apply(this, arguments);
      }

      // Recursively wrap all of a function's arguments that are
      // functions themselves.
      while (i--) args[i] = deep ? self.wrap(options, arguments[i]) : arguments[i];

      try {
        // Attempt to invoke user-land function
        // NOTE: If you are a Sentry user, and you are seeing this stack frame, it
        //       means Raven caught an error invoking your application code. This is
        //       expected behavior and NOT indicative of a bug with Raven.js.
        return func.apply(this, args);
      } catch (e) {
        self._ignoreNextOnError();
        self.captureException(e, options);
        throw e;
      }
    }

    // copy over properties of the old function
    for (var property in func) {
      if (hasKey(func, property)) {
        wrapped[property] = func[property];
      }
    }
    wrapped.prototype = func.prototype;

    func.__raven_wrapper__ = wrapped;
    // Signal that this function has been wrapped/filled already
    // for both debugging and to prevent it to being wrapped/filled twice
    wrapped.__raven__ = true;
    wrapped.__orig__ = func;

    return wrapped;
  },

  /**
   * Uninstalls the global error handler.
   *
   * @return {Raven}
   */
  uninstall: function() {
    TraceKit.report.uninstall();

    this._detachPromiseRejectionHandler();
    this._unpatchFunctionToString();
    this._restoreBuiltIns();
    this._restoreConsole();

    Error.stackTraceLimit = this._originalErrorStackTraceLimit;
    this._isRavenInstalled = false;

    return this;
  },

  /**
   * Callback used for `unhandledrejection` event
   *
   * @param {PromiseRejectionEvent} event An object containing
   *   promise: the Promise that was rejected
   *   reason: the value with which the Promise was rejected
   * @return void
   */
  _promiseRejectionHandler: function(event) {
    this._logDebug('debug', 'Raven caught unhandled promise rejection:', event);
    this.captureException(event.reason, {
      mechanism: {
        type: 'onunhandledrejection',
        handled: false
      }
    });
  },

  /**
   * Installs the global promise rejection handler.
   *
   * @return {raven}
   */
  _attachPromiseRejectionHandler: function() {
    this._promiseRejectionHandler = this._promiseRejectionHandler.bind(this);
    _window.addEventListener &&
      _window.addEventListener('unhandledrejection', this._promiseRejectionHandler);
    return this;
  },

  /**
   * Uninstalls the global promise rejection handler.
   *
   * @return {raven}
   */
  _detachPromiseRejectionHandler: function() {
    _window.removeEventListener &&
      _window.removeEventListener('unhandledrejection', this._promiseRejectionHandler);
    return this;
  },

  /**
   * Manually capture an exception and send it over to Sentry
   *
   * @param {error} ex An exception to be logged
   * @param {object} options A specific set of options for this error [optional]
   * @return {Raven}
   */
  captureException: function(ex, options) {
    options = objectMerge({trimHeadFrames: 0}, options ? options : {});

    if (isErrorEvent(ex) && ex.error) {
      // If it is an ErrorEvent with `error` property, extract it to get actual Error
      ex = ex.error;
    } else if (isDOMError(ex) || isDOMException(ex)) {
      // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)
      // then we just extract the name and message, as they don't provide anything else
      // https://developer.mozilla.org/en-US/docs/Web/API/DOMError
      // https://developer.mozilla.org/en-US/docs/Web/API/DOMException
      var name = ex.name || (isDOMError(ex) ? 'DOMError' : 'DOMException');
      var message = ex.message ? name + ': ' + ex.message : name;

      return this.captureMessage(
        message,
        objectMerge(options, {
          // neither DOMError or DOMException provide stack trace and we most likely wont get it this way as well
          // but it's barely any overhead so we may at least try
          stacktrace: true,
          trimHeadFrames: options.trimHeadFrames + 1
        })
      );
    } else if (isError(ex)) {
      // we have a real Error object
      ex = ex;
    } else if (isPlainObject(ex)) {
      // If it is plain Object, serialize it manually and extract options
      // This will allow us to group events based on top-level keys
      // which is much better than creating new group when any key/value change
      options = this._getCaptureExceptionOptionsFromPlainObject(options, ex);
      ex = new Error(options.message);
    } else {
      // If none of previous checks were valid, then it means that
      // it's not a DOMError/DOMException
      // it's not a plain Object
      // it's not a valid ErrorEvent (one with an error property)
      // it's not an Error
      // So bail out and capture it as a simple message:
      return this.captureMessage(
        ex,
        objectMerge(options, {
          stacktrace: true, // if we fall back to captureMessage, default to attempting a new trace
          trimHeadFrames: options.trimHeadFrames + 1
        })
      );
    }

    // Store the raw exception object for potential debugging and introspection
    this._lastCapturedException = ex;

    // TraceKit.report will re-raise any exception passed to it,
    // which means you have to wrap it in try/catch. Instead, we
    // can wrap it here and only re-raise if TraceKit.report
    // raises an exception different from the one we asked to
    // report on.
    try {
      var stack = TraceKit.computeStackTrace(ex);
      this._handleStackInfo(stack, options);
    } catch (ex1) {
      if (ex !== ex1) {
        throw ex1;
      }
    }

    return this;
  },

  _getCaptureExceptionOptionsFromPlainObject: function(currentOptions, ex) {
    var exKeys = Object.keys(ex).sort();
    var options = objectMerge(currentOptions, {
      message:
        'Non-Error exception captured with keys: ' + serializeKeysForMessage(exKeys),
      fingerprint: [md5(exKeys)],
      extra: currentOptions.extra || {}
    });
    options.extra.__serialized__ = serializeException(ex);

    return options;
  },

  /*
     * Manually send a message to Sentry
     *
     * @param {string} msg A plain message to be captured in Sentry
     * @param {object} options A specific set of options for this message [optional]
     * @return {Raven}
     */
  captureMessage: function(msg, options) {
    // config() automagically converts ignoreErrors from a list to a RegExp so we need to test for an
    // early call; we'll error on the side of logging anything called before configuration since it's
    // probably something you should see:
    if (
      !!this._globalOptions.ignoreErrors.test &&
      this._globalOptions.ignoreErrors.test(msg)
    ) {
      return;
    }

    options = options || {};
    msg = msg + ''; // Make sure it's actually a string

    var data = objectMerge(
      {
        message: msg
      },
      options
    );

    var ex;
    // Generate a "synthetic" stack trace from this point.
    // NOTE: If you are a Sentry user, and you are seeing this stack frame, it is NOT indicative
    //       of a bug with Raven.js. Sentry generates synthetic traces either by configuration,
    //       or if it catches a thrown object without a "stack" property.
    try {
      throw new Error(msg);
    } catch (ex1) {
      ex = ex1;
    }

    // null exception name so `Error` isn't prefixed to msg
    ex.name = null;
    var stack = TraceKit.computeStackTrace(ex);

    // stack[0] is `throw new Error(msg)` call itself, we are interested in the frame that was just before that, stack[1]
    var initialCall = isArray(stack.stack) && stack.stack[1];

    // if stack[1] is `Raven.captureException`, it means that someone passed a string to it and we redirected that call
    // to be handled by `captureMessage`, thus `initialCall` is the 3rd one, not 2nd
    // initialCall => captureException(string) => captureMessage(string)
    if (initialCall && initialCall.func === 'Raven.captureException') {
      initialCall = stack.stack[2];
    }

    var fileurl = (initialCall && initialCall.url) || '';

    if (
      !!this._globalOptions.ignoreUrls.test &&
      this._globalOptions.ignoreUrls.test(fileurl)
    ) {
      return;
    }

    if (
      !!this._globalOptions.whitelistUrls.test &&
      !this._globalOptions.whitelistUrls.test(fileurl)
    ) {
      return;
    }

    // Always attempt to get stacktrace if message is empty.
    // It's the only way to provide any helpful information to the user.
    if (this._globalOptions.stacktrace || options.stacktrace || data.message === '') {
      // fingerprint on msg, not stack trace (legacy behavior, could be revisited)
      data.fingerprint = data.fingerprint == null ? msg : data.fingerprint;

      options = objectMerge(
        {
          trimHeadFrames: 0
        },
        options
      );
      // Since we know this is a synthetic trace, the top frame (this function call)
      // MUST be from Raven.js, so mark it for trimming
      // We add to the trim counter so that callers can choose to trim extra frames, such
      // as utility functions.
      options.trimHeadFrames += 1;

      var frames = this._prepareFrames(stack, options);
      data.stacktrace = {
        // Sentry expects frames oldest to newest
        frames: frames.reverse()
      };
    }

    // Make sure that fingerprint is always wrapped in an array
    if (data.fingerprint) {
      data.fingerprint = isArray(data.fingerprint)
        ? data.fingerprint
        : [data.fingerprint];
    }

    // Fire away!
    this._send(data);

    return this;
  },

  captureBreadcrumb: function(obj) {
    var crumb = objectMerge(
      {
        timestamp: now() / 1000
      },
      obj
    );

    if (isFunction(this._globalOptions.breadcrumbCallback)) {
      var result = this._globalOptions.breadcrumbCallback(crumb);

      if (isObject(result) && !isEmptyObject(result)) {
        crumb = result;
      } else if (result === false) {
        return this;
      }
    }

    this._breadcrumbs.push(crumb);
    if (this._breadcrumbs.length > this._globalOptions.maxBreadcrumbs) {
      this._breadcrumbs.shift();
    }
    return this;
  },

  addPlugin: function(plugin /*arg1, arg2, ... argN*/) {
    var pluginArgs = [].slice.call(arguments, 1);

    this._plugins.push([plugin, pluginArgs]);
    if (this._isRavenInstalled) {
      this._drainPlugins();
    }

    return this;
  },

  /*
     * Set/clear a user to be sent along with the payload.
     *
     * @param {object} user An object representing user data [optional]
     * @return {Raven}
     */
  setUserContext: function(user) {
    // Intentionally do not merge here since that's an unexpected behavior.
    this._globalContext.user = user;

    return this;
  },

  /*
     * Merge extra attributes to be sent along with the payload.
     *
     * @param {object} extra An object representing extra data [optional]
     * @return {Raven}
     */
  setExtraContext: function(extra) {
    this._mergeContext('extra', extra);

    return this;
  },

  /*
     * Merge tags to be sent along with the payload.
     *
     * @param {object} tags An object representing tags [optional]
     * @return {Raven}
     */
  setTagsContext: function(tags) {
    this._mergeContext('tags', tags);

    return this;
  },

  /*
     * Clear all of the context.
     *
     * @return {Raven}
     */
  clearContext: function() {
    this._globalContext = {};

    return this;
  },

  /*
     * Get a copy of the current context. This cannot be mutated.
     *
     * @return {object} copy of context
     */
  getContext: function() {
    // lol javascript
    return JSON.parse(stringify(this._globalContext));
  },

  /*
     * Set environment of application
     *
     * @param {string} environment Typically something like 'production'.
     * @return {Raven}
     */
  setEnvironment: function(environment) {
    this._globalOptions.environment = environment;

    return this;
  },

  /*
     * Set release version of application
     *
     * @param {string} release Typically something like a git SHA to identify version
     * @return {Raven}
     */
  setRelease: function(release) {
    this._globalOptions.release = release;

    return this;
  },

  /*
     * Set the dataCallback option
     *
     * @param {function} callback The callback to run which allows the
     *                            data blob to be mutated before sending
     * @return {Raven}
     */
  setDataCallback: function(callback) {
    var original = this._globalOptions.dataCallback;
    this._globalOptions.dataCallback = keepOriginalCallback(original, callback);
    return this;
  },

  /*
     * Set the breadcrumbCallback option
     *
     * @param {function} callback The callback to run which allows filtering
     *                            or mutating breadcrumbs
     * @return {Raven}
     */
  setBreadcrumbCallback: function(callback) {
    var original = this._globalOptions.breadcrumbCallback;
    this._globalOptions.breadcrumbCallback = keepOriginalCallback(original, callback);
    return this;
  },

  /*
     * Set the shouldSendCallback option
     *
     * @param {function} callback The callback to run which allows
     *                            introspecting the blob before sending
     * @return {Raven}
     */
  setShouldSendCallback: function(callback) {
    var original = this._globalOptions.shouldSendCallback;
    this._globalOptions.shouldSendCallback = keepOriginalCallback(original, callback);
    return this;
  },

  /**
   * Override the default HTTP transport mechanism that transmits data
   * to the Sentry server.
   *
   * @param {function} transport Function invoked instead of the default
   *                             `makeRequest` handler.
   *
   * @return {Raven}
   */
  setTransport: function(transport) {
    this._globalOptions.transport = transport;

    return this;
  },

  /*
     * Get the latest raw exception that was captured by Raven.
     *
     * @return {error}
     */
  lastException: function() {
    return this._lastCapturedException;
  },

  /*
     * Get the last event id
     *
     * @return {string}
     */
  lastEventId: function() {
    return this._lastEventId;
  },

  /*
     * Determine if Raven is setup and ready to go.
     *
     * @return {boolean}
     */
  isSetup: function() {
    if (!this._hasJSON) return false; // needs JSON support
    if (!this._globalServer) {
      if (!this.ravenNotConfiguredError) {
        this.ravenNotConfiguredError = true;
        this._logDebug('error', 'Error: Raven has not been configured.');
      }
      return false;
    }
    return true;
  },

  afterLoad: function() {
    // TODO: remove window dependence?

    // Attempt to initialize Raven on load
    var RavenConfig = _window.RavenConfig;
    if (RavenConfig) {
      this.config(RavenConfig.dsn, RavenConfig.config).install();
    }
  },

  showReportDialog: function(options) {
    if (
      !_document // doesn't work without a document (React native)
    )
      return;

    options = objectMerge(
      {
        eventId: this.lastEventId(),
        dsn: this._dsn,
        user: this._globalContext.user || {}
      },
      options
    );

    if (!options.eventId) {
      throw new RavenConfigError('Missing eventId');
    }

    if (!options.dsn) {
      throw new RavenConfigError('Missing DSN');
    }

    var encode = encodeURIComponent;
    var encodedOptions = [];

    for (var key in options) {
      if (key === 'user') {
        var user = options.user;
        if (user.name) encodedOptions.push('name=' + encode(user.name));
        if (user.email) encodedOptions.push('email=' + encode(user.email));
      } else {
        encodedOptions.push(encode(key) + '=' + encode(options[key]));
      }
    }
    var globalServer = this._getGlobalServer(this._parseDSN(options.dsn));

    var script = _document.createElement('script');
    script.async = true;
    script.src = globalServer + '/api/embed/error-page/?' + encodedOptions.join('&');
    (_document.head || _document.body).appendChild(script);
  },

  /**** Private functions ****/
  _ignoreNextOnError: function() {
    var self = this;
    this._ignoreOnError += 1;
    setTimeout(function() {
      // onerror should trigger before setTimeout
      self._ignoreOnError -= 1;
    });
  },

  _triggerEvent: function(eventType, options) {
    // NOTE: `event` is a native browser thing, so let's avoid conflicting wiht it
    var evt, key;

    if (!this._hasDocument) return;

    options = options || {};

    eventType = 'raven' + eventType.substr(0, 1).toUpperCase() + eventType.substr(1);

    if (_document.createEvent) {
      evt = _document.createEvent('HTMLEvents');
      evt.initEvent(eventType, true, true);
    } else {
      evt = _document.createEventObject();
      evt.eventType = eventType;
    }

    for (key in options)
      if (hasKey(options, key)) {
        evt[key] = options[key];
      }

    if (_document.createEvent) {
      // IE9 if standards
      _document.dispatchEvent(evt);
    } else {
      // IE8 regardless of Quirks or Standards
      // IE9 if quirks
      try {
        _document.fireEvent('on' + evt.eventType.toLowerCase(), evt);
      } catch (e) {
        // Do nothing
      }
    }
  },

  /**
   * Wraps addEventListener to capture UI breadcrumbs
   * @param evtName the event name (e.g. "click")
   * @returns {Function}
   * @private
   */
  _breadcrumbEventHandler: function(evtName) {
    var self = this;
    return function(evt) {
      // reset keypress timeout; e.g. triggering a 'click' after
      // a 'keypress' will reset the keypress debounce so that a new
      // set of keypresses can be recorded
      self._keypressTimeout = null;

      // It's possible this handler might trigger multiple times for the same
      // event (e.g. event propagation through node ancestors). Ignore if we've
      // already captured the event.
      if (self._lastCapturedEvent === evt) return;

      self._lastCapturedEvent = evt;

      // try/catch both:
      // - accessing evt.target (see getsentry/raven-js#838, #768)
      // - `htmlTreeAsString` because it's complex, and just accessing the DOM incorrectly
      //   can throw an exception in some circumstances.
      var target;
      try {
        target = htmlTreeAsString(evt.target);
      } catch (e) {
        target = '<unknown>';
      }

      self.captureBreadcrumb({
        category: 'ui.' + evtName, // e.g. ui.click, ui.input
        message: target
      });
    };
  },

  /**
   * Wraps addEventListener to capture keypress UI events
   * @returns {Function}
   * @private
   */
  _keypressEventHandler: function() {
    var self = this,
      debounceDuration = 1000; // milliseconds

    // TODO: if somehow user switches keypress target before
    //       debounce timeout is triggered, we will only capture
    //       a single breadcrumb from the FIRST target (acceptable?)
    return function(evt) {
      var target;
      try {
        target = evt.target;
      } catch (e) {
        // just accessing event properties can throw an exception in some rare circumstances
        // see: https://github.com/getsentry/raven-js/issues/838
        return;
      }
      var tagName = target && target.tagName;

      // only consider keypress events on actual input elements
      // this will disregard keypresses targeting body (e.g. tabbing
      // through elements, hotkeys, etc)
      if (
        !tagName ||
        (tagName !== 'INPUT' && tagName !== 'TEXTAREA' && !target.isContentEditable)
      )
        return;

      // record first keypress in a series, but ignore subsequent
      // keypresses until debounce clears
      var timeout = self._keypressTimeout;
      if (!timeout) {
        self._breadcrumbEventHandler('input')(evt);
      }
      clearTimeout(timeout);
      self._keypressTimeout = setTimeout(function() {
        self._keypressTimeout = null;
      }, debounceDuration);
    };
  },

  /**
   * Captures a breadcrumb of type "navigation", normalizing input URLs
   * @param to the originating URL
   * @param from the target URL
   * @private
   */
  _captureUrlChange: function(from, to) {
    var parsedLoc = parseUrl(this._location.href);
    var parsedTo = parseUrl(to);
    var parsedFrom = parseUrl(from);

    // because onpopstate only tells you the "new" (to) value of location.href, and
    // not the previous (from) value, we need to track the value of the current URL
    // state ourselves
    this._lastHref = to;

    // Use only the path component of the URL if the URL matches the current
    // document (almost all the time when using pushState)
    if (parsedLoc.protocol === parsedTo.protocol && parsedLoc.host === parsedTo.host)
      to = parsedTo.relative;
    if (parsedLoc.protocol === parsedFrom.protocol && parsedLoc.host === parsedFrom.host)
      from = parsedFrom.relative;

    this.captureBreadcrumb({
      category: 'navigation',
      data: {
        to: to,
        from: from
      }
    });
  },

  _patchFunctionToString: function() {
    var self = this;
    self._originalFunctionToString = Function.prototype.toString;
    // eslint-disable-next-line no-extend-native
    Function.prototype.toString = function() {
      if (typeof this === 'function' && this.__raven__) {
        return self._originalFunctionToString.apply(this.__orig__, arguments);
      }
      return self._originalFunctionToString.apply(this, arguments);
    };
  },

  _unpatchFunctionToString: function() {
    if (this._originalFunctionToString) {
      // eslint-disable-next-line no-extend-native
      Function.prototype.toString = this._originalFunctionToString;
    }
  },

  /**
   * Wrap timer functions and event targets to catch errors and provide
   * better metadata.
   */
  _instrumentTryCatch: function() {
    var self = this;

    var wrappedBuiltIns = self._wrappedBuiltIns;

    function wrapTimeFn(orig) {
      return function(fn, t) {
        // preserve arity
        // Make a copy of the arguments to prevent deoptimization
        // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; ++i) {
          args[i] = arguments[i];
        }
        var originalCallback = args[0];
        if (isFunction(originalCallback)) {
          args[0] = self.wrap(
            {
              mechanism: {
                type: 'instrument',
                data: {function: orig.name || '<anonymous>'}
              }
            },
            originalCallback
          );
        }

        // IE < 9 doesn't support .call/.apply on setInterval/setTimeout, but it
        // also supports only two arguments and doesn't care what this is, so we
        // can just call the original function directly.
        if (orig.apply) {
          return orig.apply(this, args);
        } else {
          return orig(args[0], args[1]);
        }
      };
    }

    var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

    function wrapEventTarget(global) {
      var proto = _window[global] && _window[global].prototype;
      if (proto && proto.hasOwnProperty && proto.hasOwnProperty('addEventListener')) {
        fill(
          proto,
          'addEventListener',
          function(orig) {
            return function(evtName, fn, capture, secure) {
              // preserve arity
              try {
                if (fn && fn.handleEvent) {
                  fn.handleEvent = self.wrap(
                    {
                      mechanism: {
                        type: 'instrument',
                        data: {
                          target: global,
                          function: 'handleEvent',
                          handler: (fn && fn.name) || '<anonymous>'
                        }
                      }
                    },
                    fn.handleEvent
                  );
                }
              } catch (err) {
                // can sometimes get 'Permission denied to access property "handle Event'
              }

              // More breadcrumb DOM capture ... done here and not in `_instrumentBreadcrumbs`
              // so that we don't have more than one wrapper function
              var before, clickHandler, keypressHandler;

              if (
                autoBreadcrumbs &&
                autoBreadcrumbs.dom &&
                (global === 'EventTarget' || global === 'Node')
              ) {
                // NOTE: generating multiple handlers per addEventListener invocation, should
                //       revisit and verify we can just use one (almost certainly)
                clickHandler = self._breadcrumbEventHandler('click');
                keypressHandler = self._keypressEventHandler();
                before = function(evt) {
                  // need to intercept every DOM event in `before` argument, in case that
                  // same wrapped method is re-used for different events (e.g. mousemove THEN click)
                  // see #724
                  if (!evt) return;

                  var eventType;
                  try {
                    eventType = evt.type;
                  } catch (e) {
                    // just accessing event properties can throw an exception in some rare circumstances
                    // see: https://github.com/getsentry/raven-js/issues/838
                    return;
                  }
                  if (eventType === 'click') return clickHandler(evt);
                  else if (eventType === 'keypress') return keypressHandler(evt);
                };
              }
              return orig.call(
                this,
                evtName,
                self.wrap(
                  {
                    mechanism: {
                      type: 'instrument',
                      data: {
                        target: global,
                        function: 'addEventListener',
                        handler: (fn && fn.name) || '<anonymous>'
                      }
                    }
                  },
                  fn,
                  before
                ),
                capture,
                secure
              );
            };
          },
          wrappedBuiltIns
        );
        fill(
          proto,
          'removeEventListener',
          function(orig) {
            return function(evt, fn, capture, secure) {
              try {
                fn = fn && (fn.__raven_wrapper__ ? fn.__raven_wrapper__ : fn);
              } catch (e) {
                // ignore, accessing __raven_wrapper__ will throw in some Selenium environments
              }
              return orig.call(this, evt, fn, capture, secure);
            };
          },
          wrappedBuiltIns
        );
      }
    }

    fill(_window, 'setTimeout', wrapTimeFn, wrappedBuiltIns);
    fill(_window, 'setInterval', wrapTimeFn, wrappedBuiltIns);
    if (_window.requestAnimationFrame) {
      fill(
        _window,
        'requestAnimationFrame',
        function(orig) {
          return function(cb) {
            return orig(
              self.wrap(
                {
                  mechanism: {
                    type: 'instrument',
                    data: {
                      function: 'requestAnimationFrame',
                      handler: (orig && orig.name) || '<anonymous>'
                    }
                  }
                },
                cb
              )
            );
          };
        },
        wrappedBuiltIns
      );
    }

    // event targets borrowed from bugsnag-js:
    // https://github.com/bugsnag/bugsnag-js/blob/master/src/bugsnag.js#L666
    var eventTargets = [
      'EventTarget',
      'Window',
      'Node',
      'ApplicationCache',
      'AudioTrackList',
      'ChannelMergerNode',
      'CryptoOperation',
      'EventSource',
      'FileReader',
      'HTMLUnknownElement',
      'IDBDatabase',
      'IDBRequest',
      'IDBTransaction',
      'KeyOperation',
      'MediaController',
      'MessagePort',
      'ModalWindow',
      'Notification',
      'SVGElementInstance',
      'Screen',
      'TextTrack',
      'TextTrackCue',
      'TextTrackList',
      'WebSocket',
      'WebSocketWorker',
      'Worker',
      'XMLHttpRequest',
      'XMLHttpRequestEventTarget',
      'XMLHttpRequestUpload'
    ];
    for (var i = 0; i < eventTargets.length; i++) {
      wrapEventTarget(eventTargets[i]);
    }
  },

  /**
   * Instrument browser built-ins w/ breadcrumb capturing
   *  - XMLHttpRequests
   *  - DOM interactions (click/typing)
   *  - window.location changes
   *  - console
   *
   * Can be disabled or individually configured via the `autoBreadcrumbs` config option
   */
  _instrumentBreadcrumbs: function() {
    var self = this;
    var autoBreadcrumbs = this._globalOptions.autoBreadcrumbs;

    var wrappedBuiltIns = self._wrappedBuiltIns;

    function wrapProp(prop, xhr) {
      if (prop in xhr && isFunction(xhr[prop])) {
        fill(xhr, prop, function(orig) {
          return self.wrap(
            {
              mechanism: {
                type: 'instrument',
                data: {function: prop, handler: (orig && orig.name) || '<anonymous>'}
              }
            },
            orig
          );
        }); // intentionally don't track filled methods on XHR instances
      }
    }

    if (autoBreadcrumbs.xhr && 'XMLHttpRequest' in _window) {
      var xhrproto = _window.XMLHttpRequest && _window.XMLHttpRequest.prototype;
      fill(
        xhrproto,
        'open',
        function(origOpen) {
          return function(method, url) {
            // preserve arity

            // if Sentry key appears in URL, don't capture
            if (isString(url) && url.indexOf(self._globalKey) === -1) {
              this.__raven_xhr = {
                method: method,
                url: url,
                status_code: null
              };
            }

            return origOpen.apply(this, arguments);
          };
        },
        wrappedBuiltIns
      );

      fill(
        xhrproto,
        'send',
        function(origSend) {
          return function() {
            // preserve arity
            var xhr = this;

            function onreadystatechangeHandler() {
              if (xhr.__raven_xhr && xhr.readyState === 4) {
                try {
                  // touching statusCode in some platforms throws
                  // an exception
                  xhr.__raven_xhr.status_code = xhr.status;
                } catch (e) {
                  /* do nothing */
                }

                self.captureBreadcrumb({
                  type: 'http',
                  category: 'xhr',
                  data: xhr.__raven_xhr
                });
              }
            }

            var props = ['onload', 'onerror', 'onprogress'];
            for (var j = 0; j < props.length; j++) {
              wrapProp(props[j], xhr);
            }

            if ('onreadystatechange' in xhr && isFunction(xhr.onreadystatechange)) {
              fill(
                xhr,
                'onreadystatechange',
                function(orig) {
                  return self.wrap(
                    {
                      mechanism: {
                        type: 'instrument',
                        data: {
                          function: 'onreadystatechange',
                          handler: (orig && orig.name) || '<anonymous>'
                        }
                      }
                    },
                    orig,
                    onreadystatechangeHandler
                  );
                } /* intentionally don't track this instrumentation */
              );
            } else {
              // if onreadystatechange wasn't actually set by the page on this xhr, we
              // are free to set our own and capture the breadcrumb
              xhr.onreadystatechange = onreadystatechangeHandler;
            }

            return origSend.apply(this, arguments);
          };
        },
        wrappedBuiltIns
      );
    }

    if (autoBreadcrumbs.xhr && supportsFetch()) {
      fill(
        _window,
        'fetch',
        function(origFetch) {
          return function() {
            // preserve arity
            // Make a copy of the arguments to prevent deoptimization
            // https://github.com/petkaantonov/bluebird/wiki/Optimization-killers#32-leaking-arguments
            var args = new Array(arguments.length);
            for (var i = 0; i < args.length; ++i) {
              args[i] = arguments[i];
            }

            var fetchInput = args[0];
            var method = 'GET';
            var url;

            if (typeof fetchInput === 'string') {
              url = fetchInput;
            } else if ('Request' in _window && fetchInput instanceof _window.Request) {
              url = fetchInput.url;
              if (fetchInput.method) {
                method = fetchInput.method;
              }
            } else {
              url = '' + fetchInput;
            }

            // if Sentry key appears in URL, don't capture, as it's our own request
            if (url.indexOf(self._globalKey) !== -1) {
              return origFetch.apply(this, args);
            }

            if (args[1] && args[1].method) {
              method = args[1].method;
            }

            var fetchData = {
              method: method,
              url: url,
              status_code: null
            };

            return origFetch
              .apply(this, args)
              .then(function(response) {
                fetchData.status_code = response.status;

                self.captureBreadcrumb({
                  type: 'http',
                  category: 'fetch',
                  data: fetchData
                });

                return response;
              })
              ['catch'](function(err) {
                // if there is an error performing the request
                self.captureBreadcrumb({
                  type: 'http',
                  category: 'fetch',
                  data: fetchData,
                  level: 'error'
                });

                throw err;
              });
          };
        },
        wrappedBuiltIns
      );
    }

    // Capture breadcrumbs from any click that is unhandled / bubbled up all the way
    // to the document. Do this before we instrument addEventListener.
    if (autoBreadcrumbs.dom && this._hasDocument) {
      if (_document.addEventListener) {
        _document.addEventListener('click', self._breadcrumbEventHandler('click'), false);
        _document.addEventListener('keypress', self._keypressEventHandler(), false);
      } else if (_document.attachEvent) {
        // IE8 Compatibility
        _document.attachEvent('onclick', self._breadcrumbEventHandler('click'));
        _document.attachEvent('onkeypress', self._keypressEventHandler());
      }
    }

    // record navigation (URL) changes
    // NOTE: in Chrome App environment, touching history.pushState, *even inside
    //       a try/catch block*, will cause Chrome to output an error to console.error
    // borrowed from: https://github.com/angular/angular.js/pull/13945/files
    var chrome = _window.chrome;
    var isChromePackagedApp = chrome && chrome.app && chrome.app.runtime;
    var hasPushAndReplaceState =
      !isChromePackagedApp &&
      _window.history &&
      _window.history.pushState &&
      _window.history.replaceState;
    if (autoBreadcrumbs.location && hasPushAndReplaceState) {
      // TODO: remove onpopstate handler on uninstall()
      var oldOnPopState = _window.onpopstate;
      _window.onpopstate = function() {
        var currentHref = self._location.href;
        self._captureUrlChange(self._lastHref, currentHref);

        if (oldOnPopState) {
          return oldOnPopState.apply(this, arguments);
        }
      };

      var historyReplacementFunction = function(origHistFunction) {
        // note history.pushState.length is 0; intentionally not declaring
        // params to preserve 0 arity
        return function(/* state, title, url */) {
          var url = arguments.length > 2 ? arguments[2] : undefined;

          // url argument is optional
          if (url) {
            // coerce to string (this is what pushState does)
            self._captureUrlChange(self._lastHref, url + '');
          }

          return origHistFunction.apply(this, arguments);
        };
      };

      fill(_window.history, 'pushState', historyReplacementFunction, wrappedBuiltIns);
      fill(_window.history, 'replaceState', historyReplacementFunction, wrappedBuiltIns);
    }

    if (autoBreadcrumbs.console && 'console' in _window && console.log) {
      // console
      var consoleMethodCallback = function(msg, data) {
        self.captureBreadcrumb({
          message: msg,
          level: data.level,
          category: 'console'
        });
      };

      each(['debug', 'info', 'warn', 'error', 'log'], function(_, level) {
        wrapConsoleMethod(console, level, consoleMethodCallback);
      });
    }
  },

  _restoreBuiltIns: function() {
    // restore any wrapped builtins
    var builtin;
    while (this._wrappedBuiltIns.length) {
      builtin = this._wrappedBuiltIns.shift();

      var obj = builtin[0],
        name = builtin[1],
        orig = builtin[2];

      obj[name] = orig;
    }
  },

  _restoreConsole: function() {
    // eslint-disable-next-line guard-for-in
    for (var method in this._originalConsoleMethods) {
      this._originalConsole[method] = this._originalConsoleMethods[method];
    }
  },

  _drainPlugins: function() {
    var self = this;

    // FIX ME TODO
    each(this._plugins, function(_, plugin) {
      var installer = plugin[0];
      var args = plugin[1];
      installer.apply(self, [self].concat(args));
    });
  },

  _parseDSN: function(str) {
    var m = dsnPattern.exec(str),
      dsn = {},
      i = 7;

    try {
      while (i--) dsn[dsnKeys[i]] = m[i] || '';
    } catch (e) {
      throw new RavenConfigError('Invalid DSN: ' + str);
    }

    if (dsn.pass && !this._globalOptions.allowSecretKey) {
      throw new RavenConfigError(
        'Do not specify your secret key in the DSN. See: http://bit.ly/raven-secret-key'
      );
    }

    return dsn;
  },

  _getGlobalServer: function(uri) {
    // assemble the endpoint from the uri pieces
    var globalServer = '//' + uri.host + (uri.port ? ':' + uri.port : '');

    if (uri.protocol) {
      globalServer = uri.protocol + ':' + globalServer;
    }
    return globalServer;
  },

  _handleOnErrorStackInfo: function(stackInfo, options) {
    options = options || {};
    options.mechanism = options.mechanism || {
      type: 'onerror',
      handled: false
    };

    // if we are intentionally ignoring errors via onerror, bail out
    if (!this._ignoreOnError) {
      this._handleStackInfo(stackInfo, options);
    }
  },

  _handleStackInfo: function(stackInfo, options) {
    var frames = this._prepareFrames(stackInfo, options);

    this._triggerEvent('handle', {
      stackInfo: stackInfo,
      options: options
    });

    this._processException(
      stackInfo.name,
      stackInfo.message,
      stackInfo.url,
      stackInfo.lineno,
      frames,
      options
    );
  },

  _prepareFrames: function(stackInfo, options) {
    var self = this;
    var frames = [];
    if (stackInfo.stack && stackInfo.stack.length) {
      each(stackInfo.stack, function(i, stack) {
        var frame = self._normalizeFrame(stack, stackInfo.url);
        if (frame) {
          frames.push(frame);
        }
      });

      // e.g. frames captured via captureMessage throw
      if (options && options.trimHeadFrames) {
        for (var j = 0; j < options.trimHeadFrames && j < frames.length; j++) {
          frames[j].in_app = false;
        }
      }
    }
    frames = frames.slice(0, this._globalOptions.stackTraceLimit);
    return frames;
  },

  _normalizeFrame: function(frame, stackInfoUrl) {
    // normalize the frames data
    var normalized = {
      filename: frame.url,
      lineno: frame.line,
      colno: frame.column,
      function: frame.func || '?'
    };

    // Case when we don't have any information about the error
    // E.g. throwing a string or raw object, instead of an `Error` in Firefox
    // Generating synthetic error doesn't add any value here
    //
    // We should probably somehow let a user know that they should fix their code
    if (!frame.url) {
      normalized.filename = stackInfoUrl; // fallback to whole stacks url from onerror handler
    }

    normalized.in_app = !// determine if an exception came from outside of our app
    // first we check the global includePaths list.
    (
      (!!this._globalOptions.includePaths.test &&
        !this._globalOptions.includePaths.test(normalized.filename)) ||
      // Now we check for fun, if the function name is Raven or TraceKit
      /(Raven|TraceKit)\./.test(normalized['function']) ||
      // finally, we do a last ditch effort and check for raven.min.js
      /raven\.(min\.)?js$/.test(normalized.filename)
    );

    return normalized;
  },

  _processException: function(type, message, fileurl, lineno, frames, options) {
    var prefixedMessage = (type ? type + ': ' : '') + (message || '');
    if (
      !!this._globalOptions.ignoreErrors.test &&
      (this._globalOptions.ignoreErrors.test(message) ||
        this._globalOptions.ignoreErrors.test(prefixedMessage))
    ) {
      return;
    }

    var stacktrace;

    if (frames && frames.length) {
      fileurl = frames[0].filename || fileurl;
      // Sentry expects frames oldest to newest
      // and JS sends them as newest to oldest
      frames.reverse();
      stacktrace = {frames: frames};
    } else if (fileurl) {
      stacktrace = {
        frames: [
          {
            filename: fileurl,
            lineno: lineno,
            in_app: true
          }
        ]
      };
    }

    if (
      !!this._globalOptions.ignoreUrls.test &&
      this._globalOptions.ignoreUrls.test(fileurl)
    ) {
      return;
    }

    if (
      !!this._globalOptions.whitelistUrls.test &&
      !this._globalOptions.whitelistUrls.test(fileurl)
    ) {
      return;
    }

    var data = objectMerge(
      {
        // sentry.interfaces.Exception
        exception: {
          values: [
            {
              type: type,
              value: message,
              stacktrace: stacktrace
            }
          ]
        },
        transaction: fileurl
      },
      options
    );

    var ex = data.exception.values[0];
    if (ex.type == null && ex.value === '') {
      ex.value = 'Unrecoverable error caught';
    }

    // Move mechanism from options to exception interface
    // We do this, as requiring user to pass `{exception:{mechanism:{ ... }}}` would be
    // too much
    if (!data.exception.mechanism && data.mechanism) {
      data.exception.mechanism = data.mechanism;
      delete data.mechanism;
    }

    data.exception.mechanism = objectMerge(
      {
        type: 'generic',
        handled: true
      },
      data.exception.mechanism || {}
    );

    // Fire away!
    this._send(data);
  },

  _trimPacket: function(data) {
    // For now, we only want to truncate the two different messages
    // but this could/should be expanded to just trim everything
    var max = this._globalOptions.maxMessageLength;
    if (data.message) {
      data.message = truncate(data.message, max);
    }
    if (data.exception) {
      var exception = data.exception.values[0];
      exception.value = truncate(exception.value, max);
    }

    var request = data.request;
    if (request) {
      if (request.url) {
        request.url = truncate(request.url, this._globalOptions.maxUrlLength);
      }
      if (request.Referer) {
        request.Referer = truncate(request.Referer, this._globalOptions.maxUrlLength);
      }
    }

    if (data.breadcrumbs && data.breadcrumbs.values)
      this._trimBreadcrumbs(data.breadcrumbs);

    return data;
  },

  /**
   * Truncate breadcrumb values (right now just URLs)
   */
  _trimBreadcrumbs: function(breadcrumbs) {
    // known breadcrumb properties with urls
    // TODO: also consider arbitrary prop values that start with (https?)?://
    var urlProps = ['to', 'from', 'url'],
      urlProp,
      crumb,
      data;

    for (var i = 0; i < breadcrumbs.values.length; ++i) {
      crumb = breadcrumbs.values[i];
      if (
        !crumb.hasOwnProperty('data') ||
        !isObject(crumb.data) ||
        objectFrozen(crumb.data)
      )
        continue;

      data = objectMerge({}, crumb.data);
      for (var j = 0; j < urlProps.length; ++j) {
        urlProp = urlProps[j];
        if (data.hasOwnProperty(urlProp) && data[urlProp]) {
          data[urlProp] = truncate(data[urlProp], this._globalOptions.maxUrlLength);
        }
      }
      breadcrumbs.values[i].data = data;
    }
  },

  _getHttpData: function() {
    if (!this._hasNavigator && !this._hasDocument) return;
    var httpData = {};

    if (this._hasNavigator && _navigator.userAgent) {
      httpData.headers = {
        'User-Agent': _navigator.userAgent
      };
    }

    // Check in `window` instead of `document`, as we may be in ServiceWorker environment
    if (_window.location && _window.location.href) {
      httpData.url = _window.location.href;
    }

    if (this._hasDocument && _document.referrer) {
      if (!httpData.headers) httpData.headers = {};
      httpData.headers.Referer = _document.referrer;
    }

    return httpData;
  },

  _resetBackoff: function() {
    this._backoffDuration = 0;
    this._backoffStart = null;
  },

  _shouldBackoff: function() {
    return this._backoffDuration && now() - this._backoffStart < this._backoffDuration;
  },

  /**
   * Returns true if the in-process data payload matches the signature
   * of the previously-sent data
   *
   * NOTE: This has to be done at this level because TraceKit can generate
   *       data from window.onerror WITHOUT an exception object (IE8, IE9,
   *       other old browsers). This can take the form of an "exception"
   *       data object with a single frame (derived from the onerror args).
   */
  _isRepeatData: function(current) {
    var last = this._lastData;

    if (
      !last ||
      current.message !== last.message || // defined for captureMessage
      current.transaction !== last.transaction // defined for captureException/onerror
    )
      return false;

    // Stacktrace interface (i.e. from captureMessage)
    if (current.stacktrace || last.stacktrace) {
      return isSameStacktrace(current.stacktrace, last.stacktrace);
    } else if (current.exception || last.exception) {
      // Exception interface (i.e. from captureException/onerror)
      return isSameException(current.exception, last.exception);
    } else if (current.fingerprint || last.fingerprint) {
      return Boolean(current.fingerprint && last.fingerprint) &&
        JSON.stringify(current.fingerprint) === JSON.stringify(last.fingerprint)
    }

    return true;
  },

  _setBackoffState: function(request) {
    // If we are already in a backoff state, don't change anything
    if (this._shouldBackoff()) {
      return;
    }

    var status = request.status;

    // 400 - project_id doesn't exist or some other fatal
    // 401 - invalid/revoked dsn
    // 429 - too many requests
    if (!(status === 400 || status === 401 || status === 429)) return;

    var retry;
    try {
      // If Retry-After is not in Access-Control-Expose-Headers, most
      // browsers will throw an exception trying to access it
      if (supportsFetch()) {
        retry = request.headers.get('Retry-After');
      } else {
        retry = request.getResponseHeader('Retry-After');
      }

      // Retry-After is returned in seconds
      retry = parseInt(retry, 10) * 1000;
    } catch (e) {
      /* eslint no-empty:0 */
    }

    this._backoffDuration = retry
      ? // If Sentry server returned a Retry-After value, use it
        retry
      : // Otherwise, double the last backoff duration (starts at 1 sec)
        this._backoffDuration * 2 || 1000;

    this._backoffStart = now();
  },

  _send: function(data) {
    var globalOptions = this._globalOptions;

    var baseData = {
        project: this._globalProject,
        logger: globalOptions.logger,
        platform: 'javascript'
      },
      httpData = this._getHttpData();

    if (httpData) {
      baseData.request = httpData;
    }

    // HACK: delete `trimHeadFrames` to prevent from appearing in outbound payload
    if (data.trimHeadFrames) delete data.trimHeadFrames;

    data = objectMerge(baseData, data);

    // Merge in the tags and extra separately since objectMerge doesn't handle a deep merge
    data.tags = objectMerge(objectMerge({}, this._globalContext.tags), data.tags);
    data.extra = objectMerge(objectMerge({}, this._globalContext.extra), data.extra);

    // Send along our own collected metadata with extra
    data.extra['session:duration'] = now() - this._startTime;

    if (this._breadcrumbs && this._breadcrumbs.length > 0) {
      // intentionally make shallow copy so that additions
      // to breadcrumbs aren't accidentally sent in this request
      data.breadcrumbs = {
        values: [].slice.call(this._breadcrumbs, 0)
      };
    }

    if (this._globalContext.user) {
      // sentry.interfaces.User
      data.user = this._globalContext.user;
    }

    // Include the environment if it's defined in globalOptions
    if (globalOptions.environment) data.environment = globalOptions.environment;

    // Include the release if it's defined in globalOptions
    if (globalOptions.release) data.release = globalOptions.release;

    // Include server_name if it's defined in globalOptions
    if (globalOptions.serverName) data.server_name = globalOptions.serverName;

    data = this._sanitizeData(data);

    // Cleanup empty properties before sending them to the server
    Object.keys(data).forEach(function(key) {
      if (data[key] == null || data[key] === '' || isEmptyObject(data[key])) {
        delete data[key];
      }
    });

    if (isFunction(globalOptions.dataCallback)) {
      data = globalOptions.dataCallback(data) || data;
    }

    // Why??????????
    if (!data || isEmptyObject(data)) {
      return;
    }

    // Check if the request should be filtered or not
    if (
      isFunction(globalOptions.shouldSendCallback) &&
      !globalOptions.shouldSendCallback(data)
    ) {
      return;
    }

    // Backoff state: Sentry server previously responded w/ an error (e.g. 429 - too many requests),
    // so drop requests until "cool-off" period has elapsed.
    if (this._shouldBackoff()) {
      this._logDebug('warn', 'Raven dropped error due to backoff: ', data);
      return;
    }

    if (typeof globalOptions.sampleRate === 'number') {
      if (Math.random() < globalOptions.sampleRate) {
        this._sendProcessedPayload(data);
      }
    } else {
      this._sendProcessedPayload(data);
    }
  },

  _sanitizeData: function(data) {
    return sanitize(data, this._globalOptions.sanitizeKeys);
  },

  _getUuid: function() {
    return uuid4();
  },

  _sendProcessedPayload: function(data, callback) {
    var self = this;
    var globalOptions = this._globalOptions;

    if (!this.isSetup()) return;

    // Try and clean up the packet before sending by truncating long values
    data = this._trimPacket(data);

    // ideally duplicate error testing should occur *before* dataCallback/shouldSendCallback,
    // but this would require copying an un-truncated copy of the data packet, which can be
    // arbitrarily deep (extra_data) -- could be worthwhile? will revisit
    if (!this._globalOptions.allowDuplicates && this._isRepeatData(data)) {
      this._logDebug('warn', 'Raven dropped repeat event: ', data);
      return;
    }

    // Send along an event_id if not explicitly passed.
    // This event_id can be used to reference the error within Sentry itself.
    // Set lastEventId after we know the error should actually be sent
    this._lastEventId = data.event_id || (data.event_id = this._getUuid());

    // Store outbound payload after trim
    this._lastData = data;

    this._logDebug('debug', 'Raven about to send:', data);

    var auth = {
      sentry_version: '7',
      sentry_client: 'raven-js/' + this.VERSION,
      sentry_key: this._globalKey
    };

    if (this._globalSecret) {
      auth.sentry_secret = this._globalSecret;
    }

    var exception = data.exception && data.exception.values[0];

    // only capture 'sentry' breadcrumb is autoBreadcrumbs is truthy
    if (
      this._globalOptions.autoBreadcrumbs &&
      this._globalOptions.autoBreadcrumbs.sentry
    ) {
      this.captureBreadcrumb({
        category: 'sentry',
        message: exception
          ? (exception.type ? exception.type + ': ' : '') + exception.value
          : data.message,
        event_id: data.event_id,
        level: data.level || 'error' // presume error unless specified
      });
    }

    var url = this._globalEndpoint;
    (globalOptions.transport || this._makeRequest).call(this, {
      url: url,
      auth: auth,
      data: data,
      options: globalOptions,
      onSuccess: function success() {
        self._resetBackoff();

        self._triggerEvent('success', {
          data: data,
          src: url
        });
        callback && callback();
      },
      onError: function failure(error) {
        self._logDebug('error', 'Raven transport failed to send: ', error);

        if (error.request) {
          self._setBackoffState(error.request);
        }

        self._triggerEvent('failure', {
          data: data,
          src: url
        });
        error = error || new Error('Raven send failed (no additional details provided)');
        callback && callback(error);
      }
    });
  },

  _makeRequest: function(opts) {
    // Auth is intentionally sent as part of query string (NOT as custom HTTP header) to avoid preflight CORS requests
    var url = opts.url + '?' + urlencode(opts.auth);

    var evaluatedHeaders = null;
    var evaluatedFetchParameters = {};

    if (opts.options.headers) {
      evaluatedHeaders = this._evaluateHash(opts.options.headers);
    }

    if (opts.options.fetchParameters) {
      evaluatedFetchParameters = this._evaluateHash(opts.options.fetchParameters);
    }

    if (supportsFetch()) {
      evaluatedFetchParameters.body = stringify(opts.data);

      var defaultFetchOptions = objectMerge({}, this._fetchDefaults);
      var fetchOptions = objectMerge(defaultFetchOptions, evaluatedFetchParameters);

      if (evaluatedHeaders) {
        fetchOptions.headers = evaluatedHeaders;
      }

      return _window
        .fetch(url, fetchOptions)
        .then(function(response) {
          if (response.ok) {
            opts.onSuccess && opts.onSuccess();
          } else {
            var error = new Error('Sentry error code: ' + response.status);
            // It's called request only to keep compatibility with XHR interface
            // and not add more redundant checks in setBackoffState method
            error.request = response;
            opts.onError && opts.onError(error);
          }
        })
        ['catch'](function() {
          opts.onError &&
            opts.onError(new Error('Sentry error code: network unavailable'));
        });
    }

    var request = _window.XMLHttpRequest && new _window.XMLHttpRequest();
    if (!request) return;

    // if browser doesn't support CORS (e.g. IE7), we are out of luck
    var hasCORS = 'withCredentials' in request || typeof XDomainRequest !== 'undefined';

    if (!hasCORS) return;

    if ('withCredentials' in request) {
      request.onreadystatechange = function() {
        if (request.readyState !== 4) {
          return;
        } else if (request.status === 200) {
          opts.onSuccess && opts.onSuccess();
        } else if (opts.onError) {
          var err = new Error('Sentry error code: ' + request.status);
          err.request = request;
          opts.onError(err);
        }
      };
    } else {
      request = new XDomainRequest();
      // xdomainrequest cannot go http -> https (or vice versa),
      // so always use protocol relative
      url = url.replace(/^https?:/, '');

      // onreadystatechange not supported by XDomainRequest
      if (opts.onSuccess) {
        request.onload = opts.onSuccess;
      }
      if (opts.onError) {
        request.onerror = function() {
          var err = new Error('Sentry error code: XDomainRequest');
          err.request = request;
          opts.onError(err);
        };
      }
    }

    request.open('POST', url);

    if (evaluatedHeaders) {
      each(evaluatedHeaders, function(key, value) {
        request.setRequestHeader(key, value);
      });
    }

    request.send(stringify(opts.data));
  },

  _evaluateHash: function(hash) {
    var evaluated = {};

    for (var key in hash) {
      if (hash.hasOwnProperty(key)) {
        var value = hash[key];
        evaluated[key] = typeof value === 'function' ? value() : value;
      }
    }

    return evaluated;
  },

  _logDebug: function(level) {
    // We allow `Raven.debug` and `Raven.config(DSN, { debug: true })` to not make backward incompatible API change
    if (
      this._originalConsoleMethods[level] &&
      (this.debug || this._globalOptions.debug)
    ) {
      // In IE<10 console methods do not have their own 'apply' method
      Function.prototype.apply.call(
        this._originalConsoleMethods[level],
        this._originalConsole,
        [].slice.call(arguments, 1)
      );
    }
  },

  _mergeContext: function(key, context) {
    if (isUndefined(context)) {
      delete this._globalContext[key];
    } else {
      this._globalContext[key] = objectMerge(this._globalContext[key] || {}, context);
    }
  }
};

// Deprecations
Raven.prototype.setUser = Raven.prototype.setUserContext;
Raven.prototype.setReleaseContext = Raven.prototype.setRelease;

module.exports = Raven;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../vendor/TraceKit/tracekit":9,"../vendor/json-stringify-safe/stringify":10,"../vendor/md5/md5":11,"./configError":4,"./console":5,"./utils":8}],7:[function(require,module,exports){
(function (global){
/**
 * Enforces a single instance of the Raven client, and the
 * main entry point for Raven. If you are a consumer of the
 * Raven library, you SHOULD load this file (vs raven.js).
 **/

var RavenConstructor = require('./raven');

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window =
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};
var _Raven = _window.Raven;

var Raven = new RavenConstructor();

/*
 * Allow multiple versions of Raven to be installed.
 * Strip Raven from the global context and returns the instance.
 *
 * @return {Raven}
 */
Raven.noConflict = function() {
  _window.Raven = _Raven;
  return Raven;
};

Raven.afterLoad();

module.exports = Raven;

/**
 * DISCLAIMER:
 *
 * Expose `Client` constructor for cases where user want to track multiple "sub-applications" in one larger app.
 * It's not meant to be used by a wide audience, so pleaaase make sure that you know what you're doing before using it.
 * Accidentally calling `install` multiple times, may result in an unexpected behavior that's very hard to debug.
 *
 * It's called `Client' to be in-line with Raven Node implementation.
 *
 * HOWTO:
 *
 * import Raven from 'raven-js';
 *
 * const someAppReporter = new Raven.Client();
 * const someOtherAppReporter = new Raven.Client();
 *
 * someAppReporter.config('__DSN__', {
 *   ...config goes here
 * });
 *
 * someOtherAppReporter.config('__OTHER_DSN__', {
 *   ...config goes here
 * });
 *
 * someAppReporter.captureMessage(...);
 * someAppReporter.captureException(...);
 * someAppReporter.captureBreadcrumb(...);
 *
 * someOtherAppReporter.captureMessage(...);
 * someOtherAppReporter.captureException(...);
 * someOtherAppReporter.captureBreadcrumb(...);
 *
 * It should "just work".
 */
module.exports.Client = RavenConstructor;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./raven":6}],8:[function(require,module,exports){
(function (global){
var stringify = require('../vendor/json-stringify-safe/stringify');

var _window =
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined'
      ? global
      : typeof self !== 'undefined'
        ? self
        : {};

function isObject(what) {
  return typeof what === 'object' && what !== null;
}

// Yanked from https://git.io/vS8DV re-used under CC0
// with some tiny modifications
function isError(value) {
  switch (Object.prototype.toString.call(value)) {
    case '[object Error]':
      return true;
    case '[object Exception]':
      return true;
    case '[object DOMException]':
      return true;
    default:
      return value instanceof Error;
  }
}

function isErrorEvent(value) {
  return Object.prototype.toString.call(value) === '[object ErrorEvent]';
}

function isDOMError(value) {
  return Object.prototype.toString.call(value) === '[object DOMError]';
}

function isDOMException(value) {
  return Object.prototype.toString.call(value) === '[object DOMException]';
}

function isUndefined(what) {
  return what === void 0;
}

function isFunction(what) {
  return typeof what === 'function';
}

function isPlainObject(what) {
  return Object.prototype.toString.call(what) === '[object Object]';
}

function isString(what) {
  return Object.prototype.toString.call(what) === '[object String]';
}

function isArray(what) {
  return Object.prototype.toString.call(what) === '[object Array]';
}

function isEmptyObject(what) {
  if (!isPlainObject(what)) return false;

  for (var _ in what) {
    if (what.hasOwnProperty(_)) {
      return false;
    }
  }
  return true;
}

function supportsErrorEvent() {
  try {
    new ErrorEvent(''); // eslint-disable-line no-new
    return true;
  } catch (e) {
    return false;
  }
}

function supportsDOMError() {
  try {
    new DOMError(''); // eslint-disable-line no-new
    return true;
  } catch (e) {
    return false;
  }
}

function supportsDOMException() {
  try {
    new DOMException(''); // eslint-disable-line no-new
    return true;
  } catch (e) {
    return false;
  }
}

function supportsFetch() {
  if (!('fetch' in _window)) return false;

  try {
    new Headers(); // eslint-disable-line no-new
    new Request(''); // eslint-disable-line no-new
    new Response(); // eslint-disable-line no-new
    return true;
  } catch (e) {
    return false;
  }
}

// Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default
// https://caniuse.com/#feat=referrer-policy
// It doesn't. And it throw exception instead of ignoring this parameter...
// REF: https://github.com/getsentry/raven-js/issues/1233
function supportsReferrerPolicy() {
  if (!supportsFetch()) return false;

  try {
    // eslint-disable-next-line no-new
    new Request('pickleRick', {
      referrerPolicy: 'origin'
    });
    return true;
  } catch (e) {
    return false;
  }
}

function supportsPromiseRejectionEvent() {
  return typeof PromiseRejectionEvent === 'function';
}

function wrappedCallback(callback) {
  function dataCallback(data, original) {
    var normalizedData = callback(data) || data;
    if (original) {
      return original(normalizedData) || normalizedData;
    }
    return normalizedData;
  }

  return dataCallback;
}

function each(obj, callback) {
  var i, j;

  if (isUndefined(obj.length)) {
    for (i in obj) {
      if (hasKey(obj, i)) {
        callback.call(null, i, obj[i]);
      }
    }
  } else {
    j = obj.length;
    if (j) {
      for (i = 0; i < j; i++) {
        callback.call(null, i, obj[i]);
      }
    }
  }
}

function objectMerge(obj1, obj2) {
  if (!obj2) {
    return obj1;
  }
  each(obj2, function(key, value) {
    obj1[key] = value;
  });
  return obj1;
}

/**
 * This function is only used for react-native.
 * react-native freezes object that have already been sent over the
 * js bridge. We need this function in order to check if the object is frozen.
 * So it's ok that objectFrozen returns false if Object.isFrozen is not
 * supported because it's not relevant for other "platforms". See related issue:
 * https://github.com/getsentry/react-native-sentry/issues/57
 */
function objectFrozen(obj) {
  if (!Object.isFrozen) {
    return false;
  }
  return Object.isFrozen(obj);
}

function truncate(str, max) {
  if (typeof max !== 'number') {
    throw new Error('2nd argument to `truncate` function should be a number');
  }
  if (typeof str !== 'string' || max === 0) {
    return str;
  }
  return str.length <= max ? str : str.substr(0, max) + '\u2026';
}

/**
 * hasKey, a better form of hasOwnProperty
 * Example: hasKey(MainHostObject, property) === true/false
 *
 * @param {Object} host object to check property
 * @param {string} key to check
 */
function hasKey(object, key) {
  return Object.prototype.hasOwnProperty.call(object, key);
}

function joinRegExp(patterns) {
  // Combine an array of regular expressions and strings into one large regexp
  // Be mad.
  var sources = [],
    i = 0,
    len = patterns.length,
    pattern;

  for (; i < len; i++) {
    pattern = patterns[i];
    if (isString(pattern)) {
      // If it's a string, we need to escape it
      // Taken from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
      sources.push(pattern.replace(/([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1'));
    } else if (pattern && pattern.source) {
      // If it's a regexp already, we want to extract the source
      sources.push(pattern.source);
    }
    // Intentionally skip other cases
  }
  return new RegExp(sources.join('|'), 'i');
}

function urlencode(o) {
  var pairs = [];
  each(o, function(key, value) {
    pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(value));
  });
  return pairs.join('&');
}

// borrowed from https://tools.ietf.org/html/rfc3986#appendix-B
// intentionally using regex and not <a/> href parsing trick because React Native and other
// environments where DOM might not be available
function parseUrl(url) {
  if (typeof url !== 'string') return {};
  var match = url.match(/^(([^:\/?#]+):)?(\/\/([^\/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);

  // coerce to undefined values to empty string so we don't get 'undefined'
  var query = match[6] || '';
  var fragment = match[8] || '';
  return {
    protocol: match[2],
    host: match[4],
    path: match[5],
    relative: match[5] + query + fragment // everything minus origin
  };
}
function uuid4() {
  var crypto = _window.crypto || _window.msCrypto;

  if (!isUndefined(crypto) && crypto.getRandomValues) {
    // Use window.crypto API if available
    // eslint-disable-next-line no-undef
    var arr = new Uint16Array(8);
    crypto.getRandomValues(arr);

    // set 4 in byte 7
    arr[3] = (arr[3] & 0xfff) | 0x4000;
    // set 2 most significant bits of byte 9 to '10'
    arr[4] = (arr[4] & 0x3fff) | 0x8000;

    var pad = function(num) {
      var v = num.toString(16);
      while (v.length < 4) {
        v = '0' + v;
      }
      return v;
    };

    return (
      pad(arr[0]) +
      pad(arr[1]) +
      pad(arr[2]) +
      pad(arr[3]) +
      pad(arr[4]) +
      pad(arr[5]) +
      pad(arr[6]) +
      pad(arr[7])
    );
  } else {
    // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/2117523#2117523
    return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
      var r = (Math.random() * 16) | 0,
        v = c === 'x' ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
}

/**
 * Given a child DOM element, returns a query-selector statement describing that
 * and its ancestors
 * e.g. [HTMLElement] => body > div > input#foo.btn[name=baz]
 * @param elem
 * @returns {string}
 */
function htmlTreeAsString(elem) {
  /* eslint no-extra-parens:0*/
  var MAX_TRAVERSE_HEIGHT = 5,
    MAX_OUTPUT_LEN = 80,
    out = [],
    height = 0,
    len = 0,
    separator = ' > ',
    sepLength = separator.length,
    nextStr;

  while (elem && height++ < MAX_TRAVERSE_HEIGHT) {
    nextStr = htmlElementAsString(elem);
    // bail out if
    // - nextStr is the 'html' element
    // - the length of the string that would be created exceeds MAX_OUTPUT_LEN
    //   (ignore this limit if we are on the first iteration)
    if (
      nextStr === 'html' ||
      (height > 1 && len + out.length * sepLength + nextStr.length >= MAX_OUTPUT_LEN)
    ) {
      break;
    }

    out.push(nextStr);

    len += nextStr.length;
    elem = elem.parentNode;
  }

  return out.reverse().join(separator);
}

/**
 * Returns a simple, query-selector representation of a DOM element
 * e.g. [HTMLElement] => input#foo.btn[name=baz]
 * @param HTMLElement
 * @returns {string}
 */
function htmlElementAsString(elem) {
  var out = [],
    className,
    classes,
    key,
    attr,
    i;

  if (!elem || !elem.tagName) {
    return '';
  }

  out.push(elem.tagName.toLowerCase());
  if (elem.id) {
    out.push('#' + elem.id);
  }

  className = elem.className;
  if (className && isString(className)) {
    classes = className.split(/\s+/);
    for (i = 0; i < classes.length; i++) {
      out.push('.' + classes[i]);
    }
  }
  var attrWhitelist = ['type', 'name', 'title', 'alt'];
  for (i = 0; i < attrWhitelist.length; i++) {
    key = attrWhitelist[i];
    attr = elem.getAttribute(key);
    if (attr) {
      out.push('[' + key + '="' + attr + '"]');
    }
  }
  return out.join('');
}

/**
 * Returns true if either a OR b is truthy, but not both
 */
function isOnlyOneTruthy(a, b) {
  return !!(!!a ^ !!b);
}

/**
 * Returns true if both parameters are undefined
 */
function isBothUndefined(a, b) {
  return isUndefined(a) && isUndefined(b);
}

/**
 * Returns true if the two input exception interfaces have the same content
 */
function isSameException(ex1, ex2) {
  if (isOnlyOneTruthy(ex1, ex2)) return false;

  ex1 = ex1.values[0];
  ex2 = ex2.values[0];

  if (ex1.type !== ex2.type || ex1.value !== ex2.value) return false;

  // in case both stacktraces are undefined, we can't decide so default to false
  if (isBothUndefined(ex1.stacktrace, ex2.stacktrace)) return false;

  return isSameStacktrace(ex1.stacktrace, ex2.stacktrace);
}

/**
 * Returns true if the two input stack trace interfaces have the same content
 */
function isSameStacktrace(stack1, stack2) {
  if (isOnlyOneTruthy(stack1, stack2)) return false;

  var frames1 = stack1.frames;
  var frames2 = stack2.frames;

  // Exit early if stacktrace is malformed
  if (frames1 === undefined || frames2 === undefined) return false;

  // Exit early if frame count differs
  if (frames1.length !== frames2.length) return false;

  // Iterate through every frame; bail out if anything differs
  var a, b;
  for (var i = 0; i < frames1.length; i++) {
    a = frames1[i];
    b = frames2[i];
    if (
      a.filename !== b.filename ||
      a.lineno !== b.lineno ||
      a.colno !== b.colno ||
      a['function'] !== b['function']
    )
      return false;
  }
  return true;
}

/**
 * Polyfill a method
 * @param obj object e.g. `document`
 * @param name method name present on object e.g. `addEventListener`
 * @param replacement replacement function
 * @param track {optional} record instrumentation to an array
 */
function fill(obj, name, replacement, track) {
  if (obj == null) return;
  var orig = obj[name];
  obj[name] = replacement(orig);
  obj[name].__raven__ = true;
  obj[name].__orig__ = orig;
  if (track) {
    track.push([obj, name, orig]);
  }
}

/**
 * Join values in array
 * @param input array of values to be joined together
 * @param delimiter string to be placed in-between values
 * @returns {string}
 */
function safeJoin(input, delimiter) {
  if (!isArray(input)) return '';

  var output = [];

  for (var i = 0; i < input.length; i++) {
    try {
      output.push(String(input[i]));
    } catch (e) {
      output.push('[value cannot be serialized]');
    }
  }

  return output.join(delimiter);
}

// Default Node.js REPL depth
var MAX_SERIALIZE_EXCEPTION_DEPTH = 3;
// 50kB, as 100kB is max payload size, so half sounds reasonable
var MAX_SERIALIZE_EXCEPTION_SIZE = 50 * 1024;
var MAX_SERIALIZE_KEYS_LENGTH = 40;

function utf8Length(value) {
  return ~-encodeURI(value).split(/%..|./).length;
}

function jsonSize(value) {
  return utf8Length(JSON.stringify(value));
}

function serializeValue(value) {
  if (typeof value === 'string') {
    var maxLength = 40;
    return truncate(value, maxLength);
  } else if (
    typeof value === 'number' ||
    typeof value === 'boolean' ||
    typeof value === 'undefined'
  ) {
    return value;
  }

  var type = Object.prototype.toString.call(value);

  // Node.js REPL notation
  if (type === '[object Object]') return '[Object]';
  if (type === '[object Array]') return '[Array]';
  if (type === '[object Function]')
    return value.name ? '[Function: ' + value.name + ']' : '[Function]';

  return value;
}

function serializeObject(value, depth) {
  if (depth === 0) return serializeValue(value);

  if (isPlainObject(value)) {
    return Object.keys(value).reduce(function(acc, key) {
      acc[key] = serializeObject(value[key], depth - 1);
      return acc;
    }, {});
  } else if (Array.isArray(value)) {
    return value.map(function(val) {
      return serializeObject(val, depth - 1);
    });
  }

  return serializeValue(value);
}

function serializeException(ex, depth, maxSize) {
  if (!isPlainObject(ex)) return ex;

  depth = typeof depth !== 'number' ? MAX_SERIALIZE_EXCEPTION_DEPTH : depth;
  maxSize = typeof depth !== 'number' ? MAX_SERIALIZE_EXCEPTION_SIZE : maxSize;

  var serialized = serializeObject(ex, depth);

  if (jsonSize(stringify(serialized)) > maxSize) {
    return serializeException(ex, depth - 1);
  }

  return serialized;
}

function serializeKeysForMessage(keys, maxLength) {
  if (typeof keys === 'number' || typeof keys === 'string') return keys.toString();
  if (!Array.isArray(keys)) return '';

  keys = keys.filter(function(key) {
    return typeof key === 'string';
  });
  if (keys.length === 0) return '[object has no keys]';

  maxLength = typeof maxLength !== 'number' ? MAX_SERIALIZE_KEYS_LENGTH : maxLength;
  if (keys[0].length >= maxLength) return keys[0];

  for (var usedKeys = keys.length; usedKeys > 0; usedKeys--) {
    var serialized = keys.slice(0, usedKeys).join(', ');
    if (serialized.length > maxLength) continue;
    if (usedKeys === keys.length) return serialized;
    return serialized + '\u2026';
  }

  return '';
}

function sanitize(input, sanitizeKeys) {
  if (!isArray(sanitizeKeys) || (isArray(sanitizeKeys) && sanitizeKeys.length === 0))
    return input;

  var sanitizeRegExp = joinRegExp(sanitizeKeys);
  var sanitizeMask = '********';
  var safeInput;

  try {
    safeInput = JSON.parse(stringify(input));
  } catch (o_O) {
    return input;
  }

  function sanitizeWorker(workerInput) {
    if (isArray(workerInput)) {
      return workerInput.map(function(val) {
        return sanitizeWorker(val);
      });
    }

    if (isPlainObject(workerInput)) {
      return Object.keys(workerInput).reduce(function(acc, k) {
        if (sanitizeRegExp.test(k)) {
          acc[k] = sanitizeMask;
        } else {
          acc[k] = sanitizeWorker(workerInput[k]);
        }
        return acc;
      }, {});
    }

    return workerInput;
  }

  return sanitizeWorker(safeInput);
}

module.exports = {
  isObject: isObject,
  isError: isError,
  isErrorEvent: isErrorEvent,
  isDOMError: isDOMError,
  isDOMException: isDOMException,
  isUndefined: isUndefined,
  isFunction: isFunction,
  isPlainObject: isPlainObject,
  isString: isString,
  isArray: isArray,
  isEmptyObject: isEmptyObject,
  supportsErrorEvent: supportsErrorEvent,
  supportsDOMError: supportsDOMError,
  supportsDOMException: supportsDOMException,
  supportsFetch: supportsFetch,
  supportsReferrerPolicy: supportsReferrerPolicy,
  supportsPromiseRejectionEvent: supportsPromiseRejectionEvent,
  wrappedCallback: wrappedCallback,
  each: each,
  objectMerge: objectMerge,
  truncate: truncate,
  objectFrozen: objectFrozen,
  hasKey: hasKey,
  joinRegExp: joinRegExp,
  urlencode: urlencode,
  uuid4: uuid4,
  htmlTreeAsString: htmlTreeAsString,
  htmlElementAsString: htmlElementAsString,
  isSameException: isSameException,
  isSameStacktrace: isSameStacktrace,
  parseUrl: parseUrl,
  fill: fill,
  safeJoin: safeJoin,
  serializeException: serializeException,
  serializeKeysForMessage: serializeKeysForMessage,
  sanitize: sanitize
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../vendor/json-stringify-safe/stringify":10}],9:[function(require,module,exports){
(function (global){
var utils = require('../../src/utils');

/*
 TraceKit - Cross brower stack traces

 This was originally forked from github.com/occ/TraceKit, but has since been
 largely re-written and is now maintained as part of raven-js.  Tests for
 this are in test/vendor.

 MIT license
*/

var TraceKit = {
  collectWindowErrors: true,
  debug: false
};

// This is to be defensive in environments where window does not exist (see https://github.com/getsentry/raven-js/pull/785)
var _window =
  typeof window !== 'undefined'
    ? window
    : typeof global !== 'undefined'
    ? global
    : typeof self !== 'undefined'
    ? self
    : {};

// global reference to slice
var _slice = [].slice;
var UNKNOWN_FUNCTION = '?';

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Error_types
var ERROR_TYPES_RE = /^(?:[Uu]ncaught (?:exception: )?)?(?:((?:Eval|Internal|Range|Reference|Syntax|Type|URI|)Error): )?(.*)$/;

function getLocationHref() {
  if (typeof document === 'undefined' || document.location == null) return '';
  return document.location.href;
}

function getLocationOrigin() {
  if (typeof document === 'undefined' || document.location == null) return '';

  // Oh dear IE10...
  if (!document.location.origin) {
    return (
      document.location.protocol +
      '//' +
      document.location.hostname +
      (document.location.port ? ':' + document.location.port : '')
    );
  }

  return document.location.origin;
}

/**
 * TraceKit.report: cross-browser processing of unhandled exceptions
 *
 * Syntax:
 *   TraceKit.report.subscribe(function(stackInfo) { ... })
 *   TraceKit.report.unsubscribe(function(stackInfo) { ... })
 *   TraceKit.report(exception)
 *   try { ...code... } catch(ex) { TraceKit.report(ex); }
 *
 * Supports:
 *   - Firefox: full stack trace with line numbers, plus column number
 *              on top frame; column number is not guaranteed
 *   - Opera:   full stack trace with line and column numbers
 *   - Chrome:  full stack trace with line and column numbers
 *   - Safari:  line and column number for the top frame only; some frames
 *              may be missing, and column number is not guaranteed
 *   - IE:      line and column number for the top frame only; some frames
 *              may be missing, and column number is not guaranteed
 *
 * In theory, TraceKit should work on all of the following versions:
 *   - IE5.5+ (only 8.0 tested)
 *   - Firefox 0.9+ (only 3.5+ tested)
 *   - Opera 7+ (only 10.50 tested; versions 9 and earlier may require
 *     Exceptions Have Stacktrace to be enabled in opera:config)
 *   - Safari 3+ (only 4+ tested)
 *   - Chrome 1+ (only 5+ tested)
 *   - Konqueror 3.5+ (untested)
 *
 * Requires TraceKit.computeStackTrace.
 *
 * Tries to catch all unhandled exceptions and report them to the
 * subscribed handlers. Please note that TraceKit.report will rethrow the
 * exception. This is REQUIRED in order to get a useful stack trace in IE.
 * If the exception does not reach the top of the browser, you will only
 * get a stack trace from the point where TraceKit.report was called.
 *
 * Handlers receive a stackInfo object as described in the
 * TraceKit.computeStackTrace docs.
 */
TraceKit.report = (function reportModuleWrapper() {
  var handlers = [],
    lastArgs = null,
    lastException = null,
    lastExceptionStack = null;

  /**
   * Add a crash handler.
   * @param {Function} handler
   */
  function subscribe(handler) {
    installGlobalHandler();
    handlers.push(handler);
  }

  /**
   * Remove a crash handler.
   * @param {Function} handler
   */
  function unsubscribe(handler) {
    for (var i = handlers.length - 1; i >= 0; --i) {
      if (handlers[i] === handler) {
        handlers.splice(i, 1);
      }
    }
  }

  /**
   * Remove all crash handlers.
   */
  function unsubscribeAll() {
    uninstallGlobalHandler();
    handlers = [];
  }

  /**
   * Dispatch stack information to all handlers.
   * @param {Object.<string, *>} stack
   */
  function notifyHandlers(stack, isWindowError) {
    var exception = null;
    if (isWindowError && !TraceKit.collectWindowErrors) {
      return;
    }
    for (var i in handlers) {
      if (handlers.hasOwnProperty(i)) {
        try {
          handlers[i].apply(null, [stack].concat(_slice.call(arguments, 2)));
        } catch (inner) {
          exception = inner;
        }
      }
    }

    if (exception) {
      throw exception;
    }
  }

  var _oldOnerrorHandler, _onErrorHandlerInstalled;

  /**
   * Ensures all global unhandled exceptions are recorded.
   * Supported by Gecko and IE.
   * @param {string} msg Error message.
   * @param {string} url URL of script that generated the exception.
   * @param {(number|string)} lineNo The line number at which the error
   * occurred.
   * @param {?(number|string)} colNo The column number at which the error
   * occurred.
   * @param {?Error} ex The actual Error object.
   */
  function traceKitWindowOnError(msg, url, lineNo, colNo, ex) {
    var stack = null;
    // If 'ex' is ErrorEvent, get real Error from inside
    var exception = utils.isErrorEvent(ex) ? ex.error : ex;
    // If 'msg' is ErrorEvent, get real message from inside
    var message = utils.isErrorEvent(msg) ? msg.message : msg;

    if (lastExceptionStack) {
      TraceKit.computeStackTrace.augmentStackTraceWithInitialElement(
        lastExceptionStack,
        url,
        lineNo,
        message
      );
      processLastException();
    } else if (exception && utils.isError(exception)) {
      // non-string `exception` arg; attempt to extract stack trace

      // New chrome and blink send along a real error object
      // Let's just report that like a normal error.
      // See: https://mikewest.org/2013/08/debugging-runtime-errors-with-window-onerror
      stack = TraceKit.computeStackTrace(exception);
      notifyHandlers(stack, true);
    } else {
      var location = {
        url: url,
        line: lineNo,
        column: colNo
      };

      var name = undefined;
      var groups;

      if ({}.toString.call(message) === '[object String]') {
        var groups = message.match(ERROR_TYPES_RE);
        if (groups) {
          name = groups[1];
          message = groups[2];
        }
      }

      location.func = UNKNOWN_FUNCTION;

      stack = {
        name: name,
        message: message,
        url: getLocationHref(),
        stack: [location]
      };
      notifyHandlers(stack, true);
    }

    if (_oldOnerrorHandler) {
      return _oldOnerrorHandler.apply(this, arguments);
    }

    return false;
  }

  function installGlobalHandler() {
    if (_onErrorHandlerInstalled) {
      return;
    }
    _oldOnerrorHandler = _window.onerror;
    _window.onerror = traceKitWindowOnError;
    _onErrorHandlerInstalled = true;
  }

  function uninstallGlobalHandler() {
    if (!_onErrorHandlerInstalled) {
      return;
    }
    _window.onerror = _oldOnerrorHandler;
    _onErrorHandlerInstalled = false;
    _oldOnerrorHandler = undefined;
  }

  function processLastException() {
    var _lastExceptionStack = lastExceptionStack,
      _lastArgs = lastArgs;
    lastArgs = null;
    lastExceptionStack = null;
    lastException = null;
    notifyHandlers.apply(null, [_lastExceptionStack, false].concat(_lastArgs));
  }

  /**
   * Reports an unhandled Error to TraceKit.
   * @param {Error} ex
   * @param {?boolean} rethrow If false, do not re-throw the exception.
   * Only used for window.onerror to not cause an infinite loop of
   * rethrowing.
   */
  function report(ex, rethrow) {
    var args = _slice.call(arguments, 1);
    if (lastExceptionStack) {
      if (lastException === ex) {
        return; // already caught by an inner catch block, ignore
      } else {
        processLastException();
      }
    }

    var stack = TraceKit.computeStackTrace(ex);
    lastExceptionStack = stack;
    lastException = ex;
    lastArgs = args;

    // If the stack trace is incomplete, wait for 2 seconds for
    // slow slow IE to see if onerror occurs or not before reporting
    // this exception; otherwise, we will end up with an incomplete
    // stack trace
    setTimeout(
      function() {
        if (lastException === ex) {
          processLastException();
        }
      },
      stack.incomplete ? 2000 : 0
    );

    if (rethrow !== false) {
      throw ex; // re-throw to propagate to the top level (and cause window.onerror)
    }
  }

  report.subscribe = subscribe;
  report.unsubscribe = unsubscribe;
  report.uninstall = unsubscribeAll;
  return report;
})();

/**
 * TraceKit.computeStackTrace: cross-browser stack traces in JavaScript
 *
 * Syntax:
 *   s = TraceKit.computeStackTrace(exception) // consider using TraceKit.report instead (see below)
 * Returns:
 *   s.name              - exception name
 *   s.message           - exception message
 *   s.stack[i].url      - JavaScript or HTML file URL
 *   s.stack[i].func     - function name, or empty for anonymous functions (if guessing did not work)
 *   s.stack[i].args     - arguments passed to the function, if known
 *   s.stack[i].line     - line number, if known
 *   s.stack[i].column   - column number, if known
 *
 * Supports:
 *   - Firefox:  full stack trace with line numbers and unreliable column
 *               number on top frame
 *   - Opera 10: full stack trace with line and column numbers
 *   - Opera 9-: full stack trace with line numbers
 *   - Chrome:   full stack trace with line and column numbers
 *   - Safari:   line and column number for the topmost stacktrace element
 *               only
 *   - IE:       no line numbers whatsoever
 *
 * Tries to guess names of anonymous functions by looking for assignments
 * in the source code. In IE and Safari, we have to guess source file names
 * by searching for function bodies inside all page scripts. This will not
 * work for scripts that are loaded cross-domain.
 * Here be dragons: some function names may be guessed incorrectly, and
 * duplicate functions may be mismatched.
 *
 * TraceKit.computeStackTrace should only be used for tracing purposes.
 * Logging of unhandled exceptions should be done with TraceKit.report,
 * which builds on top of TraceKit.computeStackTrace and provides better
 * IE support by utilizing the window.onerror event to retrieve information
 * about the top of the stack.
 *
 * Note: In IE and Safari, no stack trace is recorded on the Error object,
 * so computeStackTrace instead walks its *own* chain of callers.
 * This means that:
 *  * in Safari, some methods may be missing from the stack trace;
 *  * in IE, the topmost function in the stack trace will always be the
 *    caller of computeStackTrace.
 *
 * This is okay for tracing (because you are likely to be calling
 * computeStackTrace from the function you want to be the topmost element
 * of the stack trace anyway), but not okay for logging unhandled
 * exceptions (because your catch block will likely be far away from the
 * inner function that actually caused the exception).
 *
 */
TraceKit.computeStackTrace = (function computeStackTraceWrapper() {
  // Contents of Exception in various browsers.
  //
  // SAFARI:
  // ex.message = Can't find variable: qq
  // ex.line = 59
  // ex.sourceId = 580238192
  // ex.sourceURL = http://...
  // ex.expressionBeginOffset = 96
  // ex.expressionCaretOffset = 98
  // ex.expressionEndOffset = 98
  // ex.name = ReferenceError
  //
  // FIREFOX:
  // ex.message = qq is not defined
  // ex.fileName = http://...
  // ex.lineNumber = 59
  // ex.columnNumber = 69
  // ex.stack = ...stack trace... (see the example below)
  // ex.name = ReferenceError
  //
  // CHROME:
  // ex.message = qq is not defined
  // ex.name = ReferenceError
  // ex.type = not_defined
  // ex.arguments = ['aa']
  // ex.stack = ...stack trace...
  //
  // INTERNET EXPLORER:
  // ex.message = ...
  // ex.name = ReferenceError
  //
  // OPERA:
  // ex.message = ...message... (see the example below)
  // ex.name = ReferenceError
  // ex.opera#sourceloc = 11  (pretty much useless, duplicates the info in ex.message)
  // ex.stacktrace = n/a; see 'opera:config#UserPrefs|Exceptions Have Stacktrace'

  /**
   * Computes stack trace information from the stack property.
   * Chrome and Gecko use this property.
   * @param {Error} ex
   * @return {?Object.<string, *>} Stack trace information.
   */
  function computeStackTraceFromStackProp(ex) {
    if (typeof ex.stack === 'undefined' || !ex.stack) return;

    var chrome = /^\s*at (?:(.*?) ?\()?((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|[a-z]:|\/).*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i;
    var winjs = /^\s*at (?:((?:\[object object\])?.+) )?\(?((?:file|ms-appx(?:-web)|https?|webpack|blob):.*?):(\d+)(?::(\d+))?\)?\s*$/i;
    // NOTE: blob urls are now supposed to always have an origin, therefore it's format
    // which is `blob:http://url/path/with-some-uuid`, is matched by `blob.*?:\/` as well
    var gecko = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|moz-extension).*?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js))(?::(\d+))?(?::(\d+))?\s*$/i;
    // Used to additionally parse URL/line/column from eval frames
    var geckoEval = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i;
    var chromeEval = /\((\S*)(?::(\d+))(?::(\d+))\)/;
    var lines = ex.stack.split('\n');
    var stack = [];
    var submatch;
    var parts;
    var element;
    var reference = /^(.*) is undefined$/.exec(ex.message);

    for (var i = 0, j = lines.length; i < j; ++i) {
      if ((parts = chrome.exec(lines[i]))) {
        var isNative = parts[2] && parts[2].indexOf('native') === 0; // start of line
        var isEval = parts[2] && parts[2].indexOf('eval') === 0; // start of line
        if (isEval && (submatch = chromeEval.exec(parts[2]))) {
          // throw out eval line/column and use top-most line/column number
          parts[2] = submatch[1]; // url
          parts[3] = submatch[2]; // line
          parts[4] = submatch[3]; // column
        }
        element = {
          url: !isNative ? parts[2] : null,
          func: parts[1] || UNKNOWN_FUNCTION,
          args: isNative ? [parts[2]] : [],
          line: parts[3] ? +parts[3] : null,
          column: parts[4] ? +parts[4] : null
        };
      } else if ((parts = winjs.exec(lines[i]))) {
        element = {
          url: parts[2],
          func: parts[1] || UNKNOWN_FUNCTION,
          args: [],
          line: +parts[3],
          column: parts[4] ? +parts[4] : null
        };
      } else if ((parts = gecko.exec(lines[i]))) {
        var isEval = parts[3] && parts[3].indexOf(' > eval') > -1;
        if (isEval && (submatch = geckoEval.exec(parts[3]))) {
          // throw out eval line/column and use top-most line number
          parts[3] = submatch[1];
          parts[4] = submatch[2];
          parts[5] = null; // no column when eval
        } else if (i === 0 && !parts[5] && typeof ex.columnNumber !== 'undefined') {
          // FireFox uses this awesome columnNumber property for its top frame
          // Also note, Firefox's column number is 0-based and everything else expects 1-based,
          // so adding 1
          // NOTE: this hack doesn't work if top-most frame is eval
          stack[0].column = ex.columnNumber + 1;
        }
        element = {
          url: parts[3],
          func: parts[1] || UNKNOWN_FUNCTION,
          args: parts[2] ? parts[2].split(',') : [],
          line: parts[4] ? +parts[4] : null,
          column: parts[5] ? +parts[5] : null
        };
      } else {
        continue;
      }

      if (!element.func && element.line) {
        element.func = UNKNOWN_FUNCTION;
      }

      if (element.url && element.url.substr(0, 5) === 'blob:') {
        // Special case for handling JavaScript loaded into a blob.
        // We use a synchronous AJAX request here as a blob is already in
        // memory - it's not making a network request.  This will generate a warning
        // in the browser console, but there has already been an error so that's not
        // that much of an issue.
        var xhr = new XMLHttpRequest();
        xhr.open('GET', element.url, false);
        xhr.send(null);

        // If we failed to download the source, skip this patch
        if (xhr.status === 200) {
          var source = xhr.responseText || '';

          // We trim the source down to the last 300 characters as sourceMappingURL is always at the end of the file.
          // Why 300? To be in line with: https://github.com/getsentry/sentry/blob/4af29e8f2350e20c28a6933354e4f42437b4ba42/src/sentry/lang/javascript/processor.py#L164-L175
          source = source.slice(-300);

          // Now we dig out the source map URL
          var sourceMaps = source.match(/\/\/# sourceMappingURL=(.*)$/);

          // If we don't find a source map comment or we find more than one, continue on to the next element.
          if (sourceMaps) {
            var sourceMapAddress = sourceMaps[1];

            // Now we check to see if it's a relative URL.
            // If it is, convert it to an absolute one.
            if (sourceMapAddress.charAt(0) === '~') {
              sourceMapAddress = getLocationOrigin() + sourceMapAddress.slice(1);
            }

            // Now we strip the '.map' off of the end of the URL and update the
            // element so that Sentry can match the map to the blob.
            element.url = sourceMapAddress.slice(0, -4);
          }
        }
      }

      stack.push(element);
    }

    if (!stack.length) {
      return null;
    }

    return {
      name: ex.name,
      message: ex.message,
      url: getLocationHref(),
      stack: stack
    };
  }

  /**
   * Adds information about the first frame to incomplete stack traces.
   * Safari and IE require this to get complete data on the first frame.
   * @param {Object.<string, *>} stackInfo Stack trace information from
   * one of the compute* methods.
   * @param {string} url The URL of the script that caused an error.
   * @param {(number|string)} lineNo The line number of the script that
   * caused an error.
   * @param {string=} message The error generated by the browser, which
   * hopefully contains the name of the object that caused the error.
   * @return {boolean} Whether or not the stack information was
   * augmented.
   */
  function augmentStackTraceWithInitialElement(stackInfo, url, lineNo, message) {
    var initial = {
      url: url,
      line: lineNo
    };

    if (initial.url && initial.line) {
      stackInfo.incomplete = false;

      if (!initial.func) {
        initial.func = UNKNOWN_FUNCTION;
      }

      if (stackInfo.stack.length > 0) {
        if (stackInfo.stack[0].url === initial.url) {
          if (stackInfo.stack[0].line === initial.line) {
            return false; // already in stack trace
          } else if (
            !stackInfo.stack[0].line &&
            stackInfo.stack[0].func === initial.func
          ) {
            stackInfo.stack[0].line = initial.line;
            return false;
          }
        }
      }

      stackInfo.stack.unshift(initial);
      stackInfo.partial = true;
      return true;
    } else {
      stackInfo.incomplete = true;
    }

    return false;
  }

  /**
   * Computes stack trace information by walking the arguments.caller
   * chain at the time the exception occurred. This will cause earlier
   * frames to be missed but is the only way to get any stack trace in
   * Safari and IE. The top frame is restored by
   * {@link augmentStackTraceWithInitialElement}.
   * @param {Error} ex
   * @return {?Object.<string, *>} Stack trace information.
   */
  function computeStackTraceByWalkingCallerChain(ex, depth) {
    var functionName = /function\s+([_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*)?\s*\(/i,
      stack = [],
      funcs = {},
      recursion = false,
      parts,
      item,
      source;

    for (
      var curr = computeStackTraceByWalkingCallerChain.caller;
      curr && !recursion;
      curr = curr.caller
    ) {
      if (curr === computeStackTrace || curr === TraceKit.report) {
        // console.log('skipping internal function');
        continue;
      }

      item = {
        url: null,
        func: UNKNOWN_FUNCTION,
        line: null,
        column: null
      };

      if (curr.name) {
        item.func = curr.name;
      } else if ((parts = functionName.exec(curr.toString()))) {
        item.func = parts[1];
      }

      if (typeof item.func === 'undefined') {
        try {
          item.func = parts.input.substring(0, parts.input.indexOf('{'));
        } catch (e) {}
      }

      if (funcs['' + curr]) {
        recursion = true;
      } else {
        funcs['' + curr] = true;
      }

      stack.push(item);
    }

    if (depth) {
      // console.log('depth is ' + depth);
      // console.log('stack is ' + stack.length);
      stack.splice(0, depth);
    }

    var result = {
      name: ex.name,
      message: ex.message,
      url: getLocationHref(),
      stack: stack
    };
    augmentStackTraceWithInitialElement(
      result,
      ex.sourceURL || ex.fileName,
      ex.line || ex.lineNumber,
      ex.message || ex.description
    );
    return result;
  }

  /**
   * Computes a stack trace for an exception.
   * @param {Error} ex
   * @param {(string|number)=} depth
   */
  function computeStackTrace(ex, depth) {
    var stack = null;
    depth = depth == null ? 0 : +depth;

    try {
      stack = computeStackTraceFromStackProp(ex);
      if (stack) {
        return stack;
      }
    } catch (e) {
      if (TraceKit.debug) {
        throw e;
      }
    }

    try {
      stack = computeStackTraceByWalkingCallerChain(ex, depth + 1);
      if (stack) {
        return stack;
      }
    } catch (e) {
      if (TraceKit.debug) {
        throw e;
      }
    }
    return {
      name: ex.name,
      message: ex.message,
      url: getLocationHref()
    };
  }

  computeStackTrace.augmentStackTraceWithInitialElement = augmentStackTraceWithInitialElement;
  computeStackTrace.computeStackTraceFromStackProp = computeStackTraceFromStackProp;

  return computeStackTrace;
})();

module.exports = TraceKit;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"../../src/utils":8}],10:[function(require,module,exports){
/*
 json-stringify-safe
 Like JSON.stringify, but doesn't throw on circular references.

 Originally forked from https://github.com/isaacs/json-stringify-safe
 version 5.0.1 on 3/8/2017 and modified to handle Errors serialization
 and IE8 compatibility. Tests for this are in test/vendor.

 ISC license: https://github.com/isaacs/json-stringify-safe/blob/master/LICENSE
*/

exports = module.exports = stringify;
exports.getSerialize = serializer;

function indexOf(haystack, needle) {
  for (var i = 0; i < haystack.length; ++i) {
    if (haystack[i] === needle) return i;
  }
  return -1;
}

function stringify(obj, replacer, spaces, cycleReplacer) {
  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces);
}

// https://github.com/ftlabs/js-abbreviate/blob/fa709e5f139e7770a71827b1893f22418097fbda/index.js#L95-L106
function stringifyError(value) {
  var err = {
    // These properties are implemented as magical getters and don't show up in for in
    stack: value.stack,
    message: value.message,
    name: value.name
  };

  for (var i in value) {
    if (Object.prototype.hasOwnProperty.call(value, i)) {
      err[i] = value[i];
    }
  }

  return err;
}

function serializer(replacer, cycleReplacer) {
  var stack = [];
  var keys = [];

  if (cycleReplacer == null) {
    cycleReplacer = function(key, value) {
      if (stack[0] === value) {
        return '[Circular ~]';
      }
      return '[Circular ~.' + keys.slice(0, indexOf(stack, value)).join('.') + ']';
    };
  }

  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = indexOf(stack, this);
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);

      if (~indexOf(stack, value)) {
        value = cycleReplacer.call(this, key, value);
      }
    } else {
      stack.push(value);
    }

    return replacer == null
      ? value instanceof Error ? stringifyError(value) : value
      : replacer.call(this, key, value);
  };
}

},{}],11:[function(require,module,exports){
/*
 * JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/*
* Add integers, wrapping at 2^32. This uses 16-bit operations internally
* to work around bugs in some JS interpreters.
*/
function safeAdd(x, y) {
  var lsw = (x & 0xffff) + (y & 0xffff);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return (msw << 16) | (lsw & 0xffff);
}

/*
* Bitwise rotate a 32-bit number to the left.
*/
function bitRotateLeft(num, cnt) {
  return (num << cnt) | (num >>> (32 - cnt));
}

/*
* These functions implement the four basic operations the algorithm uses.
*/
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn((b & c) | (~b & d), a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn((b & d) | (c & ~d), a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}

/*
* Calculate the MD5 of an array of little-endian words, and a bit length.
*/
function binlMD5(x, len) {
  /* append padding */
  x[len >> 5] |= 0x80 << (len % 32);
  x[(((len + 64) >>> 9) << 4) + 14] = len;

  var i;
  var olda;
  var oldb;
  var oldc;
  var oldd;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;

  for (i = 0; i < x.length; i += 16) {
    olda = a;
    oldb = b;
    oldc = c;
    oldd = d;

    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);

    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);

    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);

    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);

    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}

/*
* Convert an array of little-endian words to a string
*/
function binl2rstr(input) {
  var i;
  var output = '';
  var length32 = input.length * 32;
  for (i = 0; i < length32; i += 8) {
    output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xff);
  }
  return output;
}

/*
* Convert a raw string to an array of little-endian words
* Characters >255 have their high-byte silently ignored.
*/
function rstr2binl(input) {
  var i;
  var output = [];
  output[(input.length >> 2) - 1] = undefined;
  for (i = 0; i < output.length; i += 1) {
    output[i] = 0;
  }
  var length8 = input.length * 8;
  for (i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << (i % 32);
  }
  return output;
}

/*
* Calculate the MD5 of a raw string
*/
function rstrMD5(s) {
  return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
}

/*
* Calculate the HMAC-MD5, of a key and some data (raw strings)
*/
function rstrHMACMD5(key, data) {
  var i;
  var bkey = rstr2binl(key);
  var ipad = [];
  var opad = [];
  var hash;
  ipad[15] = opad[15] = undefined;
  if (bkey.length > 16) {
    bkey = binlMD5(bkey, key.length * 8);
  }
  for (i = 0; i < 16; i += 1) {
    ipad[i] = bkey[i] ^ 0x36363636;
    opad[i] = bkey[i] ^ 0x5c5c5c5c;
  }
  hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
  return binl2rstr(binlMD5(opad.concat(hash), 512 + 128));
}

/*
* Convert a raw string to a hex string
*/
function rstr2hex(input) {
  var hexTab = '0123456789abcdef';
  var output = '';
  var x;
  var i;
  for (i = 0; i < input.length; i += 1) {
    x = input.charCodeAt(i);
    output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f);
  }
  return output;
}

/*
* Encode a string as utf-8
*/
function str2rstrUTF8(input) {
  return unescape(encodeURIComponent(input));
}

/*
* Take string arguments and return either raw or hex encoded strings
*/
function rawMD5(s) {
  return rstrMD5(str2rstrUTF8(s));
}
function hexMD5(s) {
  return rstr2hex(rawMD5(s));
}
function rawHMACMD5(k, d) {
  return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
}
function hexHMACMD5(k, d) {
  return rstr2hex(rawHMACMD5(k, d));
}

function md5(string, key, raw) {
  if (!key) {
    if (!raw) {
      return hexMD5(string);
    }
    return rawMD5(string);
  }
  if (!raw) {
    return hexHMACMD5(key, string);
  }
  return rawHMACMD5(key, string);
}

module.exports = md5;

},{}],12:[function(require,module,exports){
'use strict';
module.exports = function (str) {
	return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
		return '%' + c.charCodeAt(0).toString(16).toUpperCase();
	});
};

},{}],13:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = BrowserAction;

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _tabState = require('./tab-state');

var _tabState2 = _interopRequireDefault(_tabState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Cache the tab state constants.
var states = _tabState2.default.states;

// Each button state has two icons one for normal resolution (19) and one
// for hi-res screens (38).
var icons = {};
icons[states.ACTIVE] = {
  19: 'images/browser-icon-active.png',
  38: 'images/browser-icon-active@2x.png'
};
icons[states.INACTIVE] = {
  19: 'images/browser-icon-inactive.png',
  38: 'images/browser-icon-inactive@2x.png'
};

// themes to apply to the toolbar icon badge depending on the type of
// build. Production builds use the default color and no text
var badgeThemes = {
  dev: {
    defaultText: 'DEV',
    color: '#5BCF59' // Emerald green
  },
  qa: {
    defaultText: 'QA',
    color: '#EDA061' // Porche orange-pink
  }
};

// Fake localization function.
function _(str) {
  return str;
}

/* Controls the display of the browser action button setting the icon, title
 * and badges depending on the current state of the tab.
 *
 * BrowserAction is responsible for mapping the logical H state of
 * a tab (whether the extension is active, annotation count) to
 * the badge state.
 */
function BrowserAction(chromeBrowserAction) {
  var buildType = _settings2.default.buildType;

  /**
   * Updates the state of the browser action to reflect the logical
   * H state of a tab.
   *
   * @param state - The H state of a tab. See the 'tab-state' module.
   */
  this.update = function (tabId, state) {
    var activeIcon = icons[states.INACTIVE];
    var title = '';
    var badgeText = '';

    if (state.state === states.ACTIVE) {
      activeIcon = icons[states.ACTIVE];
      title = 'Hypothesis is active';
    } else if (state.state === states.INACTIVE) {
      title = 'Hypothesis is inactive';
    } else if (state.state === states.ERRORED) {
      title = 'Hypothesis failed to load';
      badgeText = '!';
    } else {
      throw new Error('Unknown tab state');
    }

    // display the annotation count on the badge
    if (state.state !== states.ERRORED && state.annotationCount) {
      var countLabel;
      var totalString = state.annotationCount.toString();
      if (state.annotationCount > 999) {
        totalString = '999+';
      }
      if (state.annotationCount === 1) {
        countLabel = _("There's 1 annotation on this page");
      } else {
        countLabel = _('There are ' + totalString + ' annotations on this page');
      }
      title = countLabel;
      badgeText = totalString;
    }

    // update the badge style to reflect the build type
    var badgeTheme = badgeThemes[buildType];
    if (badgeTheme) {
      chromeBrowserAction.setBadgeBackgroundColor({
        tabId: tabId,
        color: badgeTheme.color
      });
      if (!badgeText) {
        badgeText = badgeTheme.defaultText;
      }
    }

    chromeBrowserAction.setBadgeText({ tabId: tabId, text: badgeText });
    chromeBrowserAction.setIcon({ tabId: tabId, path: activeIcon });
    chromeBrowserAction.setTitle({ tabId: tabId, title: title });
  };
}

BrowserAction.icons = icons;

},{"./settings":23,"./tab-state":25}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = browserName;
/**
 * Returns the name of the current browser.
 *
 * @return {'chrome'|'firefox'}
 */
function browserName() {
  if (window.browser) {
    return 'firefox';
  } else {
    return 'chrome';
  }
}

},{}],15:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = detectContentType;
/**
 * Returns the type of content in the current document,
 * currently either 'PDF' or 'HTML'.
 *
 * This function is injected as a content script into tabs in
 * order to detect the type of content on the page (PDF, HTML) etc.
 * by sniffing for viewer plugins.
 *
 * In future this could also be extended to support extraction of the URLs
 * of content in embedded viewers where that differs from the tab's
 * main URL.
 */
function detectContentType(document_) {
  document_ = document_ || document;

  function detectChromePDFViewer() {
    // When viewing a PDF in Chrome, the viewer consists of a top-level
    // document with an <embed> tag, which in turn instantiates an inner HTML
    // document providing the PDF viewer UI plus another <embed> tag which
    // instantiates the native PDF renderer.
    //
    // The selector below matches the <embed> tag in the top-level document. To
    // see this document, open the developer tools from Chrome's menu rather
    // than right-clicking on the viewport and selecting the 'Inspect' option
    // which will instead show the _inner_ document.
    if (document_.querySelector('embed[type="application/pdf"]')) {
      return { type: 'PDF' };
    }
    return null;
  }

  function detectFirefoxPDFViewer() {
    // The Firefox PDF viewer is an instance of PDF.js.
    //
    // The Firefox PDF plugin specifically can be detected via the <base>
    // tag it includes, which can be done from a content script (which runs
    // in an isolated JS world from the page's own scripts).
    //
    // Generic PDF.js detection can be done by looking for the
    // `window.PDFViewerApplication` object. This however requires running JS
    // code in the same JS context as the page's own code.
    if (document_.baseURI.indexOf('resource://pdf.js') === 0) {
      return { type: 'PDF' };
    }
    return null;
  }

  var detectFns = [detectChromePDFViewer, detectFirefoxPDFViewer];
  for (var i = 0; i < detectFns.length; i++) {
    var typeInfo = detectFns[i]();
    if (typeInfo) {
      return typeInfo;
    }
  }

  return { type: 'HTML' };
}

},{}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = directLinkQuery;
/**
 * Subset of the client configuration which causes the client to show a
 * particular set of annotations automatically after it loads.
 *
 * See https://h-client.readthedocs.io/en/latest/publishers/config/#config-settings
 *
 * @typedef {Object} Query
 * @property {string} [annotations] - ID of the direct-linked annotation
 * @property {string} [query] - Filter query from the sidebar
 * @property {string} [group] - ID of the direct-linked group
 */

/**
 * Extracts the direct-linking query from the URL if any.
 *
 * If present, the query causes the extension to activate automatically and
 * show the matching set of annotations.
 *
 * @param {string} url -
 *   The URL which may contain a '#annotations:' fragment specifying which
 *   annotations to show.
 * @return {Query|null}
 *   The direct link query translated into client configuration settings.
 */
function directLinkQuery(url) {
  // Annotation IDs are url-safe-base64 identifiers
  // See https://tools.ietf.org/html/rfc4648#page-7
  var idMatch = url.match(/#annotations:([A-Za-z0-9_-]+)$/);
  if (idMatch) {
    return { annotations: idMatch[1] };
  }

  var queryMatch = url.match(/#annotations:query:(.*)$/);
  if (queryMatch) {
    let query = decodeURIComponent(queryMatch[1]);
    return { query };
  }

  // Group IDs (and other "pubids" in h) are a subset of ASCII letters and
  // digits. As a special exception, the "Public" group has underscores in its
  // ID ("__world__").
  var groupMatch = url.match(/#annotations:group:([A-Za-z0-9_]+)$/);
  if (groupMatch) {
    return { group: groupMatch[1] };
  }

  return null;
}

},{}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ExtensionError = ExtensionError;
exports.LocalFileError = LocalFileError;
exports.NoFileAccessError = NoFileAccessError;
exports.RestrictedProtocolError = RestrictedProtocolError;
exports.BlockedSiteError = BlockedSiteError;
exports.AlreadyInjectedError = AlreadyInjectedError;
exports.shouldIgnoreInjectionError = shouldIgnoreInjectionError;
exports.report = report;

var _raven = require('./raven');

var raven = _interopRequireWildcard(_raven);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function ExtensionError(message) {
  Error.apply(this, arguments);
  this.message = message;
}

ExtensionError.prototype = Object.create(Error.prototype);

function LocalFileError(message) {
  Error.apply(this, arguments);
  this.message = message;
}

LocalFileError.prototype = Object.create(ExtensionError.prototype);

function NoFileAccessError(message) {
  Error.apply(this, arguments);
  this.message = message;
}

NoFileAccessError.prototype = Object.create(ExtensionError.prototype);

function RestrictedProtocolError(message) {
  Error.apply(this, arguments);
  this.message = message;
}

RestrictedProtocolError.prototype = Object.create(ExtensionError.prototype);

function BlockedSiteError(message) {
  Error.apply(this, arguments);
  this.message = message;
}

BlockedSiteError.prototype = Object.create(ExtensionError.prototype);

function AlreadyInjectedError(message) {
  Error.apply(this, arguments);
  this.message = message;
}

AlreadyInjectedError.prototype = Object.create(ExtensionError.prototype);

/**
 * Returns true if `err` is a recognized 'expected' error.
 */
function isKnownError(err) {
  return err instanceof ExtensionError;
}

var IGNORED_ERRORS = [
// Errors that can happen when the tab is closed during injection
/The tab was closed/, /No tab with id.*/,
// Attempts to access pages for which Chrome does not allow scripting
/Cannot access contents of.*/, /The extensions gallery cannot be scripted/];

/**
 * Returns true if a given `err` is anticipated during sidebar injection, such
 * as the tab being closed by the user, and should not be reported to Sentry.
 *
 * @param {{message: string}} err - The Error-like object
 */
function shouldIgnoreInjectionError(err) {
  if (IGNORED_ERRORS.some(function (pattern) {
    return err.message.match(pattern);
  })) {
    return true;
  }
  if (isKnownError(err)) {
    return true;
  }
  return false;
}

/**
 * Report an error.
 *
 * All errors are logged to the console. Additionally unexpected errors,
 * ie. those which are not instances of ExtensionError, are reported to
 * Sentry.
 *
 * @param {Error} error - The error which happened.
 * @param {string} when - Describes the context in which the error occurred.
 * @param {Object} context - Additional context for the error.
 */
function report(error, when, context) {
  console.error(when, error);
  if (!isKnownError(error)) {
    raven.report(error, when, context);
  }
}

},{"./raven":22}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = HelpPage;

var _browserName = require('./browser-name');

var _browserName2 = _interopRequireDefault(_browserName);

var _errors = require('./errors');

var errors = _interopRequireWildcard(_errors);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* A controller for displaying help pages. These are bound to extension
 * specific errors (found in errors.js) but can also be triggered manually.
 *
 * chromeTabs   - An instance of chrome.tabs.
 * extensionURL - A function that recieves a path and returns a full path
 *   to the file inside the chrome extension. See:
 *   https://developer.chrome.com/extensions/extension#method-getURL
 */
function HelpPage(chromeTabs, extensionURL, browserName_) {
  browserName_ = browserName_ || _browserName2.default;

  /* Accepts an instance of errors.ExtensionError and displays an appropriate
   * help page if one exists.
   *
   * @param {Tab} tab   - The tab to display the error message in.
   * @param {Error} error - The error to display, usually an instance of
   *                        errors.ExtensionError
   */
  this.showHelpForError = function (tab, error) {
    if (error instanceof errors.LocalFileError) {
      return this.showLocalFileHelpPage(tab);
    } else if (error instanceof errors.NoFileAccessError) {
      return this.showNoFileAccessHelpPage(tab);
    } else if (error instanceof errors.RestrictedProtocolError) {
      return this.showRestrictedProtocolPage(tab);
    } else if (error instanceof errors.BlockedSiteError) {
      return this.showBlockedSitePage(tab);
    } else {
      return this.showOtherErrorPage(tab, error);
    }
  };

  this.showLocalFileHelpPage = showHelpPage.bind(null, 'local-file');
  this.showNoFileAccessHelpPage = showHelpPage.bind(null, 'no-file-access');
  this.showRestrictedProtocolPage = showHelpPage.bind(null, 'restricted-protocol');
  this.showBlockedSitePage = showHelpPage.bind(null, 'blocked-site');
  this.showOtherErrorPage = showHelpPage.bind(null, 'other-error');

  /**
   * Open a tab displaying the help page.
   *
   * @param {string} helpSection - ID of a <section> within the help page.
   * @param {tabs.Tab} tab - The tab where the error occurred.
   * @param {Error} error - The error which prompted the help page.
   */
  function showHelpPage(helpSection, tab, error) {
    var params = '';
    if (error) {
      params = '?message=' + encodeURIComponent(error.message);
    }

    var tabOpts = {
      index: tab.index + 1,
      url: extensionURL('/help/index.html' + params + '#' + helpSection)
    };

    // Add `openerTabId` property to associate the help page tab with the
    // current tab. This property is not supported in Firefox.
    if (browserName_() !== 'firefox') {
      tabOpts.openerTabId = tab.id;
    }

    chromeTabs.create(tabOpts);
  }
}

},{"./browser-name":14,"./errors":17}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = HypothesisChromeExtension;

var _browserAction = require('./browser-action');

var _browserAction2 = _interopRequireDefault(_browserAction);

var _directLinkQuery = require('./direct-link-query');

var _directLinkQuery2 = _interopRequireDefault(_directLinkQuery);

var _errors = require('./errors');

var errors = _interopRequireWildcard(_errors);

var _helpPage = require('./help-page');

var _helpPage2 = _interopRequireDefault(_helpPage);

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

var _sidebarInjector = require('./sidebar-injector');

var _sidebarInjector2 = _interopRequireDefault(_sidebarInjector);

var _tabState = require('./tab-state');

var _tabState2 = _interopRequireDefault(_tabState);

var _tabStore = require('./tab-store');

var _tabStore2 = _interopRequireDefault(_tabStore);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TAB_STATUS_LOADING = 'loading';
var TAB_STATUS_COMPLETE = 'complete';

/* The main extension application. This wires together all the smaller
 * modules. The app listens to all new created/updated/removed tab events
 * and uses the TabState object to keep track of whether the sidebar is
 * active or inactive in the tab. The app also listens to click events on
 * the browser action and toggles the state and uses the BrowserAction module
 * to update the visual style of the button.
 *
 * The SidebarInjector handles the insertion of the Hypothesis code. If it
 * runs into errors the tab is put into an errored state and when the
 * browser action is clicked again the HelpPage module displays more
 * information to the user.
 *
 * Lastly the TabStore listens to changes to the TabState module and persists
 * the current settings to localStorage. This is then loaded into the
 * application on startup.
 *
 * Relevant Chrome Extension documentation:
 * - https://developer.chrome.com/extensions/browserAction
 * - https://developer.chrome.com/extensions/tabs
 * - https://developer.chrome.com/extensions/extension
 *
 * dependencies - An object to set up the application.
 *   chromeTabs: An instance of chrome.tabs.
 *   chromeBrowserAction: An instance of chrome.browserAction.
 *   extensionURL: chrome.extension.getURL.
 *   isAllowedFileSchemeAccess: chrome.extension.isAllowedFileSchemeAccess.
 */
function HypothesisChromeExtension(dependencies) {
  var chromeTabs = dependencies.chromeTabs;
  var chromeExtension = dependencies.chromeExtension;
  var chromeStorage = dependencies.chromeStorage;
  var chromeBrowserAction = dependencies.chromeBrowserAction;
  var help = new _helpPage2.default(chromeTabs, dependencies.extensionURL);
  var store = new _tabStore2.default(localStorage);
  var state = new _tabState2.default(store.all(), onTabStateChange);
  var browserAction = new _browserAction2.default(chromeBrowserAction);
  var sidebar = new _sidebarInjector2.default(chromeTabs, {
    extensionURL: dependencies.extensionURL,
    isAllowedFileSchemeAccess: dependencies.isAllowedFileSchemeAccess
  });

  restoreSavedTabState();

  /* Sets up the extension and binds event listeners. Requires a window
   * object to be passed so that it can listen for localStorage events.
   */
  this.listen = function () {
    chromeBrowserAction.onClicked.addListener(onBrowserActionClicked);
    chromeTabs.onCreated.addListener(onTabCreated);

    // when a user navigates within an existing tab,
    // onUpdated is fired in most cases
    chromeTabs.onUpdated.addListener(onTabUpdated);

    // ... but when a user navigates to a page that is loaded
    // via prerendering or instant results, onTabReplaced is
    // fired instead. See https://developer.chrome.com/extensions/tabs#event-onReplaced
    // and https://code.google.com/p/chromium/issues/detail?id=109557
    chromeTabs.onReplaced.addListener(onTabReplaced);

    chromeTabs.onRemoved.addListener(onTabRemoved);
  };

  /* A method that can be used to setup the extension on existing tabs
   * when the extension is re-installed.
   */
  this.install = function () {
    restoreSavedTabState();
  };

  /* Opens the onboarding page */
  this.firstRun = function (extensionInfo) {
    // If we've been installed because of an administrative policy, then don't
    // open the welcome page in a new tab.
    //
    // It's safe to assume that if an admin policy is responsible for installing
    // the extension, opening the welcome page is going to do more harm than
    // good, as it will appear that a tab opened without user action.
    //
    // See:
    //
    //   https://developer.chrome.com/extensions/management#type-ExtensionInstallType
    //
    if (extensionInfo.installType === 'admin') {
      return;
    }

    chromeTabs.create({ url: _settings2.default.serviceUrl + 'welcome' }, function (tab) {
      state.activateTab(tab.id);
    });
  };

  function restoreSavedTabState() {
    store.reload();
    state.load(store.all());
    chromeTabs.query({}, function (tabs) {
      tabs.forEach(function (tab) {
        onTabStateChange(tab.id, state.getState(tab.id));
      });
    });
  }

  function onTabStateChange(tabId, current) {
    if (current) {
      browserAction.update(tabId, current);
      chromeTabs.get(tabId, updateTabDocument);

      if (!state.isTabErrored(tabId)) {
        store.set(tabId, current);
      }
    } else {
      store.unset(tabId);
    }
  }

  // exposed for use by tests
  this._onTabStateChange = onTabStateChange;

  function onBrowserActionClicked(tab) {
    var tabError = state.getState(tab.id).error;
    if (tabError) {
      help.showHelpForError(tab, tabError);
    } else if (state.isTabActive(tab.id)) {
      state.deactivateTab(tab.id);
    } else {
      state.activateTab(tab.id);
    }
  }

  /**
   * Returns the active state for a tab
   * which has just been navigated to.
   */
  function activeStateForNavigatedTab(tabId) {
    var activeState = state.getState(tabId).state;
    if (activeState === _tabState2.default.states.ERRORED) {
      // user had tried to activate H on the previous page but it failed,
      // retry on the new page
      activeState = _tabState2.default.states.ACTIVE;
    }
    return activeState;
  }

  function resetTabState(tabId, url) {
    state.setState(tabId, {
      state: activeStateForNavigatedTab(tabId),
      ready: false,
      annotationCount: 0,
      extensionSidebarInstalled: false
    });
    updateAnnotationCountIfEnabled(tabId, url);
  }

  // This function will be called multiple times as the tab reloads.
  // https://developer.chrome.com/extensions/tabs#event-onUpdated
  //
  // 'changeInfo' contains details of what changed about the tab's status.
  // Two important events are when the tab's `status` changes to `loading`
  // when the user begins a new navigation and when the tab's status changes
  // to `complete` after the user completes a navigation
  function onTabUpdated(tabId, changeInfo, tab) {
    if (changeInfo.status === TAB_STATUS_LOADING) {
      resetTabState(tabId, tab.url);
      var query = (0, _directLinkQuery2.default)(tab.url);
      if (query) {
        state.setState(tab.id, { directLinkQuery: query });
      }
    } else if (changeInfo.status === TAB_STATUS_COMPLETE) {
      var tabState = state.getState(tabId);
      var newActiveState = tabState.state;
      if (tabState.directLinkQuery) {
        newActiveState = _tabState2.default.states.ACTIVE;
      }
      state.setState(tabId, {
        ready: true,
        state: newActiveState
      });
    }
  }

  function onTabReplaced(addedTabId, removedTabId) {
    state.setState(addedTabId, {
      state: activeStateForNavigatedTab(removedTabId),
      ready: true
    });
    state.clearTab(removedTabId);

    chromeTabs.get(addedTabId, function (tab) {
      updateAnnotationCountIfEnabled(addedTabId, tab.url);
    });
  }

  function onTabCreated(tab) {
    // Clear the state in case there is old, conflicting data in storage.
    state.clearTab(tab.id);
  }

  function onTabRemoved(tabId) {
    state.clearTab(tabId);
  }

  // installs or uninstalls the sidebar from a tab when the H
  // state for a tab changes
  function updateTabDocument(tab) {
    // If the tab has not yet finished loading then just quietly return.
    if (!state.getState(tab.id).ready) {
      return Promise.resolve();
    }

    var isInstalled = state.getState(tab.id).extensionSidebarInstalled;
    if (state.isTabActive(tab.id) && !isInstalled) {
      // optimistically set the state flag indicating that the sidebar
      // has been installed
      state.setState(tab.id, {
        extensionSidebarInstalled: true
      });

      var { directLinkQuery } = state.getState(tab.id);

      var config = {
        // Configure client to load assets and sidebar app from extension.
        // Note: Even though the sidebar app URL is correct here and the page
        // does load, Chrome devtools may incorrectly report that it failed to
        // load. See https://bugs.chromium.org/p/chromium/issues/detail?id=667533
        assetRoot: chromeExtension.getURL('/client/'),
        sidebarAppUrl: chromeExtension.getURL('/client/app.html')
      };

      // Pass the direct-link query as configuration into the client.
      //
      // The reason we don't rely on just putting this into the URL and letting
      // the client pick it up is to make direct-linking work in sites/apps
      // that modify the URL fragment as they load. See commit 3143ca27e05d.
      Object.assign(config, directLinkQuery);

      return sidebar.injectIntoTab(tab, config).then(function () {
        // Clear the direct link once H has been successfully injected
        state.setState(tab.id, { directLinkQuery: undefined });
      }).catch(function (err) {
        if (err instanceof errors.AlreadyInjectedError) {
          state.setState(tab.id, {
            state: _tabState2.default.states.INACTIVE,
            extensionSidebarInstalled: false
          });
          return;
        }
        if (!errors.shouldIgnoreInjectionError(err)) {
          errors.report(err, 'Injecting Hypothesis sidebar', {
            url: tab.url
          });
        }
        state.errorTab(tab.id, err);
      });
    } else if (state.isTabInactive(tab.id) && isInstalled) {
      return sidebar.removeFromTab(tab).then(function () {
        state.setState(tab.id, {
          extensionSidebarInstalled: false
        });
      });
    } else {
      return Promise.resolve();
    }
  }

  function updateAnnotationCountIfEnabled(tabId, url) {
    if (!chromeStorage.sync) {
      // Firefox < 53 does not support `chrome.storage.sync`.
      state.updateAnnotationCount(tabId, url);
      return;
    }

    chromeStorage.sync.get({
      badge: true
    }, function (items) {
      if (items.badge) {
        state.updateAnnotationCount(tabId, url);
      }
    });
  }
}

},{"./browser-action":13,"./direct-link-query":16,"./errors":17,"./help-page":18,"./settings":23,"./sidebar-injector":24,"./tab-state":25,"./tab-store":26}],20:[function(require,module,exports){
'use strict';

var _raven = require('./raven');

var raven = _interopRequireWildcard(_raven);

require('./hypothesis-chrome-extension');

require('./install');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

if (window.EXTENSION_CONFIG.raven) {
  raven.init(window.EXTENSION_CONFIG.raven);
}

},{"./hypothesis-chrome-extension":19,"./install":21,"./raven":22}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;

var _hypothesisChromeExtension = require('./hypothesis-chrome-extension');

var _hypothesisChromeExtension2 = _interopRequireDefault(_hypothesisChromeExtension);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var browserExtension;

function init() {
  browserExtension = new _hypothesisChromeExtension2.default({
    chromeExtension: chrome.extension,
    chromeTabs: chrome.tabs,
    chromeBrowserAction: chrome.browserAction,
    chromeStorage: chrome.storage,
    extensionURL: function (path) {
      return chrome.extension.getURL(path);
    },
    isAllowedFileSchemeAccess: function (fn) {
      return chrome.extension.isAllowedFileSchemeAccess(fn);
    }
  });

  browserExtension.listen(window);
}

if (!chrome.isFakeChrome) {
  init();
}

if (chrome.runtime.onInstalled) {
  chrome.runtime.onInstalled.addListener(onInstalled);
}

// Respond to messages sent by the JavaScript from https://hyp.is.
// This is how it knows whether the user has this Chrome extension installed.
if (chrome.runtime.onMessageExternal) {
  chrome.runtime.onMessageExternal.addListener(function (request, sender, sendResponse) {
    if (request.type === 'ping') {
      sendResponse({ type: 'pong' });
    }
  });
}

if (chrome.runtime.requestUpdateCheck) {
  chrome.runtime.requestUpdateCheck(function () {
    chrome.runtime.onUpdateAvailable.addListener(onUpdateAvailable);
  });
}

function onInstalled(installDetails) {
  // The install reason can be "install", "update", "chrome_update", or
  // "shared_module_update", see:
  //
  //   https://developer.chrome.com/extensions/runtime#type-OnInstalledReason
  //
  // If we were installed (rather than updated) then trigger a "firstRun" event,
  // passing in the details of the installed extension. See:
  //
  //   https://developer.chrome.com/extensions/management#method-getSelf
  //
  if (installDetails.reason === 'install') {
    chrome.management.getSelf(browserExtension.firstRun);
  }

  browserExtension.install();
}

function onUpdateAvailable() {
  chrome.runtime.reload();
}

},{"./hypothesis-chrome-extension":19}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.report = report;

var _ravenJs = require('raven-js');

var _ravenJs2 = _interopRequireDefault(_ravenJs);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Returns the input URL if it is an HTTP URL or the filename part of the URL
 * otherwise.
 *
 * @param {string} url - The script URL associated with an exception stack
 *                       frame.
 */
function convertLocalURLsToFilenames(url) {
  if (!url) {
    return url;
  }

  if (url.match(/https?:/)) {
    return url;
  }

  // Strip the query string (which is used as a cache buster)
  // and extract the filename from the URL
  return url.replace(/\?.*/, '').split('/').slice(-1)[0];
}

/**
 * Return a transformed version of `data` with local URLs replaced
 * with filenames.
 *
 * In environments where the client is served from a local URL,
 * eg. chrome-extension://<ID>/scripts/bundle.js, the script URL
 * and the sourcemap it references will not be accessible to Sentry.
 *
 * Therefore on the client we replace references to such URLs with just
 * the filename part and then as part of the release process, upload both
 * the source file and the source map to Sentry.
 *
 * Using just the filename allows us to upload a single set of source files
 * and sourcemaps for a release though a given release of H might be served
 * from multiple actual URLs (eg. different browser extensions).
 */
/**
 * This module configures Raven for reporting crashes
 * to Sentry.
 *
 * Logging requires the Sentry DSN and Hypothesis
 * version to be provided via the app's settings object.
 */

function translateSourceURLs(data) {
  try {
    var frames = data.exception.values[0].stacktrace.frames;
    frames.forEach(function (frame) {
      frame.filename = convertLocalURLsToFilenames(frame.filename);
    });
    data.culprit = frames[0].filename;
  } catch (err) {
    console.warn('Failed to normalize error stack trace', err, data);
  }
  return data;
}

function init(config) {
  _ravenJs2.default.config(config.dsn, {
    release: config.release,
    dataCallback: translateSourceURLs
  }).install();
  installUnhandledPromiseErrorHandler();
}

/**
 * Report an error to Sentry.
 *
 * @param {Error} error - An error object describing what went wrong
 * @param {string} when - A string describing the context in which
 *                        the error occurred.
 * @param {Object} [context] - A JSON-serializable object containing additional
 *                             information which may be useful when
 *                             investigating the error.
 */
function report(error, when, context) {
  if (!(error instanceof Error)) {
    // If the passed object is not an Error, raven-js
    // will serialize it using toString() which produces unhelpful results
    // for objects that do not provide their own toString() implementations.
    //
    // If the error is a plain object or non-Error subclass with a message
    // property, such as errors returned by chrome.extension.lastError,
    // use that instead.
    if (typeof error === 'object' && error.message) {
      error = error.message;
    }
  }

  var extra = Object.assign({ when: when }, context);
  _ravenJs2.default.captureException(error, { extra: extra });
}

/**
 * Installs a handler to catch unhandled rejected promises.
 *
 * For this to work, the browser or the Promise polyfill must support
 * the unhandled promise rejection event (Chrome >= 49). On other browsers,
 * the rejections will simply go unnoticed. Therefore, app code _should_
 * always provide a .catch() handler on the top-most promise chain.
 *
 * See https://github.com/getsentry/raven-js/issues/424
 * and https://www.chromestatus.com/feature/4805872211460096
 *
 * It is possible that future versions of Raven JS may handle these events
 * automatically, in which case this code can simply be removed.
 */
function installUnhandledPromiseErrorHandler() {
  window.addEventListener('unhandledrejection', function (event) {
    if (event.reason) {
      report(event.reason, 'Unhandled Promise rejection');
    }
  });
}

},{"raven-js":7}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Validate and normalize the given settings data.
 *
 * @param {Object} settings The settings from the settings.json file.
 */
function normalizeSettings(settings) {
  // Make sure that apiUrl does not end with a /.
  if (settings.apiUrl.charAt(settings.apiUrl.length - 1) === '/') {
    settings.apiUrl = settings.apiUrl.slice(0, -1);
  }
  return settings;
}

/**
 * Returns the configuration object for the Chrome extension
 */
exports.default = normalizeSettings(window.EXTENSION_CONFIG);

},{}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = SidebarInjector;

var _queryString = require('query-string');

var queryString = _interopRequireWildcard(_queryString);

var _detectContentType = require('./detect-content-type');

var _detectContentType2 = _interopRequireDefault(_detectContentType);

var _errors = require('./errors');

var errors = _interopRequireWildcard(_errors);

var _util = require('./util');

var util = _interopRequireWildcard(_util);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var CONTENT_TYPE_HTML = 'HTML';
var CONTENT_TYPE_PDF = 'PDF';

function toIIFEString(fn) {
  return '(' + fn.toString() + ')()';
}

/**
 * Adds a <script> tag containing JSON config data to the page.
 *
 * Note that this function is stringified and injected into the page via a
 * content script, so it cannot reference any external variables.
 */
function addJSONScriptTagFn(name, content) {
  var scriptTag = document.createElement('script');
  scriptTag.className = name;
  scriptTag.textContent = content;
  scriptTag.type = 'application/json';
  document.head.appendChild(scriptTag);
}

/**
 * Extract the value returned by a content script injected via
 * chrome.tabs.executeScript() into the main frame of a page.
 *
 * executeScript() returns an array of results, one per frame which the script
 * was injected into.
 *
 * See https://developer.chrome.com/extensions/tabs#method-executeScript
 *
 * @param {Array<any>?} result
 */
function extractContentScriptResult(result) {
  if (Array.isArray(result) && result.length > 0) {
    return result[0];
  } else if (typeof result === 'object') {
    // Firefox currently returns an object instead of
    // an array from executeScript()
    return result;
  } else {
    return null;
  }
}

/* The SidebarInjector is used to deploy and remove the Hypothesis sidebar
 * from tabs. It also deals with loading PDF documents into the PDF.js viewer
 * when applicable.
 *
 * chromeTabs - An instance of chrome.tabs.
 * dependencies - An object with additional helper methods.
 *   isAllowedFileSchemeAccess: A function that returns true if the user
 *   can access resources over the file:// protocol. See:
 *   https://developer.chrome.com/extensions/extension#method-isAllowedFileSchemeAccess
 *   extensionURL: A function that receives a path and returns an absolute
 *   url. See: https://developer.chrome.com/extensions/extension#method-getURL
 */
function SidebarInjector(chromeTabs, dependencies) {
  dependencies = dependencies || {};

  var isAllowedFileSchemeAccess = dependencies.isAllowedFileSchemeAccess;
  var extensionURL = dependencies.extensionURL;

  var executeScriptFn = util.promisify(chromeTabs.executeScript);

  var PDFViewerBaseURL = extensionURL('/pdfjs/web/viewer.html');

  if (typeof extensionURL !== 'function') {
    throw new TypeError('extensionURL must be a function');
  }

  if (typeof isAllowedFileSchemeAccess !== 'function') {
    throw new TypeError('isAllowedFileSchemeAccess must be a function');
  }

  /**
   * Injects the Hypothesis sidebar into the tab provided.
   *
   * @param {Tab} tab - A tab object representing the tab to insert the sidebar
   *        into.
   * @param {Object?} config - An object containing configuration info that
   *        is passed to the app when it loads.
   *
   * Returns a promise that will be resolved if the injection succeeded
   * otherwise it will be rejected with an error.
   */
  this.injectIntoTab = function (tab, config) {
    config = config || {};
    if (isFileURL(tab.url)) {
      return injectIntoLocalDocument(tab);
    } else {
      return injectIntoRemoteDocument(tab, config);
    }
  };

  /* Removes the Hypothesis sidebar from the tab provided.
   *
   * tab - A tab object representing the tab to remove the sidebar from.
   *
   * Returns a promise that will be resolved if the removal succeeded
   * otherwise it will be rejected with an error.
   */
  this.removeFromTab = function (tab) {
    if (isPDFViewerURL(tab.url)) {
      return removeFromPDF(tab);
    } else {
      return removeFromHTML(tab);
    }
  };

  function getPDFViewerURL(url) {
    // Encode the original URL but preserve the fragment, so that a
    // '#annotations' fragment in the original URL will persist and trigger the
    // sidebar to focus and scroll to that annotation when the PDF viewer loads.
    var parsedURL = new URL(url);
    var hash = parsedURL.hash;
    parsedURL.hash = '';
    var encodedURL = encodeURIComponent(parsedURL.href);
    return PDFViewerBaseURL + '?file=' + encodedURL + hash;
  }

  // returns true if the extension is permitted to inject
  // a content script into a tab with a given URL.
  function canInjectScript(url) {
    var canInject;
    if (isSupportedURL(url)) {
      canInject = Promise.resolve(true);
    } else if (isFileURL(url)) {
      canInject = util.promisify(isAllowedFileSchemeAccess)();
    } else {
      canInject = Promise.resolve(false);
    }
    return canInject;
  }

  /**
   * Guess the content type of a page from the URL alone.
   *
   * This is a fallback for when it is not possible to inject
   * a content script to determine the type of content in the page.
   */
  function guessContentTypeFromURL(url) {
    if (url.indexOf('.pdf') !== -1) {
      return CONTENT_TYPE_PDF;
    } else {
      return CONTENT_TYPE_HTML;
    }
  }

  function detectTabContentType(tab) {
    if (isPDFViewerURL(tab.url)) {
      return Promise.resolve(CONTENT_TYPE_PDF);
    }

    return canInjectScript(tab.url).then(function (canInject) {
      if (canInject) {
        return executeScriptFn(tab.id, {
          code: toIIFEString(_detectContentType2.default)
        }).then(function (frameResults) {
          var result = extractContentScriptResult(frameResults);
          if (result) {
            return result.type;
          } else {
            // If the content script threw an exception,
            // frameResults may be null or undefined.
            //
            // In that case, fall back to guessing based on the
            // tab URL
            return guessContentTypeFromURL(tab.url);
          }
        });
      } else {
        // We cannot inject a content script in order to determine the
        // file type, so fall back to a URL-based mechanism
        return Promise.resolve(guessContentTypeFromURL(tab.url));
      }
    });
  }

  /**
   * Returns true if a tab is displaying a PDF using the PDF.js-based
   * viewer bundled with the extension.
   */
  function isPDFViewerURL(url) {
    return url.indexOf(PDFViewerBaseURL) === 0;
  }

  function isFileURL(url) {
    return url.indexOf('file:') === 0;
  }

  function isSupportedURL(url) {
    // Injection of content scripts is limited to a small number of protocols,
    // see https://developer.chrome.com/extensions/match_patterns
    var parsedURL = new URL(url);
    var SUPPORTED_PROTOCOLS = ['http:', 'https:', 'ftp:'];
    return SUPPORTED_PROTOCOLS.some(function (protocol) {
      return parsedURL.protocol === protocol;
    });
  }

  function injectIntoLocalDocument(tab) {
    return detectTabContentType(tab).then(function (type) {
      if (type === CONTENT_TYPE_PDF) {
        return injectIntoLocalPDF(tab);
      } else {
        return Promise.reject(new errors.LocalFileError('Local non-PDF files are not supported'));
      }
    });
  }

  function injectIntoRemoteDocument(tab, config) {
    if (isPDFViewerURL(tab.url)) {
      return Promise.resolve();
    }

    if (!isSupportedURL(tab.url)) {
      // Chrome does not permit extensions to inject content scripts
      // into (chrome*):// URLs and other custom schemes.
      //
      // A common case where this happens is when the user has an
      // extension installed that provides a custom viewer for PDFs
      // (or some other format). In some cases we could extract the original
      // URL and open that in the Hypothesis viewer instead.
      var protocol = tab.url.split(':')[0];
      return Promise.reject(new errors.RestrictedProtocolError('Cannot load Hypothesis into ' + protocol + ' pages'));
    }

    return detectTabContentType(tab).then(function (type) {
      if (type === CONTENT_TYPE_PDF) {
        return injectIntoPDF(tab);
      } else {
        return injectConfig(tab.id, config).then(function () {
          return injectIntoHTML(tab);
        }).then(function (results) {
          var result = extractContentScriptResult(results);
          if (result && typeof result.installedURL === 'string' && result.installedURL.indexOf(extensionURL('/')) === -1) {
            throw new errors.AlreadyInjectedError('Hypothesis is already injected into this page');
          }
        });
      }
    });
  }

  function injectIntoPDF(tab) {
    if (isPDFViewerURL(tab.url)) {
      return Promise.resolve();
    }
    var updateFn = util.promisify(chromeTabs.update);
    return updateFn(tab.id, { url: getPDFViewerURL(tab.url) });
  }

  function injectIntoLocalPDF(tab) {
    return new Promise(function (resolve, reject) {
      isAllowedFileSchemeAccess(function (isAllowed) {
        if (isAllowed) {
          resolve(injectIntoPDF(tab));
        } else {
          reject(new errors.NoFileAccessError('Local file scheme access denied'));
        }
      });
    });
  }

  function injectIntoHTML(tab) {
    return injectScript(tab.id, '/client/build/boot.js');
  }

  function removeFromPDF(tab) {
    return new Promise(function (resolve) {
      var parsedURL = new URL(tab.url);
      var originalURL = queryString.parse(parsedURL.search).file;
      if (!originalURL) {
        throw new Error('Failed to extract original URL from ' + tab.url);
      }
      var hash = parsedURL.hash;

      // If the original URL was a direct link, drop the #annotations fragment
      // as otherwise the Chrome extension will re-activate itself on this tab
      // when the original URL loads.
      if (hash.indexOf('#annotations:') === 0) {
        hash = '';
      }

      chromeTabs.update(tab.id, {
        url: decodeURIComponent(originalURL) + hash
      }, resolve);
    });
  }

  function removeFromHTML(tab) {
    if (!isSupportedURL(tab.url)) {
      return Promise.resolve();
    }
    return injectScript(tab.id, '/unload-client.js');
  }

  /**
   * Inject the script from the source file at `path` into the
   * page currently loaded in the tab at the given ID.
   */
  function injectScript(tabId, path) {
    return executeScriptFn(tabId, { file: path });
  }

  /**
   * Inject configuration information for the Hypothesis application
   * into the page as JSON data via a <meta> tag.
   *
   * A <meta> tag is used because that makes it available to JS content
   * running in isolated worlds.
   */
  function injectConfig(tabId, config) {
    var configStr = JSON.stringify(config).replace(/"/g, '\\"');
    var configCode = 'var hypothesisConfig = "' + configStr + '";\n' + '(' + addJSONScriptTagFn.toString() + ')' + '("js-hypothesis-config", hypothesisConfig);\n';
    return executeScriptFn(tabId, { code: configCode });
  }
}

},{"./detect-content-type":15,"./errors":17,"./util":28,"query-string":3}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TabState;

var _isEqualShallow = require('is-equal-shallow');

var _isEqualShallow2 = _interopRequireDefault(_isEqualShallow);

var _uriInfo = require('./uri-info');

var uriInfo = _interopRequireWildcard(_uriInfo);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var states = {
  ACTIVE: 'active',
  INACTIVE: 'inactive',
  ERRORED: 'errored'
};

/** The default H state for a new browser tab */
var DEFAULT_STATE = {
  /** Whether or not H is active on the page */
  state: states.INACTIVE,
  /** The count of annotations on the page visible to the user,
   * as returned by the badge API
   */
  annotationCount: 0,
  /** Whether or not the H sidebar has been installed onto the page by
   * the extension
   */
  extensionSidebarInstalled: false,
  /** Whether the tab is loaded and ready for the sidebar to be installed. */
  ready: false,
  /** The error for the current tab. */
  error: undefined
};

/** TabState stores the H state for a tab. This state includes:
 *
 * - Whether the extension has been activated on a tab
 * - Whether the sidebar is currently installed on a tab
 * - The count of annotations visible to the user on the URL currently
 *   displayed in the tab.
 *
 * The H state for a tab is updated via the setState() method and
 * retrieved via getState().
 *
 * When the H state for a tab changes, the `onchange()` callback will
 * be triggered with the tab ID and current and previous states.
 *
 * initialState - An Object of tabId/state keys. Used when loading state
 *   from a persisted store such as localStorage. This will be merged with
 *   the default state for a tab.
 * onchange     - A function that recieves onchange(tabId, current).
 */
function TabState(initialState, onchange) {
  var self = this;
  var currentState;

  this.onchange = onchange || null;

  /** Replaces the H state for all tabs with the state data
   * from `newState`.
   *
   * @param newState - A dictionary mapping tab ID to tab state objects.
   *                   The provided state will be merged with the default
   *                   state for a tab.
   */
  this.load = function (newState) {
    var newCurrentState = {};
    Object.keys(newState).forEach(function (tabId) {
      newCurrentState[tabId] = Object.assign({}, DEFAULT_STATE, newState[tabId]);
    });
    currentState = newCurrentState;
  };

  this.activateTab = function (tabId) {
    this.setState(tabId, { state: states.ACTIVE });
  };

  this.deactivateTab = function (tabId) {
    this.setState(tabId, { state: states.INACTIVE });
  };

  this.errorTab = function (tabId, error) {
    this.setState(tabId, {
      state: states.ERRORED,
      error: error
    });
  };

  this.clearTab = function (tabId) {
    this.setState(tabId, null);
  };

  this.getState = function (tabId) {
    if (!currentState[tabId]) {
      return DEFAULT_STATE;
    }
    return currentState[tabId];
  };

  this.annotationCount = function (tabId) {
    return this.getState(tabId).annotationCount;
  };

  this.isTabActive = function (tabId) {
    return this.getState(tabId).state === states.ACTIVE;
  };

  this.isTabInactive = function (tabId) {
    return this.getState(tabId).state === states.INACTIVE;
  };

  this.isTabErrored = function (tabId) {
    return this.getState(tabId).state === states.ERRORED;
  };

  /**
   * Updates the H state for a tab.
   *
   * @param tabId - The ID of the tab being updated
   * @param stateUpdate - A dictionary of {key:value} properties for
   *                      state properties to update or null if the
   *                      state should be removed.
   */
  this.setState = function (tabId, stateUpdate) {
    var newState;
    if (stateUpdate) {
      newState = Object.assign({}, this.getState(tabId), stateUpdate);
      if (newState.state !== states.ERRORED) {
        newState.error = undefined;
      }
    }

    if ((0, _isEqualShallow2.default)(newState, currentState[tabId])) {
      return;
    }

    currentState[tabId] = newState;

    if (self.onchange) {
      self.onchange(tabId, newState);
    }
  };

  /**
   * Query the server for the annotation count for a URL
   * and update the annotation count for the tab accordingly.
   *
   * @method
   * @param {integer} tabId The id of the tab.
   * @param {string} tabUrl The URL of the tab.
   */
  this.updateAnnotationCount = function (tabId, tabUrl) {
    var self = this;
    return uriInfo.query(tabUrl).then(function (result) {
      self.setState(tabId, { annotationCount: result.total });
    }).catch(function (err) {
      self.setState(tabId, { annotationCount: 0 });
      console.error('Failed to fetch annotation count for %s: %s', tabUrl, err);
    });
  };

  this.load(initialState || {});
}

TabState.states = states;

},{"./uri-info":27,"is-equal-shallow":1}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = TabStore;
/** TabStore is used to persist the state of H browser tabs when
 * the extension is re-installed or updated.
 *
 * Note: This could also be used to persist the state across browser sessions,
 * for that to work however the storage key would need to be changed.
 * The tab ID is currently used but this is valid only for a browser session.
 */
function TabStore(storage) {
  var key = 'state';
  var local;

  this.get = function (tabId) {
    var value = local[tabId];
    if (!value) {
      throw new Error('TabStateStore could not find entry for tab: ' + tabId);
    }
    return value;
  };

  this.set = function (tabId, value) {
    // copy across only the parts of the tab state that should
    // be preserved
    local[tabId] = {
      state: value.state,
      annotationCount: value.annotationCount
    };
    storage.setItem(key, JSON.stringify(local));
  };

  this.unset = function (tabId) {
    delete local[tabId];
    storage.setItem(key, JSON.stringify(local));
  };

  this.all = function () {
    return local;
  };

  this.reload = function () {
    try {
      local = {};
      var loaded = JSON.parse(storage.getItem(key));
      Object.keys(loaded).forEach(function (key) {
        // ignore tab state saved by earlier versions of
        // the extension which saved the state as a {key: <state string>}
        // dict rather than {key: <state object>}
        if (typeof loaded[key] === 'string') {
          local[key] = { state: loaded[key] };
        } else {
          local[key] = loaded[key];
        }
      });
    } catch (e) {
      local = null;
    }
    local = local || {};
  };

  this.reload();
}

},{}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.query = query;

var _settings = require('./settings');

var _settings2 = _interopRequireDefault(_settings);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/** encodeUriQuery encodes a string for use in a query parameter */
function encodeUriQuery(val) {
  return encodeURIComponent(val).replace(/%20/g, '+');
}

/**
 * Queries the Hypothesis service that provides
 * statistics about the annotations for a given URL.
 */
function query(uri) {
  return fetch(_settings2.default.apiUrl + '/badge?uri=' + encodeUriQuery(uri), {
    credentials: 'include'
  }).then(function (res) {
    return res.json();
  }).then(function (data) {
    if (typeof data.total !== 'number') {
      throw new Error('Annotation count is not a number');
    }
    return data;
  });
}

},{"./settings":23}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.promisify = promisify;
function getLastError() {
  if (typeof chrome !== 'undefined' && chrome.extension) {
    return chrome.extension.lastError;
  } else {
    return undefined;
  }
}

/**
 * Converts an async Chrome API into a function
 * which returns a promise.
 *
 * Usage:
 *   var apiFn = promisify(chrome.someModule.aFunction);
 *   apiFn(arg1, arg2)
 *     .then(function (result) { ...handle success  })
 *     .catch(function (err) { ...handle error })
 *
 *
 * @param fn A Chrome API function whose last argument is a callback
 *           which is invoked with the result of the query. When this callback
 *           is invoked, the promise is rejected if chrome.extension.lastError
 *           is set or resolved with the first argument to the callback otherwise.
 */
function promisify(fn) {
  return function () {
    var args = [].slice.call(arguments);
    var result = new Promise(function (resolve, reject) {
      fn.apply(this, args.concat(function (result) {
        var lastError = getLastError();
        if (lastError) {
          reject(lastError);
        } else {
          resolve(result);
        }
      }));
    });
    return result;
  };
}

},{}]},{},[20])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvaXMtZXF1YWwtc2hhbGxvdy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pcy1wcmltaXRpdmUvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcXVlcnktc3RyaW5nL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3JhdmVuLWpzL3NyYy9jb25maWdFcnJvci5qcyIsIm5vZGVfbW9kdWxlcy9yYXZlbi1qcy9zcmMvY29uc29sZS5qcyIsIm5vZGVfbW9kdWxlcy9yYXZlbi1qcy9zcmMvcmF2ZW4uanMiLCJub2RlX21vZHVsZXMvcmF2ZW4tanMvc3JjL3NpbmdsZXRvbi5qcyIsIm5vZGVfbW9kdWxlcy9yYXZlbi1qcy9zcmMvdXRpbHMuanMiLCJub2RlX21vZHVsZXMvcmF2ZW4tanMvdmVuZG9yL1RyYWNlS2l0L3RyYWNla2l0LmpzIiwibm9kZV9tb2R1bGVzL3JhdmVuLWpzL3ZlbmRvci9qc29uLXN0cmluZ2lmeS1zYWZlL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9yYXZlbi1qcy92ZW5kb3IvbWQ1L21kNS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpY3QtdXJpLWVuY29kZS9pbmRleC5qcyIsInNyYy9iYWNrZ3JvdW5kL2Jyb3dzZXItYWN0aW9uLmpzIiwic3JjL2JhY2tncm91bmQvYnJvd3Nlci1uYW1lLmpzIiwic3JjL2JhY2tncm91bmQvZGV0ZWN0LWNvbnRlbnQtdHlwZS5qcyIsInNyYy9iYWNrZ3JvdW5kL2RpcmVjdC1saW5rLXF1ZXJ5LmpzIiwic3JjL2JhY2tncm91bmQvZXJyb3JzLmpzIiwic3JjL2JhY2tncm91bmQvaGVscC1wYWdlLmpzIiwic3JjL2JhY2tncm91bmQvaHlwb3RoZXNpcy1jaHJvbWUtZXh0ZW5zaW9uLmpzIiwic3JjL2JhY2tncm91bmQvaW5kZXguanMiLCJzcmMvYmFja2dyb3VuZC9pbnN0YWxsLmpzIiwic3JjL2JhY2tncm91bmQvcmF2ZW4uanMiLCJzcmMvYmFja2dyb3VuZC9zZXR0aW5ncy5qcyIsInNyYy9iYWNrZ3JvdW5kL3NpZGViYXItaW5qZWN0b3IuanMiLCJzcmMvYmFja2dyb3VuZC90YWItc3RhdGUuanMiLCJzcmMvYmFja2dyb3VuZC90YWItc3RvcmUuanMiLCJzcmMvYmFja2dyb3VuZC91cmktaW5mby5qcyIsInNyYy9iYWNrZ3JvdW5kL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMxQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDanZFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzVvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDanJCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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LCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbigpe2Z1bmN0aW9uIHIoZSxuLHQpe2Z1bmN0aW9uIG8oaSxmKXtpZighbltpXSl7aWYoIWVbaV0pe3ZhciBjPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmU7aWYoIWYmJmMpcmV0dXJuIGMoaSwhMCk7aWYodSlyZXR1cm4gdShpLCEwKTt2YXIgYT1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK2krXCInXCIpO3Rocm93IGEuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixhfXZhciBwPW5baV09e2V4cG9ydHM6e319O2VbaV1bMF0uY2FsbChwLmV4cG9ydHMsZnVuY3Rpb24ocil7dmFyIG49ZVtpXVsxXVtyXTtyZXR1cm4gbyhufHxyKX0scCxwLmV4cG9ydHMscixlLG4sdCl9cmV0dXJuIG5baV0uZXhwb3J0c31mb3IodmFyIHU9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZSxpPTA7aTx0Lmxlbmd0aDtpKyspbyh0W2ldKTtyZXR1cm4gb31yZXR1cm4gcn0pKCkiLCIvKiFcbiAqIGlzLWVxdWFsLXNoYWxsb3cgPGh0dHBzOi8vZ2l0aHViLmNvbS9qb25zY2hsaW5rZXJ0L2lzLWVxdWFsLXNoYWxsb3c+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1LCBKb24gU2NobGlua2VydC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpc1ByaW1pdGl2ZSA9IHJlcXVpcmUoJ2lzLXByaW1pdGl2ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzRXF1YWwoYSwgYikge1xuICBpZiAoIWEgJiYgIWIpIHsgcmV0dXJuIHRydWU7IH1cbiAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikgeyByZXR1cm4gZmFsc2U7IH1cblxuICB2YXIgbnVtS2V5c0EgPSAwLCBudW1LZXlzQiA9IDAsIGtleTtcbiAgZm9yIChrZXkgaW4gYikge1xuICAgIG51bUtleXNCKys7XG4gICAgaWYgKCFpc1ByaW1pdGl2ZShiW2tleV0pIHx8ICFhLmhhc093blByb3BlcnR5KGtleSkgfHwgKGFba2V5XSAhPT0gYltrZXldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGtleSBpbiBhKSB7XG4gICAgbnVtS2V5c0ErKztcbiAgfVxuICByZXR1cm4gbnVtS2V5c0EgPT09IG51bUtleXNCO1xufTtcbiIsIi8qIVxuICogaXMtcHJpbWl0aXZlIDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wcmltaXRpdmU+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTUsIEpvbiBTY2hsaW5rZXJ0LlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gc2VlIGh0dHA6Ly9qc3BlcmYuY29tL3Rlc3RpbmctdmFsdWUtaXMtcHJpbWl0aXZlLzdcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNQcmltaXRpdmUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgKHR5cGVvZiB2YWx1ZSAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgc3RyaWN0VXJpRW5jb2RlID0gcmVxdWlyZSgnc3RyaWN0LXVyaS1lbmNvZGUnKTtcblxuZXhwb3J0cy5leHRyYWN0ID0gZnVuY3Rpb24gKHN0cikge1xuXHRyZXR1cm4gc3RyLnNwbGl0KCc/JylbMV0gfHwgJyc7XG59O1xuXG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHN0cikge1xuXHRpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcblx0XHRyZXR1cm4ge307XG5cdH1cblxuXHRzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoL14oXFw/fCN8JikvLCAnJyk7XG5cblx0aWYgKCFzdHIpIHtcblx0XHRyZXR1cm4ge307XG5cdH1cblxuXHRyZXR1cm4gc3RyLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIHBhcmFtKSB7XG5cdFx0dmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFwrL2csICcgJykuc3BsaXQoJz0nKTtcblx0XHQvLyBGaXJlZm94IChwcmUgNDApIGRlY29kZXMgYCUzRGAgdG8gYD1gXG5cdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL3NpbmRyZXNvcmh1cy9xdWVyeS1zdHJpbmcvcHVsbC8zN1xuXHRcdHZhciBrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuXHRcdHZhciB2YWwgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHMuam9pbignPScpIDogdW5kZWZpbmVkO1xuXG5cdFx0a2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSk7XG5cblx0XHQvLyBtaXNzaW5nIGA9YCBzaG91bGQgYmUgYG51bGxgOlxuXHRcdC8vIGh0dHA6Ly93My5vcmcvVFIvMjAxMi9XRC11cmwtMjAxMjA1MjQvI2NvbGxlY3QtdXJsLXBhcmFtZXRlcnNcblx0XHR2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQodmFsKTtcblxuXHRcdGlmICghcmV0Lmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdHJldFtrZXldID0gdmFsO1xuXHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShyZXRba2V5XSkpIHtcblx0XHRcdHJldFtrZXldLnB1c2godmFsKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0W2tleV0gPSBbcmV0W2tleV0sIHZhbF07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJldDtcblx0fSwge30pO1xufTtcblxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAob2JqKSB7XG5cdHJldHVybiBvYmogPyBPYmplY3Qua2V5cyhvYmopLnNvcnQoKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuXHRcdHZhciB2YWwgPSBvYmpba2V5XTtcblxuXHRcdGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuICcnO1xuXHRcdH1cblxuXHRcdGlmICh2YWwgPT09IG51bGwpIHtcblx0XHRcdHJldHVybiBrZXk7XG5cdFx0fVxuXG5cdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuXHRcdFx0cmV0dXJuIHZhbC5zbGljZSgpLnNvcnQoKS5tYXAoZnVuY3Rpb24gKHZhbDIpIHtcblx0XHRcdFx0cmV0dXJuIHN0cmljdFVyaUVuY29kZShrZXkpICsgJz0nICsgc3RyaWN0VXJpRW5jb2RlKHZhbDIpO1xuXHRcdFx0fSkuam9pbignJicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzdHJpY3RVcmlFbmNvZGUoa2V5KSArICc9JyArIHN0cmljdFVyaUVuY29kZSh2YWwpO1xuXHR9KS5maWx0ZXIoZnVuY3Rpb24gKHgpIHtcblx0XHRyZXR1cm4geC5sZW5ndGggPiAwO1xuXHR9KS5qb2luKCcmJykgOiAnJztcbn07XG4iLCJmdW5jdGlvbiBSYXZlbkNvbmZpZ0Vycm9yKG1lc3NhZ2UpIHtcbiAgdGhpcy5uYW1lID0gJ1JhdmVuQ29uZmlnRXJyb3InO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuUmF2ZW5Db25maWdFcnJvci5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcblJhdmVuQ29uZmlnRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUmF2ZW5Db25maWdFcnJvcjtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXZlbkNvbmZpZ0Vycm9yO1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG52YXIgd3JhcE1ldGhvZCA9IGZ1bmN0aW9uKGNvbnNvbGUsIGxldmVsLCBjYWxsYmFjaykge1xuICB2YXIgb3JpZ2luYWxDb25zb2xlTGV2ZWwgPSBjb25zb2xlW2xldmVsXTtcbiAgdmFyIG9yaWdpbmFsQ29uc29sZSA9IGNvbnNvbGU7XG5cbiAgaWYgKCEobGV2ZWwgaW4gY29uc29sZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VudHJ5TGV2ZWwgPSBsZXZlbCA9PT0gJ3dhcm4nID8gJ3dhcm5pbmcnIDogbGV2ZWw7XG5cbiAgY29uc29sZVtsZXZlbF0gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblxuICAgIHZhciBtc2cgPSB1dGlscy5zYWZlSm9pbihhcmdzLCAnICcpO1xuICAgIHZhciBkYXRhID0ge2xldmVsOiBzZW50cnlMZXZlbCwgbG9nZ2VyOiAnY29uc29sZScsIGV4dHJhOiB7YXJndW1lbnRzOiBhcmdzfX07XG5cbiAgICBpZiAobGV2ZWwgPT09ICdhc3NlcnQnKSB7XG4gICAgICBpZiAoYXJnc1swXSA9PT0gZmFsc2UpIHtcbiAgICAgICAgLy8gRGVmYXVsdCBicm93c2VycyBtZXNzYWdlXG4gICAgICAgIG1zZyA9XG4gICAgICAgICAgJ0Fzc2VydGlvbiBmYWlsZWQ6ICcgKyAodXRpbHMuc2FmZUpvaW4oYXJncy5zbGljZSgxKSwgJyAnKSB8fCAnY29uc29sZS5hc3NlcnQnKTtcbiAgICAgICAgZGF0YS5leHRyYS5hcmd1bWVudHMgPSBhcmdzLnNsaWNlKDEpO1xuICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhtc2csIGRhdGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhtc2csIGRhdGEpO1xuICAgIH1cblxuICAgIC8vIHRoaXMgZmFpbHMgZm9yIHNvbWUgYnJvd3NlcnMuIDooXG4gICAgaWYgKG9yaWdpbmFsQ29uc29sZUxldmVsKSB7XG4gICAgICAvLyBJRTkgZG9lc24ndCBhbGxvdyBjYWxsaW5nIGFwcGx5IG9uIGNvbnNvbGUgZnVuY3Rpb25zIGRpcmVjdGx5XG4gICAgICAvLyBTZWU6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU0NzI5MzgvZG9lcy1pZTktc3VwcG9ydC1jb25zb2xlLWxvZy1hbmQtaXMtaXQtYS1yZWFsLWZ1bmN0aW9uI2Fuc3dlci01NDczMTkzXG4gICAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChvcmlnaW5hbENvbnNvbGVMZXZlbCwgb3JpZ2luYWxDb25zb2xlLCBhcmdzKTtcbiAgICB9XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd3JhcE1ldGhvZDogd3JhcE1ldGhvZFxufTtcbiIsIi8qZ2xvYmFsIFhEb21haW5SZXF1ZXN0OmZhbHNlICovXG5cbnZhciBUcmFjZUtpdCA9IHJlcXVpcmUoJy4uL3ZlbmRvci9UcmFjZUtpdC90cmFjZWtpdCcpO1xudmFyIHN0cmluZ2lmeSA9IHJlcXVpcmUoJy4uL3ZlbmRvci9qc29uLXN0cmluZ2lmeS1zYWZlL3N0cmluZ2lmeScpO1xudmFyIG1kNSA9IHJlcXVpcmUoJy4uL3ZlbmRvci9tZDUvbWQ1Jyk7XG52YXIgUmF2ZW5Db25maWdFcnJvciA9IHJlcXVpcmUoJy4vY29uZmlnRXJyb3InKTtcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGlzRXJyb3JFdmVudCA9IHV0aWxzLmlzRXJyb3JFdmVudDtcbnZhciBpc0RPTUVycm9yID0gdXRpbHMuaXNET01FcnJvcjtcbnZhciBpc0RPTUV4Y2VwdGlvbiA9IHV0aWxzLmlzRE9NRXhjZXB0aW9uO1xudmFyIGlzRXJyb3IgPSB1dGlscy5pc0Vycm9yO1xudmFyIGlzT2JqZWN0ID0gdXRpbHMuaXNPYmplY3Q7XG52YXIgaXNQbGFpbk9iamVjdCA9IHV0aWxzLmlzUGxhaW5PYmplY3Q7XG52YXIgaXNVbmRlZmluZWQgPSB1dGlscy5pc1VuZGVmaW5lZDtcbnZhciBpc0Z1bmN0aW9uID0gdXRpbHMuaXNGdW5jdGlvbjtcbnZhciBpc1N0cmluZyA9IHV0aWxzLmlzU3RyaW5nO1xudmFyIGlzQXJyYXkgPSB1dGlscy5pc0FycmF5O1xudmFyIGlzRW1wdHlPYmplY3QgPSB1dGlscy5pc0VtcHR5T2JqZWN0O1xudmFyIGVhY2ggPSB1dGlscy5lYWNoO1xudmFyIG9iamVjdE1lcmdlID0gdXRpbHMub2JqZWN0TWVyZ2U7XG52YXIgdHJ1bmNhdGUgPSB1dGlscy50cnVuY2F0ZTtcbnZhciBvYmplY3RGcm96ZW4gPSB1dGlscy5vYmplY3RGcm96ZW47XG52YXIgaGFzS2V5ID0gdXRpbHMuaGFzS2V5O1xudmFyIGpvaW5SZWdFeHAgPSB1dGlscy5qb2luUmVnRXhwO1xudmFyIHVybGVuY29kZSA9IHV0aWxzLnVybGVuY29kZTtcbnZhciB1dWlkNCA9IHV0aWxzLnV1aWQ0O1xudmFyIGh0bWxUcmVlQXNTdHJpbmcgPSB1dGlscy5odG1sVHJlZUFzU3RyaW5nO1xudmFyIGlzU2FtZUV4Y2VwdGlvbiA9IHV0aWxzLmlzU2FtZUV4Y2VwdGlvbjtcbnZhciBpc1NhbWVTdGFja3RyYWNlID0gdXRpbHMuaXNTYW1lU3RhY2t0cmFjZTtcbnZhciBwYXJzZVVybCA9IHV0aWxzLnBhcnNlVXJsO1xudmFyIGZpbGwgPSB1dGlscy5maWxsO1xudmFyIHN1cHBvcnRzRmV0Y2ggPSB1dGlscy5zdXBwb3J0c0ZldGNoO1xudmFyIHN1cHBvcnRzUmVmZXJyZXJQb2xpY3kgPSB1dGlscy5zdXBwb3J0c1JlZmVycmVyUG9saWN5O1xudmFyIHNlcmlhbGl6ZUtleXNGb3JNZXNzYWdlID0gdXRpbHMuc2VyaWFsaXplS2V5c0Zvck1lc3NhZ2U7XG52YXIgc2VyaWFsaXplRXhjZXB0aW9uID0gdXRpbHMuc2VyaWFsaXplRXhjZXB0aW9uO1xudmFyIHNhbml0aXplID0gdXRpbHMuc2FuaXRpemU7XG5cbnZhciB3cmFwQ29uc29sZU1ldGhvZCA9IHJlcXVpcmUoJy4vY29uc29sZScpLndyYXBNZXRob2Q7XG5cbnZhciBkc25LZXlzID0gJ3NvdXJjZSBwcm90b2NvbCB1c2VyIHBhc3MgaG9zdCBwb3J0IHBhdGgnLnNwbGl0KCcgJyksXG4gIGRzblBhdHRlcm4gPSAvXig/OihcXHcrKTopP1xcL1xcLyg/OihcXHcrKSg6XFx3Kyk/QCk/KFtcXHdcXC4tXSspKD86OihcXGQrKSk/KFxcLy4qKS87XG5cbmZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuICtuZXcgRGF0ZSgpO1xufVxuXG4vLyBUaGlzIGlzIHRvIGJlIGRlZmVuc2l2ZSBpbiBlbnZpcm9ubWVudHMgd2hlcmUgd2luZG93IGRvZXMgbm90IGV4aXN0IChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9yYXZlbi1qcy9wdWxsLzc4NSlcbnZhciBfd2luZG93ID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgPyBzZWxmIDoge307XG52YXIgX2RvY3VtZW50ID0gX3dpbmRvdy5kb2N1bWVudDtcbnZhciBfbmF2aWdhdG9yID0gX3dpbmRvdy5uYXZpZ2F0b3I7XG5cbmZ1bmN0aW9uIGtlZXBPcmlnaW5hbENhbGxiYWNrKG9yaWdpbmFsLCBjYWxsYmFjaykge1xuICByZXR1cm4gaXNGdW5jdGlvbihjYWxsYmFjaylcbiAgICA/IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEsIG9yaWdpbmFsKTtcbiAgICAgIH1cbiAgICA6IGNhbGxiYWNrO1xufVxuXG4vLyBGaXJzdCwgY2hlY2sgZm9yIEpTT04gc3VwcG9ydFxuLy8gSWYgdGhlcmUgaXMgbm8gSlNPTiwgd2Ugbm8tb3AgdGhlIGNvcmUgZmVhdHVyZXMgb2YgUmF2ZW5cbi8vIHNpbmNlIEpTT04gaXMgcmVxdWlyZWQgdG8gZW5jb2RlIHRoZSBwYXlsb2FkXG5mdW5jdGlvbiBSYXZlbigpIHtcbiAgdGhpcy5faGFzSlNPTiA9ICEhKHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyAmJiBKU09OLnN0cmluZ2lmeSk7XG4gIC8vIFJhdmVuIGNhbiBydW4gaW4gY29udGV4dHMgd2hlcmUgdGhlcmUncyBubyBkb2N1bWVudCAocmVhY3QtbmF0aXZlKVxuICB0aGlzLl9oYXNEb2N1bWVudCA9ICFpc1VuZGVmaW5lZChfZG9jdW1lbnQpO1xuICB0aGlzLl9oYXNOYXZpZ2F0b3IgPSAhaXNVbmRlZmluZWQoX25hdmlnYXRvcik7XG4gIHRoaXMuX2xhc3RDYXB0dXJlZEV4Y2VwdGlvbiA9IG51bGw7XG4gIHRoaXMuX2xhc3REYXRhID0gbnVsbDtcbiAgdGhpcy5fbGFzdEV2ZW50SWQgPSBudWxsO1xuICB0aGlzLl9nbG9iYWxTZXJ2ZXIgPSBudWxsO1xuICB0aGlzLl9nbG9iYWxLZXkgPSBudWxsO1xuICB0aGlzLl9nbG9iYWxQcm9qZWN0ID0gbnVsbDtcbiAgdGhpcy5fZ2xvYmFsQ29udGV4dCA9IHt9O1xuICB0aGlzLl9nbG9iYWxPcHRpb25zID0ge1xuICAgIC8vIFNFTlRSWV9SRUxFQVNFIGNhbiBiZSBpbmplY3RlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS13ZWJwYWNrLXBsdWdpblxuICAgIHJlbGVhc2U6IF93aW5kb3cuU0VOVFJZX1JFTEVBU0UgJiYgX3dpbmRvdy5TRU5UUllfUkVMRUFTRS5pZCxcbiAgICBsb2dnZXI6ICdqYXZhc2NyaXB0JyxcbiAgICBpZ25vcmVFcnJvcnM6IFtdLFxuICAgIGlnbm9yZVVybHM6IFtdLFxuICAgIHdoaXRlbGlzdFVybHM6IFtdLFxuICAgIGluY2x1ZGVQYXRoczogW10sXG4gICAgaGVhZGVyczogbnVsbCxcbiAgICBjb2xsZWN0V2luZG93RXJyb3JzOiB0cnVlLFxuICAgIGNhcHR1cmVVbmhhbmRsZWRSZWplY3Rpb25zOiB0cnVlLFxuICAgIG1heE1lc3NhZ2VMZW5ndGg6IDAsXG4gICAgLy8gQnkgZGVmYXVsdCwgdHJ1bmNhdGVzIFVSTCB2YWx1ZXMgdG8gMjUwIGNoYXJzXG4gICAgbWF4VXJsTGVuZ3RoOiAyNTAsXG4gICAgc3RhY2tUcmFjZUxpbWl0OiA1MCxcbiAgICBhdXRvQnJlYWRjcnVtYnM6IHRydWUsXG4gICAgaW5zdHJ1bWVudDogdHJ1ZSxcbiAgICBzYW1wbGVSYXRlOiAxLFxuICAgIHNhbml0aXplS2V5czogW11cbiAgfTtcbiAgdGhpcy5fZmV0Y2hEZWZhdWx0cyA9IHtcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAvLyBEZXNwaXRlIGFsbCBzdGFycyBpbiB0aGUgc2t5IHNheWluZyB0aGF0IEVkZ2Ugc3VwcG9ydHMgb2xkIGRyYWZ0IHN5bnRheCwgYWthICduZXZlcicsICdhbHdheXMnLCAnb3JpZ2luJyBhbmQgJ2RlZmF1bHRcbiAgICAvLyBodHRwczovL2Nhbml1c2UuY29tLyNmZWF0PXJlZmVycmVyLXBvbGljeVxuICAgIC8vIEl0IGRvZXNuJ3QuIEFuZCBpdCB0aHJvdyBleGNlcHRpb24gaW5zdGVhZCBvZiBpZ25vcmluZyB0aGlzIHBhcmFtZXRlci4uLlxuICAgIC8vIFJFRjogaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9yYXZlbi1qcy9pc3N1ZXMvMTIzM1xuICAgIHJlZmVycmVyUG9saWN5OiBzdXBwb3J0c1JlZmVycmVyUG9saWN5KCkgPyAnb3JpZ2luJyA6ICcnXG4gIH07XG4gIHRoaXMuX2lnbm9yZU9uRXJyb3IgPSAwO1xuICB0aGlzLl9pc1JhdmVuSW5zdGFsbGVkID0gZmFsc2U7XG4gIHRoaXMuX29yaWdpbmFsRXJyb3JTdGFja1RyYWNlTGltaXQgPSBFcnJvci5zdGFja1RyYWNlTGltaXQ7XG4gIC8vIGNhcHR1cmUgcmVmZXJlbmNlcyB0byB3aW5kb3cuY29uc29sZSAqYW5kKiBhbGwgaXRzIG1ldGhvZHMgZmlyc3RcbiAgLy8gYmVmb3JlIHRoZSBjb25zb2xlIHBsdWdpbiBoYXMgYSBjaGFuY2UgdG8gbW9ua2V5IHBhdGNoXG4gIHRoaXMuX29yaWdpbmFsQ29uc29sZSA9IF93aW5kb3cuY29uc29sZSB8fCB7fTtcbiAgdGhpcy5fb3JpZ2luYWxDb25zb2xlTWV0aG9kcyA9IHt9O1xuICB0aGlzLl9wbHVnaW5zID0gW107XG4gIHRoaXMuX3N0YXJ0VGltZSA9IG5vdygpO1xuICB0aGlzLl93cmFwcGVkQnVpbHRJbnMgPSBbXTtcbiAgdGhpcy5fYnJlYWRjcnVtYnMgPSBbXTtcbiAgdGhpcy5fbGFzdENhcHR1cmVkRXZlbnQgPSBudWxsO1xuICB0aGlzLl9rZXlwcmVzc1RpbWVvdXQ7XG4gIHRoaXMuX2xvY2F0aW9uID0gX3dpbmRvdy5sb2NhdGlvbjtcbiAgdGhpcy5fbGFzdEhyZWYgPSB0aGlzLl9sb2NhdGlvbiAmJiB0aGlzLl9sb2NhdGlvbi5ocmVmO1xuICB0aGlzLl9yZXNldEJhY2tvZmYoKTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZ3VhcmQtZm9yLWluXG4gIGZvciAodmFyIG1ldGhvZCBpbiB0aGlzLl9vcmlnaW5hbENvbnNvbGUpIHtcbiAgICB0aGlzLl9vcmlnaW5hbENvbnNvbGVNZXRob2RzW21ldGhvZF0gPSB0aGlzLl9vcmlnaW5hbENvbnNvbGVbbWV0aG9kXTtcbiAgfVxufVxuXG4vKlxuICogVGhlIGNvcmUgUmF2ZW4gc2luZ2xldG9uXG4gKlxuICogQHRoaXMge1JhdmVufVxuICovXG5cblJhdmVuLnByb3RvdHlwZSA9IHtcbiAgLy8gSGFyZGNvZGUgdmVyc2lvbiBzdHJpbmcgc28gdGhhdCByYXZlbiBzb3VyY2UgY2FuIGJlIGxvYWRlZCBkaXJlY3RseSB2aWFcbiAgLy8gd2VicGFjayAodXNpbmcgYSBidWlsZCBzdGVwIGNhdXNlcyB3ZWJwYWNrICMxNjE3KS4gR3J1bnQgdmVyaWZpZXMgdGhhdFxuICAvLyB0aGlzIHZhbHVlIG1hdGNoZXMgcGFja2FnZS5qc29uIGR1cmluZyBidWlsZC5cbiAgLy8gICBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvcmF2ZW4tanMvaXNzdWVzLzQ2NVxuICBWRVJTSU9OOiAnMy4yNy4yJyxcblxuICBkZWJ1ZzogZmFsc2UsXG5cbiAgVHJhY2VLaXQ6IFRyYWNlS2l0LCAvLyBhbGlhcyB0byBUcmFjZUtpdFxuXG4gIC8qXG4gICAgICogQ29uZmlndXJlIFJhdmVuIHdpdGggYSBEU04gYW5kIGV4dHJhIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkc24gVGhlIHB1YmxpYyBTZW50cnkgRFNOXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgU2V0IG9mIGdsb2JhbCBvcHRpb25zIFtvcHRpb25hbF1cbiAgICAgKiBAcmV0dXJuIHtSYXZlbn1cbiAgICAgKi9cbiAgY29uZmlnOiBmdW5jdGlvbihkc24sIG9wdGlvbnMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoc2VsZi5fZ2xvYmFsU2VydmVyKSB7XG4gICAgICB0aGlzLl9sb2dEZWJ1ZygnZXJyb3InLCAnRXJyb3I6IFJhdmVuIGhhcyBhbHJlYWR5IGJlZW4gY29uZmlndXJlZCcpO1xuICAgICAgcmV0dXJuIHNlbGY7XG4gICAgfVxuICAgIGlmICghZHNuKSByZXR1cm4gc2VsZjtcblxuICAgIHZhciBnbG9iYWxPcHRpb25zID0gc2VsZi5fZ2xvYmFsT3B0aW9ucztcblxuICAgIC8vIG1lcmdlIGluIG9wdGlvbnNcbiAgICBpZiAob3B0aW9ucykge1xuICAgICAgZWFjaChvcHRpb25zLCBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgIC8vIHRhZ3MgYW5kIGV4dHJhIGFyZSBzcGVjaWFsIGFuZCBuZWVkIHRvIGJlIHB1dCBpbnRvIGNvbnRleHRcbiAgICAgICAgaWYgKGtleSA9PT0gJ3RhZ3MnIHx8IGtleSA9PT0gJ2V4dHJhJyB8fCBrZXkgPT09ICd1c2VyJykge1xuICAgICAgICAgIHNlbGYuX2dsb2JhbENvbnRleHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdsb2JhbE9wdGlvbnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBzZWxmLnNldERTTihkc24pO1xuXG4gICAgLy8gXCJTY3JpcHQgZXJyb3IuXCIgaXMgaGFyZCBjb2RlZCBpbnRvIGJyb3dzZXJzIGZvciBlcnJvcnMgdGhhdCBpdCBjYW4ndCByZWFkLlxuICAgIC8vIHRoaXMgaXMgdGhlIHJlc3VsdCBvZiBhIHNjcmlwdCBiZWluZyBwdWxsZWQgaW4gZnJvbSBhbiBleHRlcm5hbCBkb21haW4gYW5kIENPUlMuXG4gICAgZ2xvYmFsT3B0aW9ucy5pZ25vcmVFcnJvcnMucHVzaCgvXlNjcmlwdCBlcnJvclxcLj8kLyk7XG4gICAgZ2xvYmFsT3B0aW9ucy5pZ25vcmVFcnJvcnMucHVzaCgvXkphdmFzY3JpcHQgZXJyb3I6IFNjcmlwdCBlcnJvclxcLj8gb24gbGluZSAwJC8pO1xuXG4gICAgLy8gam9pbiByZWdleHAgcnVsZXMgaW50byBvbmUgYmlnIHJ1bGVcbiAgICBnbG9iYWxPcHRpb25zLmlnbm9yZUVycm9ycyA9IGpvaW5SZWdFeHAoZ2xvYmFsT3B0aW9ucy5pZ25vcmVFcnJvcnMpO1xuICAgIGdsb2JhbE9wdGlvbnMuaWdub3JlVXJscyA9IGdsb2JhbE9wdGlvbnMuaWdub3JlVXJscy5sZW5ndGhcbiAgICAgID8gam9pblJlZ0V4cChnbG9iYWxPcHRpb25zLmlnbm9yZVVybHMpXG4gICAgICA6IGZhbHNlO1xuICAgIGdsb2JhbE9wdGlvbnMud2hpdGVsaXN0VXJscyA9IGdsb2JhbE9wdGlvbnMud2hpdGVsaXN0VXJscy5sZW5ndGhcbiAgICAgID8gam9pblJlZ0V4cChnbG9iYWxPcHRpb25zLndoaXRlbGlzdFVybHMpXG4gICAgICA6IGZhbHNlO1xuICAgIGdsb2JhbE9wdGlvbnMuaW5jbHVkZVBhdGhzID0gam9pblJlZ0V4cChnbG9iYWxPcHRpb25zLmluY2x1ZGVQYXRocyk7XG4gICAgZ2xvYmFsT3B0aW9ucy5tYXhCcmVhZGNydW1icyA9IE1hdGgubWF4KFxuICAgICAgMCxcbiAgICAgIE1hdGgubWluKGdsb2JhbE9wdGlvbnMubWF4QnJlYWRjcnVtYnMgfHwgMTAwLCAxMDApXG4gICAgKTsgLy8gZGVmYXVsdCBhbmQgaGFyZCBsaW1pdCBpcyAxMDBcblxuICAgIHZhciBhdXRvQnJlYWRjcnVtYkRlZmF1bHRzID0ge1xuICAgICAgeGhyOiB0cnVlLFxuICAgICAgY29uc29sZTogdHJ1ZSxcbiAgICAgIGRvbTogdHJ1ZSxcbiAgICAgIGxvY2F0aW9uOiB0cnVlLFxuICAgICAgc2VudHJ5OiB0cnVlXG4gICAgfTtcblxuICAgIHZhciBhdXRvQnJlYWRjcnVtYnMgPSBnbG9iYWxPcHRpb25zLmF1dG9CcmVhZGNydW1icztcbiAgICBpZiAoe30udG9TdHJpbmcuY2FsbChhdXRvQnJlYWRjcnVtYnMpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgYXV0b0JyZWFkY3J1bWJzID0gb2JqZWN0TWVyZ2UoYXV0b0JyZWFkY3J1bWJEZWZhdWx0cywgYXV0b0JyZWFkY3J1bWJzKTtcbiAgICB9IGVsc2UgaWYgKGF1dG9CcmVhZGNydW1icyAhPT0gZmFsc2UpIHtcbiAgICAgIGF1dG9CcmVhZGNydW1icyA9IGF1dG9CcmVhZGNydW1iRGVmYXVsdHM7XG4gICAgfVxuICAgIGdsb2JhbE9wdGlvbnMuYXV0b0JyZWFkY3J1bWJzID0gYXV0b0JyZWFkY3J1bWJzO1xuXG4gICAgdmFyIGluc3RydW1lbnREZWZhdWx0cyA9IHtcbiAgICAgIHRyeUNhdGNoOiB0cnVlXG4gICAgfTtcblxuICAgIHZhciBpbnN0cnVtZW50ID0gZ2xvYmFsT3B0aW9ucy5pbnN0cnVtZW50O1xuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGluc3RydW1lbnQpID09PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgICAgaW5zdHJ1bWVudCA9IG9iamVjdE1lcmdlKGluc3RydW1lbnREZWZhdWx0cywgaW5zdHJ1bWVudCk7XG4gICAgfSBlbHNlIGlmIChpbnN0cnVtZW50ICE9PSBmYWxzZSkge1xuICAgICAgaW5zdHJ1bWVudCA9IGluc3RydW1lbnREZWZhdWx0cztcbiAgICB9XG4gICAgZ2xvYmFsT3B0aW9ucy5pbnN0cnVtZW50ID0gaW5zdHJ1bWVudDtcblxuICAgIFRyYWNlS2l0LmNvbGxlY3RXaW5kb3dFcnJvcnMgPSAhIWdsb2JhbE9wdGlvbnMuY29sbGVjdFdpbmRvd0Vycm9ycztcblxuICAgIC8vIHJldHVybiBmb3IgY2hhaW5pbmdcbiAgICByZXR1cm4gc2VsZjtcbiAgfSxcblxuICAvKlxuICAgICAqIEluc3RhbGxzIGEgZ2xvYmFsIHdpbmRvdy5vbmVycm9yIGVycm9yIGhhbmRsZXJcbiAgICAgKiB0byBjYXB0dXJlIGFuZCByZXBvcnQgdW5jYXVnaHQgZXhjZXB0aW9ucy5cbiAgICAgKiBBdCB0aGlzIHBvaW50LCBpbnN0YWxsKCkgaXMgcmVxdWlyZWQgdG8gYmUgY2FsbGVkIGR1ZVxuICAgICAqIHRvIHRoZSB3YXkgVHJhY2VLaXQgaXMgc2V0IHVwLlxuICAgICAqXG4gICAgICogQHJldHVybiB7UmF2ZW59XG4gICAgICovXG4gIGluc3RhbGw6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAoc2VsZi5pc1NldHVwKCkgJiYgIXNlbGYuX2lzUmF2ZW5JbnN0YWxsZWQpIHtcbiAgICAgIFRyYWNlS2l0LnJlcG9ydC5zdWJzY3JpYmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYuX2hhbmRsZU9uRXJyb3JTdGFja0luZm8uYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoc2VsZi5fZ2xvYmFsT3B0aW9ucy5jYXB0dXJlVW5oYW5kbGVkUmVqZWN0aW9ucykge1xuICAgICAgICBzZWxmLl9hdHRhY2hQcm9taXNlUmVqZWN0aW9uSGFuZGxlcigpO1xuICAgICAgfVxuXG4gICAgICBzZWxmLl9wYXRjaEZ1bmN0aW9uVG9TdHJpbmcoKTtcblxuICAgICAgaWYgKHNlbGYuX2dsb2JhbE9wdGlvbnMuaW5zdHJ1bWVudCAmJiBzZWxmLl9nbG9iYWxPcHRpb25zLmluc3RydW1lbnQudHJ5Q2F0Y2gpIHtcbiAgICAgICAgc2VsZi5faW5zdHJ1bWVudFRyeUNhdGNoKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxmLl9nbG9iYWxPcHRpb25zLmF1dG9CcmVhZGNydW1icykgc2VsZi5faW5zdHJ1bWVudEJyZWFkY3J1bWJzKCk7XG5cbiAgICAgIC8vIEluc3RhbGwgYWxsIG9mIHRoZSBwbHVnaW5zXG4gICAgICBzZWxmLl9kcmFpblBsdWdpbnMoKTtcblxuICAgICAgc2VsZi5faXNSYXZlbkluc3RhbGxlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgRXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gc2VsZi5fZ2xvYmFsT3B0aW9ucy5zdGFja1RyYWNlTGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLypcbiAgICAgKiBTZXQgdGhlIERTTiAoY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lIHVubGlrZSBjb25maWcpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZHNuIFRoZSBwdWJsaWMgU2VudHJ5IERTTlxuICAgICAqL1xuICBzZXREU046IGZ1bmN0aW9uKGRzbikge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIHVyaSA9IHNlbGYuX3BhcnNlRFNOKGRzbiksXG4gICAgICBsYXN0U2xhc2ggPSB1cmkucGF0aC5sYXN0SW5kZXhPZignLycpLFxuICAgICAgcGF0aCA9IHVyaS5wYXRoLnN1YnN0cigxLCBsYXN0U2xhc2gpO1xuXG4gICAgc2VsZi5fZHNuID0gZHNuO1xuICAgIHNlbGYuX2dsb2JhbEtleSA9IHVyaS51c2VyO1xuICAgIHNlbGYuX2dsb2JhbFNlY3JldCA9IHVyaS5wYXNzICYmIHVyaS5wYXNzLnN1YnN0cigxKTtcbiAgICBzZWxmLl9nbG9iYWxQcm9qZWN0ID0gdXJpLnBhdGguc3Vic3RyKGxhc3RTbGFzaCArIDEpO1xuXG4gICAgc2VsZi5fZ2xvYmFsU2VydmVyID0gc2VsZi5fZ2V0R2xvYmFsU2VydmVyKHVyaSk7XG5cbiAgICBzZWxmLl9nbG9iYWxFbmRwb2ludCA9XG4gICAgICBzZWxmLl9nbG9iYWxTZXJ2ZXIgKyAnLycgKyBwYXRoICsgJ2FwaS8nICsgc2VsZi5fZ2xvYmFsUHJvamVjdCArICcvc3RvcmUvJztcblxuICAgIC8vIFJlc2V0IGJhY2tvZmYgc3RhdGUgc2luY2Ugd2UgbWF5IGJlIHBvaW50aW5nIGF0IGFcbiAgICAvLyBuZXcgcHJvamVjdC9zZXJ2ZXJcbiAgICB0aGlzLl9yZXNldEJhY2tvZmYoKTtcbiAgfSxcblxuICAvKlxuICAgICAqIFdyYXAgY29kZSB3aXRoaW4gYSBjb250ZXh0IHNvIFJhdmVuIGNhbiBjYXB0dXJlIGVycm9yc1xuICAgICAqIHJlbGlhYmx5IGFjcm9zcyBkb21haW5zIHRoYXQgaXMgZXhlY3V0ZWQgaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBIHNwZWNpZmljIHNldCBvZiBvcHRpb25zIGZvciB0aGlzIGNvbnRleHQgW29wdGlvbmFsXVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgVGhlIGNhbGxiYWNrIHRvIGJlIGltbWVkaWF0ZWx5IGV4ZWN1dGVkIHdpdGhpbiB0aGUgY29udGV4dFxuICAgICAqIEBwYXJhbSB7YXJyYXl9IGFyZ3MgQW4gYXJyYXkgb2YgYXJndW1lbnRzIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBjYWxsYmFjayBbb3B0aW9uYWxdXG4gICAgICovXG4gIGNvbnRleHQ6IGZ1bmN0aW9uKG9wdGlvbnMsIGZ1bmMsIGFyZ3MpIHtcbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgYXJncyA9IGZ1bmMgfHwgW107XG4gICAgICBmdW5jID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy53cmFwKG9wdGlvbnMsIGZ1bmMpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9LFxuXG4gIC8qXG4gICAgICogV3JhcCBjb2RlIHdpdGhpbiBhIGNvbnRleHQgYW5kIHJldHVybnMgYmFjayBhIG5ldyBmdW5jdGlvbiB0byBiZSBleGVjdXRlZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQSBzcGVjaWZpYyBzZXQgb2Ygb3B0aW9ucyBmb3IgdGhpcyBjb250ZXh0IFtvcHRpb25hbF1cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiZSB3cmFwcGVkIGluIGEgbmV3IGNvbnRleHRcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBfYmVmb3JlIEEgZnVuY3Rpb24gdG8gY2FsbCBiZWZvcmUgdGhlIHRyeS9jYXRjaCB3cmFwcGVyIFtvcHRpb25hbCwgcHJpdmF0ZV1cbiAgICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gVGhlIG5ld2x5IHdyYXBwZWQgZnVuY3Rpb25zIHdpdGggYSBjb250ZXh0XG4gICAgICovXG4gIHdyYXA6IGZ1bmN0aW9uKG9wdGlvbnMsIGZ1bmMsIF9iZWZvcmUpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgLy8gMSBhcmd1bWVudCBoYXMgYmVlbiBwYXNzZWQsIGFuZCBpdCdzIG5vdCBhIGZ1bmN0aW9uXG4gICAgLy8gc28ganVzdCByZXR1cm4gaXRcbiAgICBpZiAoaXNVbmRlZmluZWQoZnVuYykgJiYgIWlzRnVuY3Rpb24ob3B0aW9ucykpIHtcbiAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cblxuICAgIC8vIG9wdGlvbnMgaXMgb3B0aW9uYWxcbiAgICBpZiAoaXNGdW5jdGlvbihvcHRpb25zKSkge1xuICAgICAgZnVuYyA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlJ3ZlIHBhc3NlZCBhbG9uZyAyIGFyZ3VtZW50cywgYW5kIHRoZSBzZWNvbmQgb25lXG4gICAgLy8gaXMgbm90IGEgZnVuY3Rpb24gZWl0aGVyLCBzbyB3ZSdsbCBqdXN0IHJldHVybiB0aGUgc2Vjb25kIGFyZ3VtZW50LlxuICAgIGlmICghaXNGdW5jdGlvbihmdW5jKSkge1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfVxuXG4gICAgLy8gV2UgZG9uJ3Qgd2FubmEgd3JhcCBpdCB0d2ljZSFcbiAgICB0cnkge1xuICAgICAgaWYgKGZ1bmMuX19yYXZlbl9fKSB7XG4gICAgICAgIHJldHVybiBmdW5jO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGhhcyBhbHJlYWR5IGJlZW4gd3JhcHBlZCBpbiB0aGUgcGFzdCwgcmV0dXJuIHRoYXRcbiAgICAgIGlmIChmdW5jLl9fcmF2ZW5fd3JhcHBlcl9fKSB7XG4gICAgICAgIHJldHVybiBmdW5jLl9fcmF2ZW5fd3JhcHBlcl9fO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIEp1c3QgYWNjZXNzaW5nIGN1c3RvbSBwcm9wcyBpbiBzb21lIFNlbGVuaXVtIGVudmlyb25tZW50c1xuICAgICAgLy8gY2FuIGNhdXNlIGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGV4Y2VwdGlvbiAoc2VlIHJhdmVuLWpzIzQ5NSkuXG4gICAgICAvLyBCYWlsIG9uIHdyYXBwaW5nIGFuZCByZXR1cm4gdGhlIGZ1bmN0aW9uIGFzLWlzIChkZWZlcnMgdG8gd2luZG93Lm9uZXJyb3IpLlxuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gd3JhcHBlZCgpIHtcbiAgICAgIHZhciBhcmdzID0gW10sXG4gICAgICAgIGkgPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICBkZWVwID0gIW9wdGlvbnMgfHwgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWVwICE9PSBmYWxzZSk7XG5cbiAgICAgIGlmIChfYmVmb3JlICYmIGlzRnVuY3Rpb24oX2JlZm9yZSkpIHtcbiAgICAgICAgX2JlZm9yZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZWN1cnNpdmVseSB3cmFwIGFsbCBvZiBhIGZ1bmN0aW9uJ3MgYXJndW1lbnRzIHRoYXQgYXJlXG4gICAgICAvLyBmdW5jdGlvbnMgdGhlbXNlbHZlcy5cbiAgICAgIHdoaWxlIChpLS0pIGFyZ3NbaV0gPSBkZWVwID8gc2VsZi53cmFwKG9wdGlvbnMsIGFyZ3VtZW50c1tpXSkgOiBhcmd1bWVudHNbaV07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEF0dGVtcHQgdG8gaW52b2tlIHVzZXItbGFuZCBmdW5jdGlvblxuICAgICAgICAvLyBOT1RFOiBJZiB5b3UgYXJlIGEgU2VudHJ5IHVzZXIsIGFuZCB5b3UgYXJlIHNlZWluZyB0aGlzIHN0YWNrIGZyYW1lLCBpdFxuICAgICAgICAvLyAgICAgICBtZWFucyBSYXZlbiBjYXVnaHQgYW4gZXJyb3IgaW52b2tpbmcgeW91ciBhcHBsaWNhdGlvbiBjb2RlLiBUaGlzIGlzXG4gICAgICAgIC8vICAgICAgIGV4cGVjdGVkIGJlaGF2aW9yIGFuZCBOT1QgaW5kaWNhdGl2ZSBvZiBhIGJ1ZyB3aXRoIFJhdmVuLmpzLlxuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2VsZi5faWdub3JlTmV4dE9uRXJyb3IoKTtcbiAgICAgICAgc2VsZi5jYXB0dXJlRXhjZXB0aW9uKGUsIG9wdGlvbnMpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNvcHkgb3ZlciBwcm9wZXJ0aWVzIG9mIHRoZSBvbGQgZnVuY3Rpb25cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBmdW5jKSB7XG4gICAgICBpZiAoaGFzS2V5KGZ1bmMsIHByb3BlcnR5KSkge1xuICAgICAgICB3cmFwcGVkW3Byb3BlcnR5XSA9IGZ1bmNbcHJvcGVydHldO1xuICAgICAgfVxuICAgIH1cbiAgICB3cmFwcGVkLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuXG4gICAgZnVuYy5fX3JhdmVuX3dyYXBwZXJfXyA9IHdyYXBwZWQ7XG4gICAgLy8gU2lnbmFsIHRoYXQgdGhpcyBmdW5jdGlvbiBoYXMgYmVlbiB3cmFwcGVkL2ZpbGxlZCBhbHJlYWR5XG4gICAgLy8gZm9yIGJvdGggZGVidWdnaW5nIGFuZCB0byBwcmV2ZW50IGl0IHRvIGJlaW5nIHdyYXBwZWQvZmlsbGVkIHR3aWNlXG4gICAgd3JhcHBlZC5fX3JhdmVuX18gPSB0cnVlO1xuICAgIHdyYXBwZWQuX19vcmlnX18gPSBmdW5jO1xuXG4gICAgcmV0dXJuIHdyYXBwZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVuaW5zdGFsbHMgdGhlIGdsb2JhbCBlcnJvciBoYW5kbGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtSYXZlbn1cbiAgICovXG4gIHVuaW5zdGFsbDogZnVuY3Rpb24oKSB7XG4gICAgVHJhY2VLaXQucmVwb3J0LnVuaW5zdGFsbCgpO1xuXG4gICAgdGhpcy5fZGV0YWNoUHJvbWlzZVJlamVjdGlvbkhhbmRsZXIoKTtcbiAgICB0aGlzLl91bnBhdGNoRnVuY3Rpb25Ub1N0cmluZygpO1xuICAgIHRoaXMuX3Jlc3RvcmVCdWlsdElucygpO1xuICAgIHRoaXMuX3Jlc3RvcmVDb25zb2xlKCk7XG5cbiAgICBFcnJvci5zdGFja1RyYWNlTGltaXQgPSB0aGlzLl9vcmlnaW5hbEVycm9yU3RhY2tUcmFjZUxpbWl0O1xuICAgIHRoaXMuX2lzUmF2ZW5JbnN0YWxsZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayB1c2VkIGZvciBgdW5oYW5kbGVkcmVqZWN0aW9uYCBldmVudFxuICAgKlxuICAgKiBAcGFyYW0ge1Byb21pc2VSZWplY3Rpb25FdmVudH0gZXZlbnQgQW4gb2JqZWN0IGNvbnRhaW5pbmdcbiAgICogICBwcm9taXNlOiB0aGUgUHJvbWlzZSB0aGF0IHdhcyByZWplY3RlZFxuICAgKiAgIHJlYXNvbjogdGhlIHZhbHVlIHdpdGggd2hpY2ggdGhlIFByb21pc2Ugd2FzIHJlamVjdGVkXG4gICAqIEByZXR1cm4gdm9pZFxuICAgKi9cbiAgX3Byb21pc2VSZWplY3Rpb25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIHRoaXMuX2xvZ0RlYnVnKCdkZWJ1ZycsICdSYXZlbiBjYXVnaHQgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uOicsIGV2ZW50KTtcbiAgICB0aGlzLmNhcHR1cmVFeGNlcHRpb24oZXZlbnQucmVhc29uLCB7XG4gICAgICBtZWNoYW5pc206IHtcbiAgICAgICAgdHlwZTogJ29udW5oYW5kbGVkcmVqZWN0aW9uJyxcbiAgICAgICAgaGFuZGxlZDogZmFsc2VcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogSW5zdGFsbHMgdGhlIGdsb2JhbCBwcm9taXNlIHJlamVjdGlvbiBoYW5kbGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtyYXZlbn1cbiAgICovXG4gIF9hdHRhY2hQcm9taXNlUmVqZWN0aW9uSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcHJvbWlzZVJlamVjdGlvbkhhbmRsZXIgPSB0aGlzLl9wcm9taXNlUmVqZWN0aW9uSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgIF93aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAmJlxuICAgICAgX3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd1bmhhbmRsZWRyZWplY3Rpb24nLCB0aGlzLl9wcm9taXNlUmVqZWN0aW9uSGFuZGxlcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVuaW5zdGFsbHMgdGhlIGdsb2JhbCBwcm9taXNlIHJlamVjdGlvbiBoYW5kbGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtyYXZlbn1cbiAgICovXG4gIF9kZXRhY2hQcm9taXNlUmVqZWN0aW9uSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgX3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyICYmXG4gICAgICBfd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicsIHRoaXMuX3Byb21pc2VSZWplY3Rpb25IYW5kbGVyKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogTWFudWFsbHkgY2FwdHVyZSBhbiBleGNlcHRpb24gYW5kIHNlbmQgaXQgb3ZlciB0byBTZW50cnlcbiAgICpcbiAgICogQHBhcmFtIHtlcnJvcn0gZXggQW4gZXhjZXB0aW9uIHRvIGJlIGxvZ2dlZFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBIHNwZWNpZmljIHNldCBvZiBvcHRpb25zIGZvciB0aGlzIGVycm9yIFtvcHRpb25hbF1cbiAgICogQHJldHVybiB7UmF2ZW59XG4gICAqL1xuICBjYXB0dXJlRXhjZXB0aW9uOiBmdW5jdGlvbihleCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvYmplY3RNZXJnZSh7dHJpbUhlYWRGcmFtZXM6IDB9LCBvcHRpb25zID8gb3B0aW9ucyA6IHt9KTtcblxuICAgIGlmIChpc0Vycm9yRXZlbnQoZXgpICYmIGV4LmVycm9yKSB7XG4gICAgICAvLyBJZiBpdCBpcyBhbiBFcnJvckV2ZW50IHdpdGggYGVycm9yYCBwcm9wZXJ0eSwgZXh0cmFjdCBpdCB0byBnZXQgYWN0dWFsIEVycm9yXG4gICAgICBleCA9IGV4LmVycm9yO1xuICAgIH0gZWxzZSBpZiAoaXNET01FcnJvcihleCkgfHwgaXNET01FeGNlcHRpb24oZXgpKSB7XG4gICAgICAvLyBJZiBpdCBpcyBhIERPTUVycm9yIG9yIERPTUV4Y2VwdGlvbiAod2hpY2ggYXJlIGxlZ2FjeSBBUElzLCBidXQgc3RpbGwgc3VwcG9ydGVkIGluIHNvbWUgYnJvd3NlcnMpXG4gICAgICAvLyB0aGVuIHdlIGp1c3QgZXh0cmFjdCB0aGUgbmFtZSBhbmQgbWVzc2FnZSwgYXMgdGhleSBkb24ndCBwcm92aWRlIGFueXRoaW5nIGVsc2VcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9ET01FcnJvclxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RPTUV4Y2VwdGlvblxuICAgICAgdmFyIG5hbWUgPSBleC5uYW1lIHx8IChpc0RPTUVycm9yKGV4KSA/ICdET01FcnJvcicgOiAnRE9NRXhjZXB0aW9uJyk7XG4gICAgICB2YXIgbWVzc2FnZSA9IGV4Lm1lc3NhZ2UgPyBuYW1lICsgJzogJyArIGV4Lm1lc3NhZ2UgOiBuYW1lO1xuXG4gICAgICByZXR1cm4gdGhpcy5jYXB0dXJlTWVzc2FnZShcbiAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgb2JqZWN0TWVyZ2Uob3B0aW9ucywge1xuICAgICAgICAgIC8vIG5laXRoZXIgRE9NRXJyb3Igb3IgRE9NRXhjZXB0aW9uIHByb3ZpZGUgc3RhY2sgdHJhY2UgYW5kIHdlIG1vc3QgbGlrZWx5IHdvbnQgZ2V0IGl0IHRoaXMgd2F5IGFzIHdlbGxcbiAgICAgICAgICAvLyBidXQgaXQncyBiYXJlbHkgYW55IG92ZXJoZWFkIHNvIHdlIG1heSBhdCBsZWFzdCB0cnlcbiAgICAgICAgICBzdGFja3RyYWNlOiB0cnVlLFxuICAgICAgICAgIHRyaW1IZWFkRnJhbWVzOiBvcHRpb25zLnRyaW1IZWFkRnJhbWVzICsgMVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKGlzRXJyb3IoZXgpKSB7XG4gICAgICAvLyB3ZSBoYXZlIGEgcmVhbCBFcnJvciBvYmplY3RcbiAgICAgIGV4ID0gZXg7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGV4KSkge1xuICAgICAgLy8gSWYgaXQgaXMgcGxhaW4gT2JqZWN0LCBzZXJpYWxpemUgaXQgbWFudWFsbHkgYW5kIGV4dHJhY3Qgb3B0aW9uc1xuICAgICAgLy8gVGhpcyB3aWxsIGFsbG93IHVzIHRvIGdyb3VwIGV2ZW50cyBiYXNlZCBvbiB0b3AtbGV2ZWwga2V5c1xuICAgICAgLy8gd2hpY2ggaXMgbXVjaCBiZXR0ZXIgdGhhbiBjcmVhdGluZyBuZXcgZ3JvdXAgd2hlbiBhbnkga2V5L3ZhbHVlIGNoYW5nZVxuICAgICAgb3B0aW9ucyA9IHRoaXMuX2dldENhcHR1cmVFeGNlcHRpb25PcHRpb25zRnJvbVBsYWluT2JqZWN0KG9wdGlvbnMsIGV4KTtcbiAgICAgIGV4ID0gbmV3IEVycm9yKG9wdGlvbnMubWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIG5vbmUgb2YgcHJldmlvdXMgY2hlY2tzIHdlcmUgdmFsaWQsIHRoZW4gaXQgbWVhbnMgdGhhdFxuICAgICAgLy8gaXQncyBub3QgYSBET01FcnJvci9ET01FeGNlcHRpb25cbiAgICAgIC8vIGl0J3Mgbm90IGEgcGxhaW4gT2JqZWN0XG4gICAgICAvLyBpdCdzIG5vdCBhIHZhbGlkIEVycm9yRXZlbnQgKG9uZSB3aXRoIGFuIGVycm9yIHByb3BlcnR5KVxuICAgICAgLy8gaXQncyBub3QgYW4gRXJyb3JcbiAgICAgIC8vIFNvIGJhaWwgb3V0IGFuZCBjYXB0dXJlIGl0IGFzIGEgc2ltcGxlIG1lc3NhZ2U6XG4gICAgICByZXR1cm4gdGhpcy5jYXB0dXJlTWVzc2FnZShcbiAgICAgICAgZXgsXG4gICAgICAgIG9iamVjdE1lcmdlKG9wdGlvbnMsIHtcbiAgICAgICAgICBzdGFja3RyYWNlOiB0cnVlLCAvLyBpZiB3ZSBmYWxsIGJhY2sgdG8gY2FwdHVyZU1lc3NhZ2UsIGRlZmF1bHQgdG8gYXR0ZW1wdGluZyBhIG5ldyB0cmFjZVxuICAgICAgICAgIHRyaW1IZWFkRnJhbWVzOiBvcHRpb25zLnRyaW1IZWFkRnJhbWVzICsgMVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBTdG9yZSB0aGUgcmF3IGV4Y2VwdGlvbiBvYmplY3QgZm9yIHBvdGVudGlhbCBkZWJ1Z2dpbmcgYW5kIGludHJvc3BlY3Rpb25cbiAgICB0aGlzLl9sYXN0Q2FwdHVyZWRFeGNlcHRpb24gPSBleDtcblxuICAgIC8vIFRyYWNlS2l0LnJlcG9ydCB3aWxsIHJlLXJhaXNlIGFueSBleGNlcHRpb24gcGFzc2VkIHRvIGl0LFxuICAgIC8vIHdoaWNoIG1lYW5zIHlvdSBoYXZlIHRvIHdyYXAgaXQgaW4gdHJ5L2NhdGNoLiBJbnN0ZWFkLCB3ZVxuICAgIC8vIGNhbiB3cmFwIGl0IGhlcmUgYW5kIG9ubHkgcmUtcmFpc2UgaWYgVHJhY2VLaXQucmVwb3J0XG4gICAgLy8gcmFpc2VzIGFuIGV4Y2VwdGlvbiBkaWZmZXJlbnQgZnJvbSB0aGUgb25lIHdlIGFza2VkIHRvXG4gICAgLy8gcmVwb3J0IG9uLlxuICAgIHRyeSB7XG4gICAgICB2YXIgc3RhY2sgPSBUcmFjZUtpdC5jb21wdXRlU3RhY2tUcmFjZShleCk7XG4gICAgICB0aGlzLl9oYW5kbGVTdGFja0luZm8oc3RhY2ssIG9wdGlvbnMpO1xuICAgIH0gY2F0Y2ggKGV4MSkge1xuICAgICAgaWYgKGV4ICE9PSBleDEpIHtcbiAgICAgICAgdGhyb3cgZXgxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIF9nZXRDYXB0dXJlRXhjZXB0aW9uT3B0aW9uc0Zyb21QbGFpbk9iamVjdDogZnVuY3Rpb24oY3VycmVudE9wdGlvbnMsIGV4KSB7XG4gICAgdmFyIGV4S2V5cyA9IE9iamVjdC5rZXlzKGV4KS5zb3J0KCk7XG4gICAgdmFyIG9wdGlvbnMgPSBvYmplY3RNZXJnZShjdXJyZW50T3B0aW9ucywge1xuICAgICAgbWVzc2FnZTpcbiAgICAgICAgJ05vbi1FcnJvciBleGNlcHRpb24gY2FwdHVyZWQgd2l0aCBrZXlzOiAnICsgc2VyaWFsaXplS2V5c0Zvck1lc3NhZ2UoZXhLZXlzKSxcbiAgICAgIGZpbmdlcnByaW50OiBbbWQ1KGV4S2V5cyldLFxuICAgICAgZXh0cmE6IGN1cnJlbnRPcHRpb25zLmV4dHJhIHx8IHt9XG4gICAgfSk7XG4gICAgb3B0aW9ucy5leHRyYS5fX3NlcmlhbGl6ZWRfXyA9IHNlcmlhbGl6ZUV4Y2VwdGlvbihleCk7XG5cbiAgICByZXR1cm4gb3B0aW9ucztcbiAgfSxcblxuICAvKlxuICAgICAqIE1hbnVhbGx5IHNlbmQgYSBtZXNzYWdlIHRvIFNlbnRyeVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1zZyBBIHBsYWluIG1lc3NhZ2UgdG8gYmUgY2FwdHVyZWQgaW4gU2VudHJ5XG4gICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQSBzcGVjaWZpYyBzZXQgb2Ygb3B0aW9ucyBmb3IgdGhpcyBtZXNzYWdlIFtvcHRpb25hbF1cbiAgICAgKiBAcmV0dXJuIHtSYXZlbn1cbiAgICAgKi9cbiAgY2FwdHVyZU1lc3NhZ2U6IGZ1bmN0aW9uKG1zZywgb3B0aW9ucykge1xuICAgIC8vIGNvbmZpZygpIGF1dG9tYWdpY2FsbHkgY29udmVydHMgaWdub3JlRXJyb3JzIGZyb20gYSBsaXN0IHRvIGEgUmVnRXhwIHNvIHdlIG5lZWQgdG8gdGVzdCBmb3IgYW5cbiAgICAvLyBlYXJseSBjYWxsOyB3ZSdsbCBlcnJvciBvbiB0aGUgc2lkZSBvZiBsb2dnaW5nIGFueXRoaW5nIGNhbGxlZCBiZWZvcmUgY29uZmlndXJhdGlvbiBzaW5jZSBpdCdzXG4gICAgLy8gcHJvYmFibHkgc29tZXRoaW5nIHlvdSBzaG91bGQgc2VlOlxuICAgIGlmIChcbiAgICAgICEhdGhpcy5fZ2xvYmFsT3B0aW9ucy5pZ25vcmVFcnJvcnMudGVzdCAmJlxuICAgICAgdGhpcy5fZ2xvYmFsT3B0aW9ucy5pZ25vcmVFcnJvcnMudGVzdChtc2cpXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgbXNnID0gbXNnICsgJyc7IC8vIE1ha2Ugc3VyZSBpdCdzIGFjdHVhbGx5IGEgc3RyaW5nXG5cbiAgICB2YXIgZGF0YSA9IG9iamVjdE1lcmdlKFxuICAgICAge1xuICAgICAgICBtZXNzYWdlOiBtc2dcbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcblxuICAgIHZhciBleDtcbiAgICAvLyBHZW5lcmF0ZSBhIFwic3ludGhldGljXCIgc3RhY2sgdHJhY2UgZnJvbSB0aGlzIHBvaW50LlxuICAgIC8vIE5PVEU6IElmIHlvdSBhcmUgYSBTZW50cnkgdXNlciwgYW5kIHlvdSBhcmUgc2VlaW5nIHRoaXMgc3RhY2sgZnJhbWUsIGl0IGlzIE5PVCBpbmRpY2F0aXZlXG4gICAgLy8gICAgICAgb2YgYSBidWcgd2l0aCBSYXZlbi5qcy4gU2VudHJ5IGdlbmVyYXRlcyBzeW50aGV0aWMgdHJhY2VzIGVpdGhlciBieSBjb25maWd1cmF0aW9uLFxuICAgIC8vICAgICAgIG9yIGlmIGl0IGNhdGNoZXMgYSB0aHJvd24gb2JqZWN0IHdpdGhvdXQgYSBcInN0YWNrXCIgcHJvcGVydHkuXG4gICAgdHJ5IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH0gY2F0Y2ggKGV4MSkge1xuICAgICAgZXggPSBleDE7XG4gICAgfVxuXG4gICAgLy8gbnVsbCBleGNlcHRpb24gbmFtZSBzbyBgRXJyb3JgIGlzbid0IHByZWZpeGVkIHRvIG1zZ1xuICAgIGV4Lm5hbWUgPSBudWxsO1xuICAgIHZhciBzdGFjayA9IFRyYWNlS2l0LmNvbXB1dGVTdGFja1RyYWNlKGV4KTtcblxuICAgIC8vIHN0YWNrWzBdIGlzIGB0aHJvdyBuZXcgRXJyb3IobXNnKWAgY2FsbCBpdHNlbGYsIHdlIGFyZSBpbnRlcmVzdGVkIGluIHRoZSBmcmFtZSB0aGF0IHdhcyBqdXN0IGJlZm9yZSB0aGF0LCBzdGFja1sxXVxuICAgIHZhciBpbml0aWFsQ2FsbCA9IGlzQXJyYXkoc3RhY2suc3RhY2spICYmIHN0YWNrLnN0YWNrWzFdO1xuXG4gICAgLy8gaWYgc3RhY2tbMV0gaXMgYFJhdmVuLmNhcHR1cmVFeGNlcHRpb25gLCBpdCBtZWFucyB0aGF0IHNvbWVvbmUgcGFzc2VkIGEgc3RyaW5nIHRvIGl0IGFuZCB3ZSByZWRpcmVjdGVkIHRoYXQgY2FsbFxuICAgIC8vIHRvIGJlIGhhbmRsZWQgYnkgYGNhcHR1cmVNZXNzYWdlYCwgdGh1cyBgaW5pdGlhbENhbGxgIGlzIHRoZSAzcmQgb25lLCBub3QgMm5kXG4gICAgLy8gaW5pdGlhbENhbGwgPT4gY2FwdHVyZUV4Y2VwdGlvbihzdHJpbmcpID0+IGNhcHR1cmVNZXNzYWdlKHN0cmluZylcbiAgICBpZiAoaW5pdGlhbENhbGwgJiYgaW5pdGlhbENhbGwuZnVuYyA9PT0gJ1JhdmVuLmNhcHR1cmVFeGNlcHRpb24nKSB7XG4gICAgICBpbml0aWFsQ2FsbCA9IHN0YWNrLnN0YWNrWzJdO1xuICAgIH1cblxuICAgIHZhciBmaWxldXJsID0gKGluaXRpYWxDYWxsICYmIGluaXRpYWxDYWxsLnVybCkgfHwgJyc7XG5cbiAgICBpZiAoXG4gICAgICAhIXRoaXMuX2dsb2JhbE9wdGlvbnMuaWdub3JlVXJscy50ZXN0ICYmXG4gICAgICB0aGlzLl9nbG9iYWxPcHRpb25zLmlnbm9yZVVybHMudGVzdChmaWxldXJsKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgICEhdGhpcy5fZ2xvYmFsT3B0aW9ucy53aGl0ZWxpc3RVcmxzLnRlc3QgJiZcbiAgICAgICF0aGlzLl9nbG9iYWxPcHRpb25zLndoaXRlbGlzdFVybHMudGVzdChmaWxldXJsKVxuICAgICkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBhdHRlbXB0IHRvIGdldCBzdGFja3RyYWNlIGlmIG1lc3NhZ2UgaXMgZW1wdHkuXG4gICAgLy8gSXQncyB0aGUgb25seSB3YXkgdG8gcHJvdmlkZSBhbnkgaGVscGZ1bCBpbmZvcm1hdGlvbiB0byB0aGUgdXNlci5cbiAgICBpZiAodGhpcy5fZ2xvYmFsT3B0aW9ucy5zdGFja3RyYWNlIHx8IG9wdGlvbnMuc3RhY2t0cmFjZSB8fCBkYXRhLm1lc3NhZ2UgPT09ICcnKSB7XG4gICAgICAvLyBmaW5nZXJwcmludCBvbiBtc2csIG5vdCBzdGFjayB0cmFjZSAobGVnYWN5IGJlaGF2aW9yLCBjb3VsZCBiZSByZXZpc2l0ZWQpXG4gICAgICBkYXRhLmZpbmdlcnByaW50ID0gZGF0YS5maW5nZXJwcmludCA9PSBudWxsID8gbXNnIDogZGF0YS5maW5nZXJwcmludDtcblxuICAgICAgb3B0aW9ucyA9IG9iamVjdE1lcmdlKFxuICAgICAgICB7XG4gICAgICAgICAgdHJpbUhlYWRGcmFtZXM6IDBcbiAgICAgICAgfSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIC8vIFNpbmNlIHdlIGtub3cgdGhpcyBpcyBhIHN5bnRoZXRpYyB0cmFjZSwgdGhlIHRvcCBmcmFtZSAodGhpcyBmdW5jdGlvbiBjYWxsKVxuICAgICAgLy8gTVVTVCBiZSBmcm9tIFJhdmVuLmpzLCBzbyBtYXJrIGl0IGZvciB0cmltbWluZ1xuICAgICAgLy8gV2UgYWRkIHRvIHRoZSB0cmltIGNvdW50ZXIgc28gdGhhdCBjYWxsZXJzIGNhbiBjaG9vc2UgdG8gdHJpbSBleHRyYSBmcmFtZXMsIHN1Y2hcbiAgICAgIC8vIGFzIHV0aWxpdHkgZnVuY3Rpb25zLlxuICAgICAgb3B0aW9ucy50cmltSGVhZEZyYW1lcyArPSAxO1xuXG4gICAgICB2YXIgZnJhbWVzID0gdGhpcy5fcHJlcGFyZUZyYW1lcyhzdGFjaywgb3B0aW9ucyk7XG4gICAgICBkYXRhLnN0YWNrdHJhY2UgPSB7XG4gICAgICAgIC8vIFNlbnRyeSBleHBlY3RzIGZyYW1lcyBvbGRlc3QgdG8gbmV3ZXN0XG4gICAgICAgIGZyYW1lczogZnJhbWVzLnJldmVyc2UoKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBNYWtlIHN1cmUgdGhhdCBmaW5nZXJwcmludCBpcyBhbHdheXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIGlmIChkYXRhLmZpbmdlcnByaW50KSB7XG4gICAgICBkYXRhLmZpbmdlcnByaW50ID0gaXNBcnJheShkYXRhLmZpbmdlcnByaW50KVxuICAgICAgICA/IGRhdGEuZmluZ2VycHJpbnRcbiAgICAgICAgOiBbZGF0YS5maW5nZXJwcmludF07XG4gICAgfVxuXG4gICAgLy8gRmlyZSBhd2F5IVxuICAgIHRoaXMuX3NlbmQoZGF0YSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBjYXB0dXJlQnJlYWRjcnVtYjogZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGNydW1iID0gb2JqZWN0TWVyZ2UoXG4gICAgICB7XG4gICAgICAgIHRpbWVzdGFtcDogbm93KCkgLyAxMDAwXG4gICAgICB9LFxuICAgICAgb2JqXG4gICAgKTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2dsb2JhbE9wdGlvbnMuYnJlYWRjcnVtYkNhbGxiYWNrKSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuX2dsb2JhbE9wdGlvbnMuYnJlYWRjcnVtYkNhbGxiYWNrKGNydW1iKTtcblxuICAgICAgaWYgKGlzT2JqZWN0KHJlc3VsdCkgJiYgIWlzRW1wdHlPYmplY3QocmVzdWx0KSkge1xuICAgICAgICBjcnVtYiA9IHJlc3VsdDtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9icmVhZGNydW1icy5wdXNoKGNydW1iKTtcbiAgICBpZiAodGhpcy5fYnJlYWRjcnVtYnMubGVuZ3RoID4gdGhpcy5fZ2xvYmFsT3B0aW9ucy5tYXhCcmVhZGNydW1icykge1xuICAgICAgdGhpcy5fYnJlYWRjcnVtYnMuc2hpZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgYWRkUGx1Z2luOiBmdW5jdGlvbihwbHVnaW4gLyphcmcxLCBhcmcyLCAuLi4gYXJnTiovKSB7XG4gICAgdmFyIHBsdWdpbkFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cbiAgICB0aGlzLl9wbHVnaW5zLnB1c2goW3BsdWdpbiwgcGx1Z2luQXJnc10pO1xuICAgIGlmICh0aGlzLl9pc1JhdmVuSW5zdGFsbGVkKSB7XG4gICAgICB0aGlzLl9kcmFpblBsdWdpbnMoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKlxuICAgICAqIFNldC9jbGVhciBhIHVzZXIgdG8gYmUgc2VudCBhbG9uZyB3aXRoIHRoZSBwYXlsb2FkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHVzZXIgQW4gb2JqZWN0IHJlcHJlc2VudGluZyB1c2VyIGRhdGEgW29wdGlvbmFsXVxuICAgICAqIEByZXR1cm4ge1JhdmVufVxuICAgICAqL1xuICBzZXRVc2VyQ29udGV4dDogZnVuY3Rpb24odXNlcikge1xuICAgIC8vIEludGVudGlvbmFsbHkgZG8gbm90IG1lcmdlIGhlcmUgc2luY2UgdGhhdCdzIGFuIHVuZXhwZWN0ZWQgYmVoYXZpb3IuXG4gICAgdGhpcy5fZ2xvYmFsQ29udGV4dC51c2VyID0gdXNlcjtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qXG4gICAgICogTWVyZ2UgZXh0cmEgYXR0cmlidXRlcyB0byBiZSBzZW50IGFsb25nIHdpdGggdGhlIHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gZXh0cmEgQW4gb2JqZWN0IHJlcHJlc2VudGluZyBleHRyYSBkYXRhIFtvcHRpb25hbF1cbiAgICAgKiBAcmV0dXJuIHtSYXZlbn1cbiAgICAgKi9cbiAgc2V0RXh0cmFDb250ZXh0OiBmdW5jdGlvbihleHRyYSkge1xuICAgIHRoaXMuX21lcmdlQ29udGV4dCgnZXh0cmEnLCBleHRyYSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKlxuICAgICAqIE1lcmdlIHRhZ3MgdG8gYmUgc2VudCBhbG9uZyB3aXRoIHRoZSBwYXlsb2FkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHRhZ3MgQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0YWdzIFtvcHRpb25hbF1cbiAgICAgKiBAcmV0dXJuIHtSYXZlbn1cbiAgICAgKi9cbiAgc2V0VGFnc0NvbnRleHQ6IGZ1bmN0aW9uKHRhZ3MpIHtcbiAgICB0aGlzLl9tZXJnZUNvbnRleHQoJ3RhZ3MnLCB0YWdzKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qXG4gICAgICogQ2xlYXIgYWxsIG9mIHRoZSBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7UmF2ZW59XG4gICAgICovXG4gIGNsZWFyQ29udGV4dDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZ2xvYmFsQ29udGV4dCA9IHt9O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLypcbiAgICAgKiBHZXQgYSBjb3B5IG9mIHRoZSBjdXJyZW50IGNvbnRleHQuIFRoaXMgY2Fubm90IGJlIG11dGF0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IGNvcHkgb2YgY29udGV4dFxuICAgICAqL1xuICBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHtcbiAgICAvLyBsb2wgamF2YXNjcmlwdFxuICAgIHJldHVybiBKU09OLnBhcnNlKHN0cmluZ2lmeSh0aGlzLl9nbG9iYWxDb250ZXh0KSk7XG4gIH0sXG5cbiAgLypcbiAgICAgKiBTZXQgZW52aXJvbm1lbnQgb2YgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbnZpcm9ubWVudCBUeXBpY2FsbHkgc29tZXRoaW5nIGxpa2UgJ3Byb2R1Y3Rpb24nLlxuICAgICAqIEByZXR1cm4ge1JhdmVufVxuICAgICAqL1xuICBzZXRFbnZpcm9ubWVudDogZnVuY3Rpb24oZW52aXJvbm1lbnQpIHtcbiAgICB0aGlzLl9nbG9iYWxPcHRpb25zLmVudmlyb25tZW50ID0gZW52aXJvbm1lbnQ7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKlxuICAgICAqIFNldCByZWxlYXNlIHZlcnNpb24gb2YgYXBwbGljYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByZWxlYXNlIFR5cGljYWxseSBzb21ldGhpbmcgbGlrZSBhIGdpdCBTSEEgdG8gaWRlbnRpZnkgdmVyc2lvblxuICAgICAqIEByZXR1cm4ge1JhdmVufVxuICAgICAqL1xuICBzZXRSZWxlYXNlOiBmdW5jdGlvbihyZWxlYXNlKSB7XG4gICAgdGhpcy5fZ2xvYmFsT3B0aW9ucy5yZWxlYXNlID0gcmVsZWFzZTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qXG4gICAgICogU2V0IHRoZSBkYXRhQ2FsbGJhY2sgb3B0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gcnVuIHdoaWNoIGFsbG93cyB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhIGJsb2IgdG8gYmUgbXV0YXRlZCBiZWZvcmUgc2VuZGluZ1xuICAgICAqIEByZXR1cm4ge1JhdmVufVxuICAgICAqL1xuICBzZXREYXRhQ2FsbGJhY2s6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fZ2xvYmFsT3B0aW9ucy5kYXRhQ2FsbGJhY2s7XG4gICAgdGhpcy5fZ2xvYmFsT3B0aW9ucy5kYXRhQ2FsbGJhY2sgPSBrZWVwT3JpZ2luYWxDYWxsYmFjayhvcmlnaW5hbCwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qXG4gICAgICogU2V0IHRoZSBicmVhZGNydW1iQ2FsbGJhY2sgb3B0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gcnVuIHdoaWNoIGFsbG93cyBmaWx0ZXJpbmdcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvciBtdXRhdGluZyBicmVhZGNydW1ic1xuICAgICAqIEByZXR1cm4ge1JhdmVufVxuICAgICAqL1xuICBzZXRCcmVhZGNydW1iQ2FsbGJhY2s6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIG9yaWdpbmFsID0gdGhpcy5fZ2xvYmFsT3B0aW9ucy5icmVhZGNydW1iQ2FsbGJhY2s7XG4gICAgdGhpcy5fZ2xvYmFsT3B0aW9ucy5icmVhZGNydW1iQ2FsbGJhY2sgPSBrZWVwT3JpZ2luYWxDYWxsYmFjayhvcmlnaW5hbCwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuXG4gIC8qXG4gICAgICogU2V0IHRoZSBzaG91bGRTZW5kQ2FsbGJhY2sgb3B0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgdG8gcnVuIHdoaWNoIGFsbG93c1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludHJvc3BlY3RpbmcgdGhlIGJsb2IgYmVmb3JlIHNlbmRpbmdcbiAgICAgKiBAcmV0dXJuIHtSYXZlbn1cbiAgICAgKi9cbiAgc2V0U2hvdWxkU2VuZENhbGxiYWNrOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX2dsb2JhbE9wdGlvbnMuc2hvdWxkU2VuZENhbGxiYWNrO1xuICAgIHRoaXMuX2dsb2JhbE9wdGlvbnMuc2hvdWxkU2VuZENhbGxiYWNrID0ga2VlcE9yaWdpbmFsQ2FsbGJhY2sob3JpZ2luYWwsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogT3ZlcnJpZGUgdGhlIGRlZmF1bHQgSFRUUCB0cmFuc3BvcnQgbWVjaGFuaXNtIHRoYXQgdHJhbnNtaXRzIGRhdGFcbiAgICogdG8gdGhlIFNlbnRyeSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IHRyYW5zcG9ydCBGdW5jdGlvbiBpbnZva2VkIGluc3RlYWQgb2YgdGhlIGRlZmF1bHRcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBtYWtlUmVxdWVzdGAgaGFuZGxlci5cbiAgICpcbiAgICogQHJldHVybiB7UmF2ZW59XG4gICAqL1xuICBzZXRUcmFuc3BvcnQ6IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuICAgIHRoaXMuX2dsb2JhbE9wdGlvbnMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgLypcbiAgICAgKiBHZXQgdGhlIGxhdGVzdCByYXcgZXhjZXB0aW9uIHRoYXQgd2FzIGNhcHR1cmVkIGJ5IFJhdmVuLlxuICAgICAqXG4gICAgICogQHJldHVybiB7ZXJyb3J9XG4gICAgICovXG4gIGxhc3RFeGNlcHRpb246IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9sYXN0Q2FwdHVyZWRFeGNlcHRpb247XG4gIH0sXG5cbiAgLypcbiAgICAgKiBHZXQgdGhlIGxhc3QgZXZlbnQgaWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgbGFzdEV2ZW50SWQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9sYXN0RXZlbnRJZDtcbiAgfSxcblxuICAvKlxuICAgICAqIERldGVybWluZSBpZiBSYXZlbiBpcyBzZXR1cCBhbmQgcmVhZHkgdG8gZ28uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICBpc1NldHVwOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2hhc0pTT04pIHJldHVybiBmYWxzZTsgLy8gbmVlZHMgSlNPTiBzdXBwb3J0XG4gICAgaWYgKCF0aGlzLl9nbG9iYWxTZXJ2ZXIpIHtcbiAgICAgIGlmICghdGhpcy5yYXZlbk5vdENvbmZpZ3VyZWRFcnJvcikge1xuICAgICAgICB0aGlzLnJhdmVuTm90Q29uZmlndXJlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbG9nRGVidWcoJ2Vycm9yJywgJ0Vycm9yOiBSYXZlbiBoYXMgbm90IGJlZW4gY29uZmlndXJlZC4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgYWZ0ZXJMb2FkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBUT0RPOiByZW1vdmUgd2luZG93IGRlcGVuZGVuY2U/XG5cbiAgICAvLyBBdHRlbXB0IHRvIGluaXRpYWxpemUgUmF2ZW4gb24gbG9hZFxuICAgIHZhciBSYXZlbkNvbmZpZyA9IF93aW5kb3cuUmF2ZW5Db25maWc7XG4gICAgaWYgKFJhdmVuQ29uZmlnKSB7XG4gICAgICB0aGlzLmNvbmZpZyhSYXZlbkNvbmZpZy5kc24sIFJhdmVuQ29uZmlnLmNvbmZpZykuaW5zdGFsbCgpO1xuICAgIH1cbiAgfSxcblxuICBzaG93UmVwb3J0RGlhbG9nOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgaWYgKFxuICAgICAgIV9kb2N1bWVudCAvLyBkb2Vzbid0IHdvcmsgd2l0aG91dCBhIGRvY3VtZW50IChSZWFjdCBuYXRpdmUpXG4gICAgKVxuICAgICAgcmV0dXJuO1xuXG4gICAgb3B0aW9ucyA9IG9iamVjdE1lcmdlKFxuICAgICAge1xuICAgICAgICBldmVudElkOiB0aGlzLmxhc3RFdmVudElkKCksXG4gICAgICAgIGRzbjogdGhpcy5fZHNuLFxuICAgICAgICB1c2VyOiB0aGlzLl9nbG9iYWxDb250ZXh0LnVzZXIgfHwge31cbiAgICAgIH0sXG4gICAgICBvcHRpb25zXG4gICAgKTtcblxuICAgIGlmICghb3B0aW9ucy5ldmVudElkKSB7XG4gICAgICB0aHJvdyBuZXcgUmF2ZW5Db25maWdFcnJvcignTWlzc2luZyBldmVudElkJyk7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLmRzbikge1xuICAgICAgdGhyb3cgbmV3IFJhdmVuQ29uZmlnRXJyb3IoJ01pc3NpbmcgRFNOJyk7XG4gICAgfVxuXG4gICAgdmFyIGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcbiAgICB2YXIgZW5jb2RlZE9wdGlvbnMgPSBbXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoa2V5ID09PSAndXNlcicpIHtcbiAgICAgICAgdmFyIHVzZXIgPSBvcHRpb25zLnVzZXI7XG4gICAgICAgIGlmICh1c2VyLm5hbWUpIGVuY29kZWRPcHRpb25zLnB1c2goJ25hbWU9JyArIGVuY29kZSh1c2VyLm5hbWUpKTtcbiAgICAgICAgaWYgKHVzZXIuZW1haWwpIGVuY29kZWRPcHRpb25zLnB1c2goJ2VtYWlsPScgKyBlbmNvZGUodXNlci5lbWFpbCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZW5jb2RlZE9wdGlvbnMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZShvcHRpb25zW2tleV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGdsb2JhbFNlcnZlciA9IHRoaXMuX2dldEdsb2JhbFNlcnZlcih0aGlzLl9wYXJzZURTTihvcHRpb25zLmRzbikpO1xuXG4gICAgdmFyIHNjcmlwdCA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgIHNjcmlwdC5zcmMgPSBnbG9iYWxTZXJ2ZXIgKyAnL2FwaS9lbWJlZC9lcnJvci1wYWdlLz8nICsgZW5jb2RlZE9wdGlvbnMuam9pbignJicpO1xuICAgIChfZG9jdW1lbnQuaGVhZCB8fCBfZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgfSxcblxuICAvKioqKiBQcml2YXRlIGZ1bmN0aW9ucyAqKioqL1xuICBfaWdub3JlTmV4dE9uRXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9pZ25vcmVPbkVycm9yICs9IDE7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIHRyaWdnZXIgYmVmb3JlIHNldFRpbWVvdXRcbiAgICAgIHNlbGYuX2lnbm9yZU9uRXJyb3IgLT0gMTtcbiAgICB9KTtcbiAgfSxcblxuICBfdHJpZ2dlckV2ZW50OiBmdW5jdGlvbihldmVudFR5cGUsIG9wdGlvbnMpIHtcbiAgICAvLyBOT1RFOiBgZXZlbnRgIGlzIGEgbmF0aXZlIGJyb3dzZXIgdGhpbmcsIHNvIGxldCdzIGF2b2lkIGNvbmZsaWN0aW5nIHdpaHQgaXRcbiAgICB2YXIgZXZ0LCBrZXk7XG5cbiAgICBpZiAoIXRoaXMuX2hhc0RvY3VtZW50KSByZXR1cm47XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGV2ZW50VHlwZSA9ICdyYXZlbicgKyBldmVudFR5cGUuc3Vic3RyKDAsIDEpLnRvVXBwZXJDYXNlKCkgKyBldmVudFR5cGUuc3Vic3RyKDEpO1xuXG4gICAgaWYgKF9kb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgZXZ0ID0gX2RvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG4gICAgICBldnQuaW5pdEV2ZW50KGV2ZW50VHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2dCA9IF9kb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xuICAgICAgZXZ0LmV2ZW50VHlwZSA9IGV2ZW50VHlwZTtcbiAgICB9XG5cbiAgICBmb3IgKGtleSBpbiBvcHRpb25zKVxuICAgICAgaWYgKGhhc0tleShvcHRpb25zLCBrZXkpKSB7XG4gICAgICAgIGV2dFtrZXldID0gb3B0aW9uc1trZXldO1xuICAgICAgfVxuXG4gICAgaWYgKF9kb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgLy8gSUU5IGlmIHN0YW5kYXJkc1xuICAgICAgX2RvY3VtZW50LmRpc3BhdGNoRXZlbnQoZXZ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSUU4IHJlZ2FyZGxlc3Mgb2YgUXVpcmtzIG9yIFN0YW5kYXJkc1xuICAgICAgLy8gSUU5IGlmIHF1aXJrc1xuICAgICAgdHJ5IHtcbiAgICAgICAgX2RvY3VtZW50LmZpcmVFdmVudCgnb24nICsgZXZ0LmV2ZW50VHlwZS50b0xvd2VyQ2FzZSgpLCBldnQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBEbyBub3RoaW5nXG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBXcmFwcyBhZGRFdmVudExpc3RlbmVyIHRvIGNhcHR1cmUgVUkgYnJlYWRjcnVtYnNcbiAgICogQHBhcmFtIGV2dE5hbWUgdGhlIGV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKVxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYnJlYWRjcnVtYkV2ZW50SGFuZGxlcjogZnVuY3Rpb24oZXZ0TmFtZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICByZXR1cm4gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAvLyByZXNldCBrZXlwcmVzcyB0aW1lb3V0OyBlLmcuIHRyaWdnZXJpbmcgYSAnY2xpY2snIGFmdGVyXG4gICAgICAvLyBhICdrZXlwcmVzcycgd2lsbCByZXNldCB0aGUga2V5cHJlc3MgZGVib3VuY2Ugc28gdGhhdCBhIG5ld1xuICAgICAgLy8gc2V0IG9mIGtleXByZXNzZXMgY2FuIGJlIHJlY29yZGVkXG4gICAgICBzZWxmLl9rZXlwcmVzc1RpbWVvdXQgPSBudWxsO1xuXG4gICAgICAvLyBJdCdzIHBvc3NpYmxlIHRoaXMgaGFuZGxlciBtaWdodCB0cmlnZ2VyIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc2FtZVxuICAgICAgLy8gZXZlbnQgKGUuZy4gZXZlbnQgcHJvcGFnYXRpb24gdGhyb3VnaCBub2RlIGFuY2VzdG9ycykuIElnbm9yZSBpZiB3ZSd2ZVxuICAgICAgLy8gYWxyZWFkeSBjYXB0dXJlZCB0aGUgZXZlbnQuXG4gICAgICBpZiAoc2VsZi5fbGFzdENhcHR1cmVkRXZlbnQgPT09IGV2dCkgcmV0dXJuO1xuXG4gICAgICBzZWxmLl9sYXN0Q2FwdHVyZWRFdmVudCA9IGV2dDtcblxuICAgICAgLy8gdHJ5L2NhdGNoIGJvdGg6XG4gICAgICAvLyAtIGFjY2Vzc2luZyBldnQudGFyZ2V0IChzZWUgZ2V0c2VudHJ5L3JhdmVuLWpzIzgzOCwgIzc2OClcbiAgICAgIC8vIC0gYGh0bWxUcmVlQXNTdHJpbmdgIGJlY2F1c2UgaXQncyBjb21wbGV4LCBhbmQganVzdCBhY2Nlc3NpbmcgdGhlIERPTSBpbmNvcnJlY3RseVxuICAgICAgLy8gICBjYW4gdGhyb3cgYW4gZXhjZXB0aW9uIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy5cbiAgICAgIHZhciB0YXJnZXQ7XG4gICAgICB0cnkge1xuICAgICAgICB0YXJnZXQgPSBodG1sVHJlZUFzU3RyaW5nKGV2dC50YXJnZXQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0YXJnZXQgPSAnPHVua25vd24+JztcbiAgICAgIH1cblxuICAgICAgc2VsZi5jYXB0dXJlQnJlYWRjcnVtYih7XG4gICAgICAgIGNhdGVnb3J5OiAndWkuJyArIGV2dE5hbWUsIC8vIGUuZy4gdWkuY2xpY2ssIHVpLmlucHV0XG4gICAgICAgIG1lc3NhZ2U6IHRhcmdldFxuICAgICAgfSk7XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogV3JhcHMgYWRkRXZlbnRMaXN0ZW5lciB0byBjYXB0dXJlIGtleXByZXNzIFVJIGV2ZW50c1xuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfa2V5cHJlc3NFdmVudEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGRlYm91bmNlRHVyYXRpb24gPSAxMDAwOyAvLyBtaWxsaXNlY29uZHNcblxuICAgIC8vIFRPRE86IGlmIHNvbWVob3cgdXNlciBzd2l0Y2hlcyBrZXlwcmVzcyB0YXJnZXQgYmVmb3JlXG4gICAgLy8gICAgICAgZGVib3VuY2UgdGltZW91dCBpcyB0cmlnZ2VyZWQsIHdlIHdpbGwgb25seSBjYXB0dXJlXG4gICAgLy8gICAgICAgYSBzaW5nbGUgYnJlYWRjcnVtYiBmcm9tIHRoZSBGSVJTVCB0YXJnZXQgKGFjY2VwdGFibGU/KVxuICAgIHJldHVybiBmdW5jdGlvbihldnQpIHtcbiAgICAgIHZhciB0YXJnZXQ7XG4gICAgICB0cnkge1xuICAgICAgICB0YXJnZXQgPSBldnQudGFyZ2V0O1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBqdXN0IGFjY2Vzc2luZyBldmVudCBwcm9wZXJ0aWVzIGNhbiB0aHJvdyBhbiBleGNlcHRpb24gaW4gc29tZSByYXJlIGNpcmN1bXN0YW5jZXNcbiAgICAgICAgLy8gc2VlOiBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3JhdmVuLWpzL2lzc3Vlcy84MzhcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHRhZ05hbWUgPSB0YXJnZXQgJiYgdGFyZ2V0LnRhZ05hbWU7XG5cbiAgICAgIC8vIG9ubHkgY29uc2lkZXIga2V5cHJlc3MgZXZlbnRzIG9uIGFjdHVhbCBpbnB1dCBlbGVtZW50c1xuICAgICAgLy8gdGhpcyB3aWxsIGRpc3JlZ2FyZCBrZXlwcmVzc2VzIHRhcmdldGluZyBib2R5IChlLmcuIHRhYmJpbmdcbiAgICAgIC8vIHRocm91Z2ggZWxlbWVudHMsIGhvdGtleXMsIGV0YylcbiAgICAgIGlmIChcbiAgICAgICAgIXRhZ05hbWUgfHxcbiAgICAgICAgKHRhZ05hbWUgIT09ICdJTlBVVCcgJiYgdGFnTmFtZSAhPT0gJ1RFWFRBUkVBJyAmJiAhdGFyZ2V0LmlzQ29udGVudEVkaXRhYmxlKVxuICAgICAgKVxuICAgICAgICByZXR1cm47XG5cbiAgICAgIC8vIHJlY29yZCBmaXJzdCBrZXlwcmVzcyBpbiBhIHNlcmllcywgYnV0IGlnbm9yZSBzdWJzZXF1ZW50XG4gICAgICAvLyBrZXlwcmVzc2VzIHVudGlsIGRlYm91bmNlIGNsZWFyc1xuICAgICAgdmFyIHRpbWVvdXQgPSBzZWxmLl9rZXlwcmVzc1RpbWVvdXQ7XG4gICAgICBpZiAoIXRpbWVvdXQpIHtcbiAgICAgICAgc2VsZi5fYnJlYWRjcnVtYkV2ZW50SGFuZGxlcignaW5wdXQnKShldnQpO1xuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgc2VsZi5fa2V5cHJlc3NUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5fa2V5cHJlc3NUaW1lb3V0ID0gbnVsbDtcbiAgICAgIH0sIGRlYm91bmNlRHVyYXRpb24pO1xuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhcHR1cmVzIGEgYnJlYWRjcnVtYiBvZiB0eXBlIFwibmF2aWdhdGlvblwiLCBub3JtYWxpemluZyBpbnB1dCBVUkxzXG4gICAqIEBwYXJhbSB0byB0aGUgb3JpZ2luYXRpbmcgVVJMXG4gICAqIEBwYXJhbSBmcm9tIHRoZSB0YXJnZXQgVVJMXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2FwdHVyZVVybENoYW5nZTogZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICB2YXIgcGFyc2VkTG9jID0gcGFyc2VVcmwodGhpcy5fbG9jYXRpb24uaHJlZik7XG4gICAgdmFyIHBhcnNlZFRvID0gcGFyc2VVcmwodG8pO1xuICAgIHZhciBwYXJzZWRGcm9tID0gcGFyc2VVcmwoZnJvbSk7XG5cbiAgICAvLyBiZWNhdXNlIG9ucG9wc3RhdGUgb25seSB0ZWxscyB5b3UgdGhlIFwibmV3XCIgKHRvKSB2YWx1ZSBvZiBsb2NhdGlvbi5ocmVmLCBhbmRcbiAgICAvLyBub3QgdGhlIHByZXZpb3VzIChmcm9tKSB2YWx1ZSwgd2UgbmVlZCB0byB0cmFjayB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgVVJMXG4gICAgLy8gc3RhdGUgb3Vyc2VsdmVzXG4gICAgdGhpcy5fbGFzdEhyZWYgPSB0bztcblxuICAgIC8vIFVzZSBvbmx5IHRoZSBwYXRoIGNvbXBvbmVudCBvZiB0aGUgVVJMIGlmIHRoZSBVUkwgbWF0Y2hlcyB0aGUgY3VycmVudFxuICAgIC8vIGRvY3VtZW50IChhbG1vc3QgYWxsIHRoZSB0aW1lIHdoZW4gdXNpbmcgcHVzaFN0YXRlKVxuICAgIGlmIChwYXJzZWRMb2MucHJvdG9jb2wgPT09IHBhcnNlZFRvLnByb3RvY29sICYmIHBhcnNlZExvYy5ob3N0ID09PSBwYXJzZWRUby5ob3N0KVxuICAgICAgdG8gPSBwYXJzZWRUby5yZWxhdGl2ZTtcbiAgICBpZiAocGFyc2VkTG9jLnByb3RvY29sID09PSBwYXJzZWRGcm9tLnByb3RvY29sICYmIHBhcnNlZExvYy5ob3N0ID09PSBwYXJzZWRGcm9tLmhvc3QpXG4gICAgICBmcm9tID0gcGFyc2VkRnJvbS5yZWxhdGl2ZTtcblxuICAgIHRoaXMuY2FwdHVyZUJyZWFkY3J1bWIoe1xuICAgICAgY2F0ZWdvcnk6ICduYXZpZ2F0aW9uJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgdG86IHRvLFxuICAgICAgICBmcm9tOiBmcm9tXG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgX3BhdGNoRnVuY3Rpb25Ub1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHNlbGYuX29yaWdpbmFsRnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZXh0ZW5kLW5hdGl2ZVxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzID09PSAnZnVuY3Rpb24nICYmIHRoaXMuX19yYXZlbl9fKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9vcmlnaW5hbEZ1bmN0aW9uVG9TdHJpbmcuYXBwbHkodGhpcy5fX29yaWdfXywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxmLl9vcmlnaW5hbEZ1bmN0aW9uVG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9LFxuXG4gIF91bnBhdGNoRnVuY3Rpb25Ub1N0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX29yaWdpbmFsRnVuY3Rpb25Ub1N0cmluZykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWV4dGVuZC1uYXRpdmVcbiAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IHRoaXMuX29yaWdpbmFsRnVuY3Rpb25Ub1N0cmluZztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdyYXAgdGltZXIgZnVuY3Rpb25zIGFuZCBldmVudCB0YXJnZXRzIHRvIGNhdGNoIGVycm9ycyBhbmQgcHJvdmlkZVxuICAgKiBiZXR0ZXIgbWV0YWRhdGEuXG4gICAqL1xuICBfaW5zdHJ1bWVudFRyeUNhdGNoOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB2YXIgd3JhcHBlZEJ1aWx0SW5zID0gc2VsZi5fd3JhcHBlZEJ1aWx0SW5zO1xuXG4gICAgZnVuY3Rpb24gd3JhcFRpbWVGbihvcmlnKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oZm4sIHQpIHtcbiAgICAgICAgLy8gcHJlc2VydmUgYXJpdHlcbiAgICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50cyB0byBwcmV2ZW50IGRlb3B0aW1pemF0aW9uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvd2lraS9PcHRpbWl6YXRpb24ta2lsbGVycyMzMi1sZWFraW5nLWFyZ3VtZW50c1xuICAgICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgb3JpZ2luYWxDYWxsYmFjayA9IGFyZ3NbMF07XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKG9yaWdpbmFsQ2FsbGJhY2spKSB7XG4gICAgICAgICAgYXJnc1swXSA9IHNlbGYud3JhcChcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWVjaGFuaXNtOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2luc3RydW1lbnQnLFxuICAgICAgICAgICAgICAgIGRhdGE6IHtmdW5jdGlvbjogb3JpZy5uYW1lIHx8ICc8YW5vbnltb3VzPid9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcmlnaW5hbENhbGxiYWNrXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFIDwgOSBkb2Vzbid0IHN1cHBvcnQgLmNhbGwvLmFwcGx5IG9uIHNldEludGVydmFsL3NldFRpbWVvdXQsIGJ1dCBpdFxuICAgICAgICAvLyBhbHNvIHN1cHBvcnRzIG9ubHkgdHdvIGFyZ3VtZW50cyBhbmQgZG9lc24ndCBjYXJlIHdoYXQgdGhpcyBpcywgc28gd2VcbiAgICAgICAgLy8gY2FuIGp1c3QgY2FsbCB0aGUgb3JpZ2luYWwgZnVuY3Rpb24gZGlyZWN0bHkuXG4gICAgICAgIGlmIChvcmlnLmFwcGx5KSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWcuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG9yaWcoYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGF1dG9CcmVhZGNydW1icyA9IHRoaXMuX2dsb2JhbE9wdGlvbnMuYXV0b0JyZWFkY3J1bWJzO1xuXG4gICAgZnVuY3Rpb24gd3JhcEV2ZW50VGFyZ2V0KGdsb2JhbCkge1xuICAgICAgdmFyIHByb3RvID0gX3dpbmRvd1tnbG9iYWxdICYmIF93aW5kb3dbZ2xvYmFsXS5wcm90b3R5cGU7XG4gICAgICBpZiAocHJvdG8gJiYgcHJvdG8uaGFzT3duUHJvcGVydHkgJiYgcHJvdG8uaGFzT3duUHJvcGVydHkoJ2FkZEV2ZW50TGlzdGVuZXInKSkge1xuICAgICAgICBmaWxsKFxuICAgICAgICAgIHByb3RvLFxuICAgICAgICAgICdhZGRFdmVudExpc3RlbmVyJyxcbiAgICAgICAgICBmdW5jdGlvbihvcmlnKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXZ0TmFtZSwgZm4sIGNhcHR1cmUsIHNlY3VyZSkge1xuICAgICAgICAgICAgICAvLyBwcmVzZXJ2ZSBhcml0eVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChmbiAmJiBmbi5oYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgZm4uaGFuZGxlRXZlbnQgPSBzZWxmLndyYXAoXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBtZWNoYW5pc206IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdpbnN0cnVtZW50JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBnbG9iYWwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiAnaGFuZGxlRXZlbnQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyOiAoZm4gJiYgZm4ubmFtZSkgfHwgJzxhbm9ueW1vdXM+J1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZm4uaGFuZGxlRXZlbnRcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBjYW4gc29tZXRpbWVzIGdldCAnUGVybWlzc2lvbiBkZW5pZWQgdG8gYWNjZXNzIHByb3BlcnR5IFwiaGFuZGxlIEV2ZW50J1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gTW9yZSBicmVhZGNydW1iIERPTSBjYXB0dXJlIC4uLiBkb25lIGhlcmUgYW5kIG5vdCBpbiBgX2luc3RydW1lbnRCcmVhZGNydW1ic2BcbiAgICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBoYXZlIG1vcmUgdGhhbiBvbmUgd3JhcHBlciBmdW5jdGlvblxuICAgICAgICAgICAgICB2YXIgYmVmb3JlLCBjbGlja0hhbmRsZXIsIGtleXByZXNzSGFuZGxlcjtcblxuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgYXV0b0JyZWFkY3J1bWJzICYmXG4gICAgICAgICAgICAgICAgYXV0b0JyZWFkY3J1bWJzLmRvbSAmJlxuICAgICAgICAgICAgICAgIChnbG9iYWwgPT09ICdFdmVudFRhcmdldCcgfHwgZ2xvYmFsID09PSAnTm9kZScpXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIE5PVEU6IGdlbmVyYXRpbmcgbXVsdGlwbGUgaGFuZGxlcnMgcGVyIGFkZEV2ZW50TGlzdGVuZXIgaW52b2NhdGlvbiwgc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gICAgICAgcmV2aXNpdCBhbmQgdmVyaWZ5IHdlIGNhbiBqdXN0IHVzZSBvbmUgKGFsbW9zdCBjZXJ0YWlubHkpXG4gICAgICAgICAgICAgICAgY2xpY2tIYW5kbGVyID0gc2VsZi5fYnJlYWRjcnVtYkV2ZW50SGFuZGxlcignY2xpY2snKTtcbiAgICAgICAgICAgICAgICBrZXlwcmVzc0hhbmRsZXIgPSBzZWxmLl9rZXlwcmVzc0V2ZW50SGFuZGxlcigpO1xuICAgICAgICAgICAgICAgIGJlZm9yZSA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBpbnRlcmNlcHQgZXZlcnkgRE9NIGV2ZW50IGluIGBiZWZvcmVgIGFyZ3VtZW50LCBpbiBjYXNlIHRoYXRcbiAgICAgICAgICAgICAgICAgIC8vIHNhbWUgd3JhcHBlZCBtZXRob2QgaXMgcmUtdXNlZCBmb3IgZGlmZmVyZW50IGV2ZW50cyAoZS5nLiBtb3VzZW1vdmUgVEhFTiBjbGljaylcbiAgICAgICAgICAgICAgICAgIC8vIHNlZSAjNzI0XG4gICAgICAgICAgICAgICAgICBpZiAoIWV2dCkgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICB2YXIgZXZlbnRUeXBlO1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRUeXBlID0gZXZ0LnR5cGU7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgYWNjZXNzaW5nIGV2ZW50IHByb3BlcnRpZXMgY2FuIHRocm93IGFuIGV4Y2VwdGlvbiBpbiBzb21lIHJhcmUgY2lyY3Vtc3RhbmNlc1xuICAgICAgICAgICAgICAgICAgICAvLyBzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvcmF2ZW4tanMvaXNzdWVzLzgzOFxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoZXZlbnRUeXBlID09PSAnY2xpY2snKSByZXR1cm4gY2xpY2tIYW5kbGVyKGV2dCk7XG4gICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudFR5cGUgPT09ICdrZXlwcmVzcycpIHJldHVybiBrZXlwcmVzc0hhbmRsZXIoZXZ0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBvcmlnLmNhbGwoXG4gICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICBldnROYW1lLFxuICAgICAgICAgICAgICAgIHNlbGYud3JhcChcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbWVjaGFuaXNtOiB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2luc3RydW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogZ2xvYmFsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246ICdhZGRFdmVudExpc3RlbmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IChmbiAmJiBmbi5uYW1lKSB8fCAnPGFub255bW91cz4nXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgZm4sXG4gICAgICAgICAgICAgICAgICBiZWZvcmVcbiAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgIGNhcHR1cmUsXG4gICAgICAgICAgICAgICAgc2VjdXJlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH0sXG4gICAgICAgICAgd3JhcHBlZEJ1aWx0SW5zXG4gICAgICAgICk7XG4gICAgICAgIGZpbGwoXG4gICAgICAgICAgcHJvdG8sXG4gICAgICAgICAgJ3JlbW92ZUV2ZW50TGlzdGVuZXInLFxuICAgICAgICAgIGZ1bmN0aW9uKG9yaWcpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihldnQsIGZuLCBjYXB0dXJlLCBzZWN1cmUpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmbiA9IGZuICYmIChmbi5fX3JhdmVuX3dyYXBwZXJfXyA/IGZuLl9fcmF2ZW5fd3JhcHBlcl9fIDogZm4pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gaWdub3JlLCBhY2Nlc3NpbmcgX19yYXZlbl93cmFwcGVyX18gd2lsbCB0aHJvdyBpbiBzb21lIFNlbGVuaXVtIGVudmlyb25tZW50c1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBvcmlnLmNhbGwodGhpcywgZXZ0LCBmbiwgY2FwdHVyZSwgc2VjdXJlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSxcbiAgICAgICAgICB3cmFwcGVkQnVpbHRJbnNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWxsKF93aW5kb3csICdzZXRUaW1lb3V0Jywgd3JhcFRpbWVGbiwgd3JhcHBlZEJ1aWx0SW5zKTtcbiAgICBmaWxsKF93aW5kb3csICdzZXRJbnRlcnZhbCcsIHdyYXBUaW1lRm4sIHdyYXBwZWRCdWlsdElucyk7XG4gICAgaWYgKF93aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICBmaWxsKFxuICAgICAgICBfd2luZG93LFxuICAgICAgICAncmVxdWVzdEFuaW1hdGlvbkZyYW1lJyxcbiAgICAgICAgZnVuY3Rpb24ob3JpZykge1xuICAgICAgICAgIHJldHVybiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgcmV0dXJuIG9yaWcoXG4gICAgICAgICAgICAgIHNlbGYud3JhcChcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBtZWNoYW5pc206IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2luc3RydW1lbnQnLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246ICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnLFxuICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXI6IChvcmlnICYmIG9yaWcubmFtZSkgfHwgJzxhbm9ueW1vdXM+J1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjYlxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdyYXBwZWRCdWlsdEluc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBldmVudCB0YXJnZXRzIGJvcnJvd2VkIGZyb20gYnVnc25hZy1qczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYnVnc25hZy9idWdzbmFnLWpzL2Jsb2IvbWFzdGVyL3NyYy9idWdzbmFnLmpzI0w2NjZcbiAgICB2YXIgZXZlbnRUYXJnZXRzID0gW1xuICAgICAgJ0V2ZW50VGFyZ2V0JyxcbiAgICAgICdXaW5kb3cnLFxuICAgICAgJ05vZGUnLFxuICAgICAgJ0FwcGxpY2F0aW9uQ2FjaGUnLFxuICAgICAgJ0F1ZGlvVHJhY2tMaXN0JyxcbiAgICAgICdDaGFubmVsTWVyZ2VyTm9kZScsXG4gICAgICAnQ3J5cHRvT3BlcmF0aW9uJyxcbiAgICAgICdFdmVudFNvdXJjZScsXG4gICAgICAnRmlsZVJlYWRlcicsXG4gICAgICAnSFRNTFVua25vd25FbGVtZW50JyxcbiAgICAgICdJREJEYXRhYmFzZScsXG4gICAgICAnSURCUmVxdWVzdCcsXG4gICAgICAnSURCVHJhbnNhY3Rpb24nLFxuICAgICAgJ0tleU9wZXJhdGlvbicsXG4gICAgICAnTWVkaWFDb250cm9sbGVyJyxcbiAgICAgICdNZXNzYWdlUG9ydCcsXG4gICAgICAnTW9kYWxXaW5kb3cnLFxuICAgICAgJ05vdGlmaWNhdGlvbicsXG4gICAgICAnU1ZHRWxlbWVudEluc3RhbmNlJyxcbiAgICAgICdTY3JlZW4nLFxuICAgICAgJ1RleHRUcmFjaycsXG4gICAgICAnVGV4dFRyYWNrQ3VlJyxcbiAgICAgICdUZXh0VHJhY2tMaXN0JyxcbiAgICAgICdXZWJTb2NrZXQnLFxuICAgICAgJ1dlYlNvY2tldFdvcmtlcicsXG4gICAgICAnV29ya2VyJyxcbiAgICAgICdYTUxIdHRwUmVxdWVzdCcsXG4gICAgICAnWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCcsXG4gICAgICAnWE1MSHR0cFJlcXVlc3RVcGxvYWQnXG4gICAgXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50VGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgd3JhcEV2ZW50VGFyZ2V0KGV2ZW50VGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnN0cnVtZW50IGJyb3dzZXIgYnVpbHQtaW5zIHcvIGJyZWFkY3J1bWIgY2FwdHVyaW5nXG4gICAqICAtIFhNTEh0dHBSZXF1ZXN0c1xuICAgKiAgLSBET00gaW50ZXJhY3Rpb25zIChjbGljay90eXBpbmcpXG4gICAqICAtIHdpbmRvdy5sb2NhdGlvbiBjaGFuZ2VzXG4gICAqICAtIGNvbnNvbGVcbiAgICpcbiAgICogQ2FuIGJlIGRpc2FibGVkIG9yIGluZGl2aWR1YWxseSBjb25maWd1cmVkIHZpYSB0aGUgYGF1dG9CcmVhZGNydW1ic2AgY29uZmlnIG9wdGlvblxuICAgKi9cbiAgX2luc3RydW1lbnRCcmVhZGNydW1iczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhdXRvQnJlYWRjcnVtYnMgPSB0aGlzLl9nbG9iYWxPcHRpb25zLmF1dG9CcmVhZGNydW1icztcblxuICAgIHZhciB3cmFwcGVkQnVpbHRJbnMgPSBzZWxmLl93cmFwcGVkQnVpbHRJbnM7XG5cbiAgICBmdW5jdGlvbiB3cmFwUHJvcChwcm9wLCB4aHIpIHtcbiAgICAgIGlmIChwcm9wIGluIHhociAmJiBpc0Z1bmN0aW9uKHhocltwcm9wXSkpIHtcbiAgICAgICAgZmlsbCh4aHIsIHByb3AsIGZ1bmN0aW9uKG9yaWcpIHtcbiAgICAgICAgICByZXR1cm4gc2VsZi53cmFwKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtZWNoYW5pc206IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaW5zdHJ1bWVudCcsXG4gICAgICAgICAgICAgICAgZGF0YToge2Z1bmN0aW9uOiBwcm9wLCBoYW5kbGVyOiAob3JpZyAmJiBvcmlnLm5hbWUpIHx8ICc8YW5vbnltb3VzPid9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvcmlnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7IC8vIGludGVudGlvbmFsbHkgZG9uJ3QgdHJhY2sgZmlsbGVkIG1ldGhvZHMgb24gWEhSIGluc3RhbmNlc1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhdXRvQnJlYWRjcnVtYnMueGhyICYmICdYTUxIdHRwUmVxdWVzdCcgaW4gX3dpbmRvdykge1xuICAgICAgdmFyIHhocnByb3RvID0gX3dpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiBfd2luZG93LlhNTEh0dHBSZXF1ZXN0LnByb3RvdHlwZTtcbiAgICAgIGZpbGwoXG4gICAgICAgIHhocnByb3RvLFxuICAgICAgICAnb3BlbicsXG4gICAgICAgIGZ1bmN0aW9uKG9yaWdPcGVuKSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKG1ldGhvZCwgdXJsKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBhcml0eVxuXG4gICAgICAgICAgICAvLyBpZiBTZW50cnkga2V5IGFwcGVhcnMgaW4gVVJMLCBkb24ndCBjYXB0dXJlXG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcodXJsKSAmJiB1cmwuaW5kZXhPZihzZWxmLl9nbG9iYWxLZXkpID09PSAtMSkge1xuICAgICAgICAgICAgICB0aGlzLl9fcmF2ZW5feGhyID0ge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgIHN0YXR1c19jb2RlOiBudWxsXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBvcmlnT3Blbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdyYXBwZWRCdWlsdEluc1xuICAgICAgKTtcblxuICAgICAgZmlsbChcbiAgICAgICAgeGhycHJvdG8sXG4gICAgICAgICdzZW5kJyxcbiAgICAgICAgZnVuY3Rpb24ob3JpZ1NlbmQpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBhcml0eVxuICAgICAgICAgICAgdmFyIHhociA9IHRoaXM7XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIG9ucmVhZHlzdGF0ZWNoYW5nZUhhbmRsZXIoKSB7XG4gICAgICAgICAgICAgIGlmICh4aHIuX19yYXZlbl94aHIgJiYgeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgLy8gdG91Y2hpbmcgc3RhdHVzQ29kZSBpbiBzb21lIHBsYXRmb3JtcyB0aHJvd3NcbiAgICAgICAgICAgICAgICAgIC8vIGFuIGV4Y2VwdGlvblxuICAgICAgICAgICAgICAgICAgeGhyLl9fcmF2ZW5feGhyLnN0YXR1c19jb2RlID0geGhyLnN0YXR1cztcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAvKiBkbyBub3RoaW5nICovXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZi5jYXB0dXJlQnJlYWRjcnVtYih7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICAgICAgICAgICAgICBjYXRlZ29yeTogJ3hocicsXG4gICAgICAgICAgICAgICAgICBkYXRhOiB4aHIuX19yYXZlbl94aHJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBbJ29ubG9hZCcsICdvbmVycm9yJywgJ29ucHJvZ3Jlc3MnXTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcHJvcHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgd3JhcFByb3AocHJvcHNbal0sIHhocik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICgnb25yZWFkeXN0YXRlY2hhbmdlJyBpbiB4aHIgJiYgaXNGdW5jdGlvbih4aHIub25yZWFkeXN0YXRlY2hhbmdlKSkge1xuICAgICAgICAgICAgICBmaWxsKFxuICAgICAgICAgICAgICAgIHhocixcbiAgICAgICAgICAgICAgICAnb25yZWFkeXN0YXRlY2hhbmdlJyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbihvcmlnKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi53cmFwKFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgbWVjaGFuaXNtOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnaW5zdHJ1bWVudCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uOiAnb25yZWFkeXN0YXRlY2hhbmdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcjogKG9yaWcgJiYgb3JpZy5uYW1lKSB8fCAnPGFub255bW91cz4nXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvcmlnLFxuICAgICAgICAgICAgICAgICAgICBvbnJlYWR5c3RhdGVjaGFuZ2VIYW5kbGVyXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH0gLyogaW50ZW50aW9uYWxseSBkb24ndCB0cmFjayB0aGlzIGluc3RydW1lbnRhdGlvbiAqL1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gaWYgb25yZWFkeXN0YXRlY2hhbmdlIHdhc24ndCBhY3R1YWxseSBzZXQgYnkgdGhlIHBhZ2Ugb24gdGhpcyB4aHIsIHdlXG4gICAgICAgICAgICAgIC8vIGFyZSBmcmVlIHRvIHNldCBvdXIgb3duIGFuZCBjYXB0dXJlIHRoZSBicmVhZGNydW1iXG4gICAgICAgICAgICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBvbnJlYWR5c3RhdGVjaGFuZ2VIYW5kbGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gb3JpZ1NlbmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICB3cmFwcGVkQnVpbHRJbnNcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGF1dG9CcmVhZGNydW1icy54aHIgJiYgc3VwcG9ydHNGZXRjaCgpKSB7XG4gICAgICBmaWxsKFxuICAgICAgICBfd2luZG93LFxuICAgICAgICAnZmV0Y2gnLFxuICAgICAgICBmdW5jdGlvbihvcmlnRmV0Y2gpIHtcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBhcml0eVxuICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgb2YgdGhlIGFyZ3VtZW50cyB0byBwcmV2ZW50IGRlb3B0aW1pemF0aW9uXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMzItbGVha2luZy1hcmd1bWVudHNcbiAgICAgICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmZXRjaElucHV0ID0gYXJnc1swXTtcbiAgICAgICAgICAgIHZhciBtZXRob2QgPSAnR0VUJztcbiAgICAgICAgICAgIHZhciB1cmw7XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmV0Y2hJbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgdXJsID0gZmV0Y2hJbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoJ1JlcXVlc3QnIGluIF93aW5kb3cgJiYgZmV0Y2hJbnB1dCBpbnN0YW5jZW9mIF93aW5kb3cuUmVxdWVzdCkge1xuICAgICAgICAgICAgICB1cmwgPSBmZXRjaElucHV0LnVybDtcbiAgICAgICAgICAgICAgaWYgKGZldGNoSW5wdXQubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gZmV0Y2hJbnB1dC5tZXRob2Q7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVybCA9ICcnICsgZmV0Y2hJbnB1dDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgU2VudHJ5IGtleSBhcHBlYXJzIGluIFVSTCwgZG9uJ3QgY2FwdHVyZSwgYXMgaXQncyBvdXIgb3duIHJlcXVlc3RcbiAgICAgICAgICAgIGlmICh1cmwuaW5kZXhPZihzZWxmLl9nbG9iYWxLZXkpICE9PSAtMSkge1xuICAgICAgICAgICAgICByZXR1cm4gb3JpZ0ZldGNoLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoYXJnc1sxXSAmJiBhcmdzWzFdLm1ldGhvZCkge1xuICAgICAgICAgICAgICBtZXRob2QgPSBhcmdzWzFdLm1ldGhvZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGZldGNoRGF0YSA9IHtcbiAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICBzdGF0dXNfY29kZTogbnVsbFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmV0dXJuIG9yaWdGZXRjaFxuICAgICAgICAgICAgICAuYXBwbHkodGhpcywgYXJncylcbiAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBmZXRjaERhdGEuc3RhdHVzX2NvZGUgPSByZXNwb25zZS5zdGF0dXM7XG5cbiAgICAgICAgICAgICAgICBzZWxmLmNhcHR1cmVCcmVhZGNydW1iKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdodHRwJyxcbiAgICAgICAgICAgICAgICAgIGNhdGVnb3J5OiAnZmV0Y2gnLFxuICAgICAgICAgICAgICAgICAgZGF0YTogZmV0Y2hEYXRhXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgIFsnY2F0Y2gnXShmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGVyZSBpcyBhbiBlcnJvciBwZXJmb3JtaW5nIHRoZSByZXF1ZXN0XG4gICAgICAgICAgICAgICAgc2VsZi5jYXB0dXJlQnJlYWRjcnVtYih7XG4gICAgICAgICAgICAgICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICAgICAgICAgICAgICBjYXRlZ29yeTogJ2ZldGNoJyxcbiAgICAgICAgICAgICAgICAgIGRhdGE6IGZldGNoRGF0YSxcbiAgICAgICAgICAgICAgICAgIGxldmVsOiAnZXJyb3InXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIHdyYXBwZWRCdWlsdEluc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBDYXB0dXJlIGJyZWFkY3J1bWJzIGZyb20gYW55IGNsaWNrIHRoYXQgaXMgdW5oYW5kbGVkIC8gYnViYmxlZCB1cCBhbGwgdGhlIHdheVxuICAgIC8vIHRvIHRoZSBkb2N1bWVudC4gRG8gdGhpcyBiZWZvcmUgd2UgaW5zdHJ1bWVudCBhZGRFdmVudExpc3RlbmVyLlxuICAgIGlmIChhdXRvQnJlYWRjcnVtYnMuZG9tICYmIHRoaXMuX2hhc0RvY3VtZW50KSB7XG4gICAgICBpZiAoX2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgX2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2VsZi5fYnJlYWRjcnVtYkV2ZW50SGFuZGxlcignY2xpY2snKSwgZmFsc2UpO1xuICAgICAgICBfZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBzZWxmLl9rZXlwcmVzc0V2ZW50SGFuZGxlcigpLCBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKF9kb2N1bWVudC5hdHRhY2hFdmVudCkge1xuICAgICAgICAvLyBJRTggQ29tcGF0aWJpbGl0eVxuICAgICAgICBfZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29uY2xpY2snLCBzZWxmLl9icmVhZGNydW1iRXZlbnRIYW5kbGVyKCdjbGljaycpKTtcbiAgICAgICAgX2RvY3VtZW50LmF0dGFjaEV2ZW50KCdvbmtleXByZXNzJywgc2VsZi5fa2V5cHJlc3NFdmVudEhhbmRsZXIoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVjb3JkIG5hdmlnYXRpb24gKFVSTCkgY2hhbmdlc1xuICAgIC8vIE5PVEU6IGluIENocm9tZSBBcHAgZW52aXJvbm1lbnQsIHRvdWNoaW5nIGhpc3RvcnkucHVzaFN0YXRlLCAqZXZlbiBpbnNpZGVcbiAgICAvLyAgICAgICBhIHRyeS9jYXRjaCBibG9jayosIHdpbGwgY2F1c2UgQ2hyb21lIHRvIG91dHB1dCBhbiBlcnJvciB0byBjb25zb2xlLmVycm9yXG4gICAgLy8gYm9ycm93ZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci5qcy9wdWxsLzEzOTQ1L2ZpbGVzXG4gICAgdmFyIGNocm9tZSA9IF93aW5kb3cuY2hyb21lO1xuICAgIHZhciBpc0Nocm9tZVBhY2thZ2VkQXBwID0gY2hyb21lICYmIGNocm9tZS5hcHAgJiYgY2hyb21lLmFwcC5ydW50aW1lO1xuICAgIHZhciBoYXNQdXNoQW5kUmVwbGFjZVN0YXRlID1cbiAgICAgICFpc0Nocm9tZVBhY2thZ2VkQXBwICYmXG4gICAgICBfd2luZG93Lmhpc3RvcnkgJiZcbiAgICAgIF93aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgJiZcbiAgICAgIF93aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGU7XG4gICAgaWYgKGF1dG9CcmVhZGNydW1icy5sb2NhdGlvbiAmJiBoYXNQdXNoQW5kUmVwbGFjZVN0YXRlKSB7XG4gICAgICAvLyBUT0RPOiByZW1vdmUgb25wb3BzdGF0ZSBoYW5kbGVyIG9uIHVuaW5zdGFsbCgpXG4gICAgICB2YXIgb2xkT25Qb3BTdGF0ZSA9IF93aW5kb3cub25wb3BzdGF0ZTtcbiAgICAgIF93aW5kb3cub25wb3BzdGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY3VycmVudEhyZWYgPSBzZWxmLl9sb2NhdGlvbi5ocmVmO1xuICAgICAgICBzZWxmLl9jYXB0dXJlVXJsQ2hhbmdlKHNlbGYuX2xhc3RIcmVmLCBjdXJyZW50SHJlZik7XG5cbiAgICAgICAgaWYgKG9sZE9uUG9wU3RhdGUpIHtcbiAgICAgICAgICByZXR1cm4gb2xkT25Qb3BTdGF0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICB2YXIgaGlzdG9yeVJlcGxhY2VtZW50RnVuY3Rpb24gPSBmdW5jdGlvbihvcmlnSGlzdEZ1bmN0aW9uKSB7XG4gICAgICAgIC8vIG5vdGUgaGlzdG9yeS5wdXNoU3RhdGUubGVuZ3RoIGlzIDA7IGludGVudGlvbmFsbHkgbm90IGRlY2xhcmluZ1xuICAgICAgICAvLyBwYXJhbXMgdG8gcHJlc2VydmUgMCBhcml0eVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24oLyogc3RhdGUsIHRpdGxlLCB1cmwgKi8pIHtcbiAgICAgICAgICB2YXIgdXJsID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAvLyB1cmwgYXJndW1lbnQgaXMgb3B0aW9uYWxcbiAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAvLyBjb2VyY2UgdG8gc3RyaW5nICh0aGlzIGlzIHdoYXQgcHVzaFN0YXRlIGRvZXMpXG4gICAgICAgICAgICBzZWxmLl9jYXB0dXJlVXJsQ2hhbmdlKHNlbGYuX2xhc3RIcmVmLCB1cmwgKyAnJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG9yaWdIaXN0RnVuY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH07XG5cbiAgICAgIGZpbGwoX3dpbmRvdy5oaXN0b3J5LCAncHVzaFN0YXRlJywgaGlzdG9yeVJlcGxhY2VtZW50RnVuY3Rpb24sIHdyYXBwZWRCdWlsdElucyk7XG4gICAgICBmaWxsKF93aW5kb3cuaGlzdG9yeSwgJ3JlcGxhY2VTdGF0ZScsIGhpc3RvcnlSZXBsYWNlbWVudEZ1bmN0aW9uLCB3cmFwcGVkQnVpbHRJbnMpO1xuICAgIH1cblxuICAgIGlmIChhdXRvQnJlYWRjcnVtYnMuY29uc29sZSAmJiAnY29uc29sZScgaW4gX3dpbmRvdyAmJiBjb25zb2xlLmxvZykge1xuICAgICAgLy8gY29uc29sZVxuICAgICAgdmFyIGNvbnNvbGVNZXRob2RDYWxsYmFjayA9IGZ1bmN0aW9uKG1zZywgZGF0YSkge1xuICAgICAgICBzZWxmLmNhcHR1cmVCcmVhZGNydW1iKHtcbiAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgbGV2ZWw6IGRhdGEubGV2ZWwsXG4gICAgICAgICAgY2F0ZWdvcnk6ICdjb25zb2xlJ1xuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGVhY2goWydkZWJ1ZycsICdpbmZvJywgJ3dhcm4nLCAnZXJyb3InLCAnbG9nJ10sIGZ1bmN0aW9uKF8sIGxldmVsKSB7XG4gICAgICAgIHdyYXBDb25zb2xlTWV0aG9kKGNvbnNvbGUsIGxldmVsLCBjb25zb2xlTWV0aG9kQ2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIF9yZXN0b3JlQnVpbHRJbnM6IGZ1bmN0aW9uKCkge1xuICAgIC8vIHJlc3RvcmUgYW55IHdyYXBwZWQgYnVpbHRpbnNcbiAgICB2YXIgYnVpbHRpbjtcbiAgICB3aGlsZSAodGhpcy5fd3JhcHBlZEJ1aWx0SW5zLmxlbmd0aCkge1xuICAgICAgYnVpbHRpbiA9IHRoaXMuX3dyYXBwZWRCdWlsdElucy5zaGlmdCgpO1xuXG4gICAgICB2YXIgb2JqID0gYnVpbHRpblswXSxcbiAgICAgICAgbmFtZSA9IGJ1aWx0aW5bMV0sXG4gICAgICAgIG9yaWcgPSBidWlsdGluWzJdO1xuXG4gICAgICBvYmpbbmFtZV0gPSBvcmlnO1xuICAgIH1cbiAgfSxcblxuICBfcmVzdG9yZUNvbnNvbGU6IGZ1bmN0aW9uKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBndWFyZC1mb3ItaW5cbiAgICBmb3IgKHZhciBtZXRob2QgaW4gdGhpcy5fb3JpZ2luYWxDb25zb2xlTWV0aG9kcykge1xuICAgICAgdGhpcy5fb3JpZ2luYWxDb25zb2xlW21ldGhvZF0gPSB0aGlzLl9vcmlnaW5hbENvbnNvbGVNZXRob2RzW21ldGhvZF07XG4gICAgfVxuICB9LFxuXG4gIF9kcmFpblBsdWdpbnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIC8vIEZJWCBNRSBUT0RPXG4gICAgZWFjaCh0aGlzLl9wbHVnaW5zLCBmdW5jdGlvbihfLCBwbHVnaW4pIHtcbiAgICAgIHZhciBpbnN0YWxsZXIgPSBwbHVnaW5bMF07XG4gICAgICB2YXIgYXJncyA9IHBsdWdpblsxXTtcbiAgICAgIGluc3RhbGxlci5hcHBseShzZWxmLCBbc2VsZl0uY29uY2F0KGFyZ3MpKTtcbiAgICB9KTtcbiAgfSxcblxuICBfcGFyc2VEU046IGZ1bmN0aW9uKHN0cikge1xuICAgIHZhciBtID0gZHNuUGF0dGVybi5leGVjKHN0ciksXG4gICAgICBkc24gPSB7fSxcbiAgICAgIGkgPSA3O1xuXG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlIChpLS0pIGRzbltkc25LZXlzW2ldXSA9IG1baV0gfHwgJyc7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFJhdmVuQ29uZmlnRXJyb3IoJ0ludmFsaWQgRFNOOiAnICsgc3RyKTtcbiAgICB9XG5cbiAgICBpZiAoZHNuLnBhc3MgJiYgIXRoaXMuX2dsb2JhbE9wdGlvbnMuYWxsb3dTZWNyZXRLZXkpIHtcbiAgICAgIHRocm93IG5ldyBSYXZlbkNvbmZpZ0Vycm9yKFxuICAgICAgICAnRG8gbm90IHNwZWNpZnkgeW91ciBzZWNyZXQga2V5IGluIHRoZSBEU04uIFNlZTogaHR0cDovL2JpdC5seS9yYXZlbi1zZWNyZXQta2V5J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZHNuO1xuICB9LFxuXG4gIF9nZXRHbG9iYWxTZXJ2ZXI6IGZ1bmN0aW9uKHVyaSkge1xuICAgIC8vIGFzc2VtYmxlIHRoZSBlbmRwb2ludCBmcm9tIHRoZSB1cmkgcGllY2VzXG4gICAgdmFyIGdsb2JhbFNlcnZlciA9ICcvLycgKyB1cmkuaG9zdCArICh1cmkucG9ydCA/ICc6JyArIHVyaS5wb3J0IDogJycpO1xuXG4gICAgaWYgKHVyaS5wcm90b2NvbCkge1xuICAgICAgZ2xvYmFsU2VydmVyID0gdXJpLnByb3RvY29sICsgJzonICsgZ2xvYmFsU2VydmVyO1xuICAgIH1cbiAgICByZXR1cm4gZ2xvYmFsU2VydmVyO1xuICB9LFxuXG4gIF9oYW5kbGVPbkVycm9yU3RhY2tJbmZvOiBmdW5jdGlvbihzdGFja0luZm8sIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLm1lY2hhbmlzbSA9IG9wdGlvbnMubWVjaGFuaXNtIHx8IHtcbiAgICAgIHR5cGU6ICdvbmVycm9yJyxcbiAgICAgIGhhbmRsZWQ6IGZhbHNlXG4gICAgfTtcblxuICAgIC8vIGlmIHdlIGFyZSBpbnRlbnRpb25hbGx5IGlnbm9yaW5nIGVycm9ycyB2aWEgb25lcnJvciwgYmFpbCBvdXRcbiAgICBpZiAoIXRoaXMuX2lnbm9yZU9uRXJyb3IpIHtcbiAgICAgIHRoaXMuX2hhbmRsZVN0YWNrSW5mbyhzdGFja0luZm8sIG9wdGlvbnMpO1xuICAgIH1cbiAgfSxcblxuICBfaGFuZGxlU3RhY2tJbmZvOiBmdW5jdGlvbihzdGFja0luZm8sIG9wdGlvbnMpIHtcbiAgICB2YXIgZnJhbWVzID0gdGhpcy5fcHJlcGFyZUZyYW1lcyhzdGFja0luZm8sIG9wdGlvbnMpO1xuXG4gICAgdGhpcy5fdHJpZ2dlckV2ZW50KCdoYW5kbGUnLCB7XG4gICAgICBzdGFja0luZm86IHN0YWNrSW5mbyxcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTtcblxuICAgIHRoaXMuX3Byb2Nlc3NFeGNlcHRpb24oXG4gICAgICBzdGFja0luZm8ubmFtZSxcbiAgICAgIHN0YWNrSW5mby5tZXNzYWdlLFxuICAgICAgc3RhY2tJbmZvLnVybCxcbiAgICAgIHN0YWNrSW5mby5saW5lbm8sXG4gICAgICBmcmFtZXMsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfSxcblxuICBfcHJlcGFyZUZyYW1lczogZnVuY3Rpb24oc3RhY2tJbmZvLCBvcHRpb25zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBmcmFtZXMgPSBbXTtcbiAgICBpZiAoc3RhY2tJbmZvLnN0YWNrICYmIHN0YWNrSW5mby5zdGFjay5sZW5ndGgpIHtcbiAgICAgIGVhY2goc3RhY2tJbmZvLnN0YWNrLCBmdW5jdGlvbihpLCBzdGFjaykge1xuICAgICAgICB2YXIgZnJhbWUgPSBzZWxmLl9ub3JtYWxpemVGcmFtZShzdGFjaywgc3RhY2tJbmZvLnVybCk7XG4gICAgICAgIGlmIChmcmFtZSkge1xuICAgICAgICAgIGZyYW1lcy5wdXNoKGZyYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIGUuZy4gZnJhbWVzIGNhcHR1cmVkIHZpYSBjYXB0dXJlTWVzc2FnZSB0aHJvd1xuICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy50cmltSGVhZEZyYW1lcykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9wdGlvbnMudHJpbUhlYWRGcmFtZXMgJiYgaiA8IGZyYW1lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGZyYW1lc1tqXS5pbl9hcHAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmcmFtZXMgPSBmcmFtZXMuc2xpY2UoMCwgdGhpcy5fZ2xvYmFsT3B0aW9ucy5zdGFja1RyYWNlTGltaXQpO1xuICAgIHJldHVybiBmcmFtZXM7XG4gIH0sXG5cbiAgX25vcm1hbGl6ZUZyYW1lOiBmdW5jdGlvbihmcmFtZSwgc3RhY2tJbmZvVXJsKSB7XG4gICAgLy8gbm9ybWFsaXplIHRoZSBmcmFtZXMgZGF0YVxuICAgIHZhciBub3JtYWxpemVkID0ge1xuICAgICAgZmlsZW5hbWU6IGZyYW1lLnVybCxcbiAgICAgIGxpbmVubzogZnJhbWUubGluZSxcbiAgICAgIGNvbG5vOiBmcmFtZS5jb2x1bW4sXG4gICAgICBmdW5jdGlvbjogZnJhbWUuZnVuYyB8fCAnPydcbiAgICB9O1xuXG4gICAgLy8gQ2FzZSB3aGVuIHdlIGRvbid0IGhhdmUgYW55IGluZm9ybWF0aW9uIGFib3V0IHRoZSBlcnJvclxuICAgIC8vIEUuZy4gdGhyb3dpbmcgYSBzdHJpbmcgb3IgcmF3IG9iamVjdCwgaW5zdGVhZCBvZiBhbiBgRXJyb3JgIGluIEZpcmVmb3hcbiAgICAvLyBHZW5lcmF0aW5nIHN5bnRoZXRpYyBlcnJvciBkb2Vzbid0IGFkZCBhbnkgdmFsdWUgaGVyZVxuICAgIC8vXG4gICAgLy8gV2Ugc2hvdWxkIHByb2JhYmx5IHNvbWVob3cgbGV0IGEgdXNlciBrbm93IHRoYXQgdGhleSBzaG91bGQgZml4IHRoZWlyIGNvZGVcbiAgICBpZiAoIWZyYW1lLnVybCkge1xuICAgICAgbm9ybWFsaXplZC5maWxlbmFtZSA9IHN0YWNrSW5mb1VybDsgLy8gZmFsbGJhY2sgdG8gd2hvbGUgc3RhY2tzIHVybCBmcm9tIG9uZXJyb3IgaGFuZGxlclxuICAgIH1cblxuICAgIG5vcm1hbGl6ZWQuaW5fYXBwID0gIS8vIGRldGVybWluZSBpZiBhbiBleGNlcHRpb24gY2FtZSBmcm9tIG91dHNpZGUgb2Ygb3VyIGFwcFxuICAgIC8vIGZpcnN0IHdlIGNoZWNrIHRoZSBnbG9iYWwgaW5jbHVkZVBhdGhzIGxpc3QuXG4gICAgKFxuICAgICAgKCEhdGhpcy5fZ2xvYmFsT3B0aW9ucy5pbmNsdWRlUGF0aHMudGVzdCAmJlxuICAgICAgICAhdGhpcy5fZ2xvYmFsT3B0aW9ucy5pbmNsdWRlUGF0aHMudGVzdChub3JtYWxpemVkLmZpbGVuYW1lKSkgfHxcbiAgICAgIC8vIE5vdyB3ZSBjaGVjayBmb3IgZnVuLCBpZiB0aGUgZnVuY3Rpb24gbmFtZSBpcyBSYXZlbiBvciBUcmFjZUtpdFxuICAgICAgLyhSYXZlbnxUcmFjZUtpdClcXC4vLnRlc3Qobm9ybWFsaXplZFsnZnVuY3Rpb24nXSkgfHxcbiAgICAgIC8vIGZpbmFsbHksIHdlIGRvIGEgbGFzdCBkaXRjaCBlZmZvcnQgYW5kIGNoZWNrIGZvciByYXZlbi5taW4uanNcbiAgICAgIC9yYXZlblxcLihtaW5cXC4pP2pzJC8udGVzdChub3JtYWxpemVkLmZpbGVuYW1lKVxuICAgICk7XG5cbiAgICByZXR1cm4gbm9ybWFsaXplZDtcbiAgfSxcblxuICBfcHJvY2Vzc0V4Y2VwdGlvbjogZnVuY3Rpb24odHlwZSwgbWVzc2FnZSwgZmlsZXVybCwgbGluZW5vLCBmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICB2YXIgcHJlZml4ZWRNZXNzYWdlID0gKHR5cGUgPyB0eXBlICsgJzogJyA6ICcnKSArIChtZXNzYWdlIHx8ICcnKTtcbiAgICBpZiAoXG4gICAgICAhIXRoaXMuX2dsb2JhbE9wdGlvbnMuaWdub3JlRXJyb3JzLnRlc3QgJiZcbiAgICAgICh0aGlzLl9nbG9iYWxPcHRpb25zLmlnbm9yZUVycm9ycy50ZXN0KG1lc3NhZ2UpIHx8XG4gICAgICAgIHRoaXMuX2dsb2JhbE9wdGlvbnMuaWdub3JlRXJyb3JzLnRlc3QocHJlZml4ZWRNZXNzYWdlKSlcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgc3RhY2t0cmFjZTtcblxuICAgIGlmIChmcmFtZXMgJiYgZnJhbWVzLmxlbmd0aCkge1xuICAgICAgZmlsZXVybCA9IGZyYW1lc1swXS5maWxlbmFtZSB8fCBmaWxldXJsO1xuICAgICAgLy8gU2VudHJ5IGV4cGVjdHMgZnJhbWVzIG9sZGVzdCB0byBuZXdlc3RcbiAgICAgIC8vIGFuZCBKUyBzZW5kcyB0aGVtIGFzIG5ld2VzdCB0byBvbGRlc3RcbiAgICAgIGZyYW1lcy5yZXZlcnNlKCk7XG4gICAgICBzdGFja3RyYWNlID0ge2ZyYW1lczogZnJhbWVzfTtcbiAgICB9IGVsc2UgaWYgKGZpbGV1cmwpIHtcbiAgICAgIHN0YWNrdHJhY2UgPSB7XG4gICAgICAgIGZyYW1lczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZpbGVuYW1lOiBmaWxldXJsLFxuICAgICAgICAgICAgbGluZW5vOiBsaW5lbm8sXG4gICAgICAgICAgICBpbl9hcHA6IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgISF0aGlzLl9nbG9iYWxPcHRpb25zLmlnbm9yZVVybHMudGVzdCAmJlxuICAgICAgdGhpcy5fZ2xvYmFsT3B0aW9ucy5pZ25vcmVVcmxzLnRlc3QoZmlsZXVybClcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAhIXRoaXMuX2dsb2JhbE9wdGlvbnMud2hpdGVsaXN0VXJscy50ZXN0ICYmXG4gICAgICAhdGhpcy5fZ2xvYmFsT3B0aW9ucy53aGl0ZWxpc3RVcmxzLnRlc3QoZmlsZXVybClcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZGF0YSA9IG9iamVjdE1lcmdlKFxuICAgICAge1xuICAgICAgICAvLyBzZW50cnkuaW50ZXJmYWNlcy5FeGNlcHRpb25cbiAgICAgICAgZXhjZXB0aW9uOiB7XG4gICAgICAgICAgdmFsdWVzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgIHZhbHVlOiBtZXNzYWdlLFxuICAgICAgICAgICAgICBzdGFja3RyYWNlOiBzdGFja3RyYWNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB0cmFuc2FjdGlvbjogZmlsZXVybFxuICAgICAgfSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuXG4gICAgdmFyIGV4ID0gZGF0YS5leGNlcHRpb24udmFsdWVzWzBdO1xuICAgIGlmIChleC50eXBlID09IG51bGwgJiYgZXgudmFsdWUgPT09ICcnKSB7XG4gICAgICBleC52YWx1ZSA9ICdVbnJlY292ZXJhYmxlIGVycm9yIGNhdWdodCc7XG4gICAgfVxuXG4gICAgLy8gTW92ZSBtZWNoYW5pc20gZnJvbSBvcHRpb25zIHRvIGV4Y2VwdGlvbiBpbnRlcmZhY2VcbiAgICAvLyBXZSBkbyB0aGlzLCBhcyByZXF1aXJpbmcgdXNlciB0byBwYXNzIGB7ZXhjZXB0aW9uOnttZWNoYW5pc206eyAuLi4gfX19YCB3b3VsZCBiZVxuICAgIC8vIHRvbyBtdWNoXG4gICAgaWYgKCFkYXRhLmV4Y2VwdGlvbi5tZWNoYW5pc20gJiYgZGF0YS5tZWNoYW5pc20pIHtcbiAgICAgIGRhdGEuZXhjZXB0aW9uLm1lY2hhbmlzbSA9IGRhdGEubWVjaGFuaXNtO1xuICAgICAgZGVsZXRlIGRhdGEubWVjaGFuaXNtO1xuICAgIH1cblxuICAgIGRhdGEuZXhjZXB0aW9uLm1lY2hhbmlzbSA9IG9iamVjdE1lcmdlKFxuICAgICAge1xuICAgICAgICB0eXBlOiAnZ2VuZXJpYycsXG4gICAgICAgIGhhbmRsZWQ6IHRydWVcbiAgICAgIH0sXG4gICAgICBkYXRhLmV4Y2VwdGlvbi5tZWNoYW5pc20gfHwge31cbiAgICApO1xuXG4gICAgLy8gRmlyZSBhd2F5IVxuICAgIHRoaXMuX3NlbmQoZGF0YSk7XG4gIH0sXG5cbiAgX3RyaW1QYWNrZXQ6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAvLyBGb3Igbm93LCB3ZSBvbmx5IHdhbnQgdG8gdHJ1bmNhdGUgdGhlIHR3byBkaWZmZXJlbnQgbWVzc2FnZXNcbiAgICAvLyBidXQgdGhpcyBjb3VsZC9zaG91bGQgYmUgZXhwYW5kZWQgdG8ganVzdCB0cmltIGV2ZXJ5dGhpbmdcbiAgICB2YXIgbWF4ID0gdGhpcy5fZ2xvYmFsT3B0aW9ucy5tYXhNZXNzYWdlTGVuZ3RoO1xuICAgIGlmIChkYXRhLm1lc3NhZ2UpIHtcbiAgICAgIGRhdGEubWVzc2FnZSA9IHRydW5jYXRlKGRhdGEubWVzc2FnZSwgbWF4KTtcbiAgICB9XG4gICAgaWYgKGRhdGEuZXhjZXB0aW9uKSB7XG4gICAgICB2YXIgZXhjZXB0aW9uID0gZGF0YS5leGNlcHRpb24udmFsdWVzWzBdO1xuICAgICAgZXhjZXB0aW9uLnZhbHVlID0gdHJ1bmNhdGUoZXhjZXB0aW9uLnZhbHVlLCBtYXgpO1xuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gZGF0YS5yZXF1ZXN0O1xuICAgIGlmIChyZXF1ZXN0KSB7XG4gICAgICBpZiAocmVxdWVzdC51cmwpIHtcbiAgICAgICAgcmVxdWVzdC51cmwgPSB0cnVuY2F0ZShyZXF1ZXN0LnVybCwgdGhpcy5fZ2xvYmFsT3B0aW9ucy5tYXhVcmxMZW5ndGgpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcXVlc3QuUmVmZXJlcikge1xuICAgICAgICByZXF1ZXN0LlJlZmVyZXIgPSB0cnVuY2F0ZShyZXF1ZXN0LlJlZmVyZXIsIHRoaXMuX2dsb2JhbE9wdGlvbnMubWF4VXJsTGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGF0YS5icmVhZGNydW1icyAmJiBkYXRhLmJyZWFkY3J1bWJzLnZhbHVlcylcbiAgICAgIHRoaXMuX3RyaW1CcmVhZGNydW1icyhkYXRhLmJyZWFkY3J1bWJzKTtcblxuICAgIHJldHVybiBkYXRhO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcnVuY2F0ZSBicmVhZGNydW1iIHZhbHVlcyAocmlnaHQgbm93IGp1c3QgVVJMcylcbiAgICovXG4gIF90cmltQnJlYWRjcnVtYnM6IGZ1bmN0aW9uKGJyZWFkY3J1bWJzKSB7XG4gICAgLy8ga25vd24gYnJlYWRjcnVtYiBwcm9wZXJ0aWVzIHdpdGggdXJsc1xuICAgIC8vIFRPRE86IGFsc28gY29uc2lkZXIgYXJiaXRyYXJ5IHByb3AgdmFsdWVzIHRoYXQgc3RhcnQgd2l0aCAoaHR0cHM/KT86Ly9cbiAgICB2YXIgdXJsUHJvcHMgPSBbJ3RvJywgJ2Zyb20nLCAndXJsJ10sXG4gICAgICB1cmxQcm9wLFxuICAgICAgY3J1bWIsXG4gICAgICBkYXRhO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBicmVhZGNydW1icy52YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNydW1iID0gYnJlYWRjcnVtYnMudmFsdWVzW2ldO1xuICAgICAgaWYgKFxuICAgICAgICAhY3J1bWIuaGFzT3duUHJvcGVydHkoJ2RhdGEnKSB8fFxuICAgICAgICAhaXNPYmplY3QoY3J1bWIuZGF0YSkgfHxcbiAgICAgICAgb2JqZWN0RnJvemVuKGNydW1iLmRhdGEpXG4gICAgICApXG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBkYXRhID0gb2JqZWN0TWVyZ2Uoe30sIGNydW1iLmRhdGEpO1xuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB1cmxQcm9wcy5sZW5ndGg7ICsraikge1xuICAgICAgICB1cmxQcm9wID0gdXJsUHJvcHNbal07XG4gICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KHVybFByb3ApICYmIGRhdGFbdXJsUHJvcF0pIHtcbiAgICAgICAgICBkYXRhW3VybFByb3BdID0gdHJ1bmNhdGUoZGF0YVt1cmxQcm9wXSwgdGhpcy5fZ2xvYmFsT3B0aW9ucy5tYXhVcmxMZW5ndGgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhZGNydW1icy52YWx1ZXNbaV0uZGF0YSA9IGRhdGE7XG4gICAgfVxuICB9LFxuXG4gIF9nZXRIdHRwRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9oYXNOYXZpZ2F0b3IgJiYgIXRoaXMuX2hhc0RvY3VtZW50KSByZXR1cm47XG4gICAgdmFyIGh0dHBEYXRhID0ge307XG5cbiAgICBpZiAodGhpcy5faGFzTmF2aWdhdG9yICYmIF9uYXZpZ2F0b3IudXNlckFnZW50KSB7XG4gICAgICBodHRwRGF0YS5oZWFkZXJzID0ge1xuICAgICAgICAnVXNlci1BZ2VudCc6IF9uYXZpZ2F0b3IudXNlckFnZW50XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIENoZWNrIGluIGB3aW5kb3dgIGluc3RlYWQgb2YgYGRvY3VtZW50YCwgYXMgd2UgbWF5IGJlIGluIFNlcnZpY2VXb3JrZXIgZW52aXJvbm1lbnRcbiAgICBpZiAoX3dpbmRvdy5sb2NhdGlvbiAmJiBfd2luZG93LmxvY2F0aW9uLmhyZWYpIHtcbiAgICAgIGh0dHBEYXRhLnVybCA9IF93aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faGFzRG9jdW1lbnQgJiYgX2RvY3VtZW50LnJlZmVycmVyKSB7XG4gICAgICBpZiAoIWh0dHBEYXRhLmhlYWRlcnMpIGh0dHBEYXRhLmhlYWRlcnMgPSB7fTtcbiAgICAgIGh0dHBEYXRhLmhlYWRlcnMuUmVmZXJlciA9IF9kb2N1bWVudC5yZWZlcnJlcjtcbiAgICB9XG5cbiAgICByZXR1cm4gaHR0cERhdGE7XG4gIH0sXG5cbiAgX3Jlc2V0QmFja29mZjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fYmFja29mZkR1cmF0aW9uID0gMDtcbiAgICB0aGlzLl9iYWNrb2ZmU3RhcnQgPSBudWxsO1xuICB9LFxuXG4gIF9zaG91bGRCYWNrb2ZmOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFja29mZkR1cmF0aW9uICYmIG5vdygpIC0gdGhpcy5fYmFja29mZlN0YXJ0IDwgdGhpcy5fYmFja29mZkR1cmF0aW9uO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGluLXByb2Nlc3MgZGF0YSBwYXlsb2FkIG1hdGNoZXMgdGhlIHNpZ25hdHVyZVxuICAgKiBvZiB0aGUgcHJldmlvdXNseS1zZW50IGRhdGFcbiAgICpcbiAgICogTk9URTogVGhpcyBoYXMgdG8gYmUgZG9uZSBhdCB0aGlzIGxldmVsIGJlY2F1c2UgVHJhY2VLaXQgY2FuIGdlbmVyYXRlXG4gICAqICAgICAgIGRhdGEgZnJvbSB3aW5kb3cub25lcnJvciBXSVRIT1VUIGFuIGV4Y2VwdGlvbiBvYmplY3QgKElFOCwgSUU5LFxuICAgKiAgICAgICBvdGhlciBvbGQgYnJvd3NlcnMpLiBUaGlzIGNhbiB0YWtlIHRoZSBmb3JtIG9mIGFuIFwiZXhjZXB0aW9uXCJcbiAgICogICAgICAgZGF0YSBvYmplY3Qgd2l0aCBhIHNpbmdsZSBmcmFtZSAoZGVyaXZlZCBmcm9tIHRoZSBvbmVycm9yIGFyZ3MpLlxuICAgKi9cbiAgX2lzUmVwZWF0RGF0YTogZnVuY3Rpb24oY3VycmVudCkge1xuICAgIHZhciBsYXN0ID0gdGhpcy5fbGFzdERhdGE7XG5cbiAgICBpZiAoXG4gICAgICAhbGFzdCB8fFxuICAgICAgY3VycmVudC5tZXNzYWdlICE9PSBsYXN0Lm1lc3NhZ2UgfHwgLy8gZGVmaW5lZCBmb3IgY2FwdHVyZU1lc3NhZ2VcbiAgICAgIGN1cnJlbnQudHJhbnNhY3Rpb24gIT09IGxhc3QudHJhbnNhY3Rpb24gLy8gZGVmaW5lZCBmb3IgY2FwdHVyZUV4Y2VwdGlvbi9vbmVycm9yXG4gICAgKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gU3RhY2t0cmFjZSBpbnRlcmZhY2UgKGkuZS4gZnJvbSBjYXB0dXJlTWVzc2FnZSlcbiAgICBpZiAoY3VycmVudC5zdGFja3RyYWNlIHx8IGxhc3Quc3RhY2t0cmFjZSkge1xuICAgICAgcmV0dXJuIGlzU2FtZVN0YWNrdHJhY2UoY3VycmVudC5zdGFja3RyYWNlLCBsYXN0LnN0YWNrdHJhY2UpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5leGNlcHRpb24gfHwgbGFzdC5leGNlcHRpb24pIHtcbiAgICAgIC8vIEV4Y2VwdGlvbiBpbnRlcmZhY2UgKGkuZS4gZnJvbSBjYXB0dXJlRXhjZXB0aW9uL29uZXJyb3IpXG4gICAgICByZXR1cm4gaXNTYW1lRXhjZXB0aW9uKGN1cnJlbnQuZXhjZXB0aW9uLCBsYXN0LmV4Y2VwdGlvbik7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50LmZpbmdlcnByaW50IHx8IGxhc3QuZmluZ2VycHJpbnQpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKGN1cnJlbnQuZmluZ2VycHJpbnQgJiYgbGFzdC5maW5nZXJwcmludCkgJiZcbiAgICAgICAgSlNPTi5zdHJpbmdpZnkoY3VycmVudC5maW5nZXJwcmludCkgPT09IEpTT04uc3RyaW5naWZ5KGxhc3QuZmluZ2VycHJpbnQpXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgX3NldEJhY2tvZmZTdGF0ZTogZnVuY3Rpb24ocmVxdWVzdCkge1xuICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IGluIGEgYmFja29mZiBzdGF0ZSwgZG9uJ3QgY2hhbmdlIGFueXRoaW5nXG4gICAgaWYgKHRoaXMuX3Nob3VsZEJhY2tvZmYoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGF0dXMgPSByZXF1ZXN0LnN0YXR1cztcblxuICAgIC8vIDQwMCAtIHByb2plY3RfaWQgZG9lc24ndCBleGlzdCBvciBzb21lIG90aGVyIGZhdGFsXG4gICAgLy8gNDAxIC0gaW52YWxpZC9yZXZva2VkIGRzblxuICAgIC8vIDQyOSAtIHRvbyBtYW55IHJlcXVlc3RzXG4gICAgaWYgKCEoc3RhdHVzID09PSA0MDAgfHwgc3RhdHVzID09PSA0MDEgfHwgc3RhdHVzID09PSA0MjkpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0cnk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIElmIFJldHJ5LUFmdGVyIGlzIG5vdCBpbiBBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVycywgbW9zdFxuICAgICAgLy8gYnJvd3NlcnMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gdHJ5aW5nIHRvIGFjY2VzcyBpdFxuICAgICAgaWYgKHN1cHBvcnRzRmV0Y2goKSkge1xuICAgICAgICByZXRyeSA9IHJlcXVlc3QuaGVhZGVycy5nZXQoJ1JldHJ5LUFmdGVyJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXRyeSA9IHJlcXVlc3QuZ2V0UmVzcG9uc2VIZWFkZXIoJ1JldHJ5LUFmdGVyJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHJ5LUFmdGVyIGlzIHJldHVybmVkIGluIHNlY29uZHNcbiAgICAgIHJldHJ5ID0gcGFyc2VJbnQocmV0cnksIDEwKSAqIDEwMDA7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLyogZXNsaW50IG5vLWVtcHR5OjAgKi9cbiAgICB9XG5cbiAgICB0aGlzLl9iYWNrb2ZmRHVyYXRpb24gPSByZXRyeVxuICAgICAgPyAvLyBJZiBTZW50cnkgc2VydmVyIHJldHVybmVkIGEgUmV0cnktQWZ0ZXIgdmFsdWUsIHVzZSBpdFxuICAgICAgICByZXRyeVxuICAgICAgOiAvLyBPdGhlcndpc2UsIGRvdWJsZSB0aGUgbGFzdCBiYWNrb2ZmIGR1cmF0aW9uIChzdGFydHMgYXQgMSBzZWMpXG4gICAgICAgIHRoaXMuX2JhY2tvZmZEdXJhdGlvbiAqIDIgfHwgMTAwMDtcblxuICAgIHRoaXMuX2JhY2tvZmZTdGFydCA9IG5vdygpO1xuICB9LFxuXG4gIF9zZW5kOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIGdsb2JhbE9wdGlvbnMgPSB0aGlzLl9nbG9iYWxPcHRpb25zO1xuXG4gICAgdmFyIGJhc2VEYXRhID0ge1xuICAgICAgICBwcm9qZWN0OiB0aGlzLl9nbG9iYWxQcm9qZWN0LFxuICAgICAgICBsb2dnZXI6IGdsb2JhbE9wdGlvbnMubG9nZ2VyLFxuICAgICAgICBwbGF0Zm9ybTogJ2phdmFzY3JpcHQnXG4gICAgICB9LFxuICAgICAgaHR0cERhdGEgPSB0aGlzLl9nZXRIdHRwRGF0YSgpO1xuXG4gICAgaWYgKGh0dHBEYXRhKSB7XG4gICAgICBiYXNlRGF0YS5yZXF1ZXN0ID0gaHR0cERhdGE7XG4gICAgfVxuXG4gICAgLy8gSEFDSzogZGVsZXRlIGB0cmltSGVhZEZyYW1lc2AgdG8gcHJldmVudCBmcm9tIGFwcGVhcmluZyBpbiBvdXRib3VuZCBwYXlsb2FkXG4gICAgaWYgKGRhdGEudHJpbUhlYWRGcmFtZXMpIGRlbGV0ZSBkYXRhLnRyaW1IZWFkRnJhbWVzO1xuXG4gICAgZGF0YSA9IG9iamVjdE1lcmdlKGJhc2VEYXRhLCBkYXRhKTtcblxuICAgIC8vIE1lcmdlIGluIHRoZSB0YWdzIGFuZCBleHRyYSBzZXBhcmF0ZWx5IHNpbmNlIG9iamVjdE1lcmdlIGRvZXNuJ3QgaGFuZGxlIGEgZGVlcCBtZXJnZVxuICAgIGRhdGEudGFncyA9IG9iamVjdE1lcmdlKG9iamVjdE1lcmdlKHt9LCB0aGlzLl9nbG9iYWxDb250ZXh0LnRhZ3MpLCBkYXRhLnRhZ3MpO1xuICAgIGRhdGEuZXh0cmEgPSBvYmplY3RNZXJnZShvYmplY3RNZXJnZSh7fSwgdGhpcy5fZ2xvYmFsQ29udGV4dC5leHRyYSksIGRhdGEuZXh0cmEpO1xuXG4gICAgLy8gU2VuZCBhbG9uZyBvdXIgb3duIGNvbGxlY3RlZCBtZXRhZGF0YSB3aXRoIGV4dHJhXG4gICAgZGF0YS5leHRyYVsnc2Vzc2lvbjpkdXJhdGlvbiddID0gbm93KCkgLSB0aGlzLl9zdGFydFRpbWU7XG5cbiAgICBpZiAodGhpcy5fYnJlYWRjcnVtYnMgJiYgdGhpcy5fYnJlYWRjcnVtYnMubGVuZ3RoID4gMCkge1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBtYWtlIHNoYWxsb3cgY29weSBzbyB0aGF0IGFkZGl0aW9uc1xuICAgICAgLy8gdG8gYnJlYWRjcnVtYnMgYXJlbid0IGFjY2lkZW50YWxseSBzZW50IGluIHRoaXMgcmVxdWVzdFxuICAgICAgZGF0YS5icmVhZGNydW1icyA9IHtcbiAgICAgICAgdmFsdWVzOiBbXS5zbGljZS5jYWxsKHRoaXMuX2JyZWFkY3J1bWJzLCAwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZ2xvYmFsQ29udGV4dC51c2VyKSB7XG4gICAgICAvLyBzZW50cnkuaW50ZXJmYWNlcy5Vc2VyXG4gICAgICBkYXRhLnVzZXIgPSB0aGlzLl9nbG9iYWxDb250ZXh0LnVzZXI7XG4gICAgfVxuXG4gICAgLy8gSW5jbHVkZSB0aGUgZW52aXJvbm1lbnQgaWYgaXQncyBkZWZpbmVkIGluIGdsb2JhbE9wdGlvbnNcbiAgICBpZiAoZ2xvYmFsT3B0aW9ucy5lbnZpcm9ubWVudCkgZGF0YS5lbnZpcm9ubWVudCA9IGdsb2JhbE9wdGlvbnMuZW52aXJvbm1lbnQ7XG5cbiAgICAvLyBJbmNsdWRlIHRoZSByZWxlYXNlIGlmIGl0J3MgZGVmaW5lZCBpbiBnbG9iYWxPcHRpb25zXG4gICAgaWYgKGdsb2JhbE9wdGlvbnMucmVsZWFzZSkgZGF0YS5yZWxlYXNlID0gZ2xvYmFsT3B0aW9ucy5yZWxlYXNlO1xuXG4gICAgLy8gSW5jbHVkZSBzZXJ2ZXJfbmFtZSBpZiBpdCdzIGRlZmluZWQgaW4gZ2xvYmFsT3B0aW9uc1xuICAgIGlmIChnbG9iYWxPcHRpb25zLnNlcnZlck5hbWUpIGRhdGEuc2VydmVyX25hbWUgPSBnbG9iYWxPcHRpb25zLnNlcnZlck5hbWU7XG5cbiAgICBkYXRhID0gdGhpcy5fc2FuaXRpemVEYXRhKGRhdGEpO1xuXG4gICAgLy8gQ2xlYW51cCBlbXB0eSBwcm9wZXJ0aWVzIGJlZm9yZSBzZW5kaW5nIHRoZW0gdG8gdGhlIHNlcnZlclxuICAgIE9iamVjdC5rZXlzKGRhdGEpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICBpZiAoZGF0YVtrZXldID09IG51bGwgfHwgZGF0YVtrZXldID09PSAnJyB8fCBpc0VtcHR5T2JqZWN0KGRhdGFba2V5XSkpIHtcbiAgICAgICAgZGVsZXRlIGRhdGFba2V5XTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGdsb2JhbE9wdGlvbnMuZGF0YUNhbGxiYWNrKSkge1xuICAgICAgZGF0YSA9IGdsb2JhbE9wdGlvbnMuZGF0YUNhbGxiYWNrKGRhdGEpIHx8IGRhdGE7XG4gICAgfVxuXG4gICAgLy8gV2h5Pz8/Pz8/Pz8/P1xuICAgIGlmICghZGF0YSB8fCBpc0VtcHR5T2JqZWN0KGRhdGEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHJlcXVlc3Qgc2hvdWxkIGJlIGZpbHRlcmVkIG9yIG5vdFxuICAgIGlmIChcbiAgICAgIGlzRnVuY3Rpb24oZ2xvYmFsT3B0aW9ucy5zaG91bGRTZW5kQ2FsbGJhY2spICYmXG4gICAgICAhZ2xvYmFsT3B0aW9ucy5zaG91bGRTZW5kQ2FsbGJhY2soZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBCYWNrb2ZmIHN0YXRlOiBTZW50cnkgc2VydmVyIHByZXZpb3VzbHkgcmVzcG9uZGVkIHcvIGFuIGVycm9yIChlLmcuIDQyOSAtIHRvbyBtYW55IHJlcXVlc3RzKSxcbiAgICAvLyBzbyBkcm9wIHJlcXVlc3RzIHVudGlsIFwiY29vbC1vZmZcIiBwZXJpb2QgaGFzIGVsYXBzZWQuXG4gICAgaWYgKHRoaXMuX3Nob3VsZEJhY2tvZmYoKSkge1xuICAgICAgdGhpcy5fbG9nRGVidWcoJ3dhcm4nLCAnUmF2ZW4gZHJvcHBlZCBlcnJvciBkdWUgdG8gYmFja29mZjogJywgZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBnbG9iYWxPcHRpb25zLnNhbXBsZVJhdGUgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoTWF0aC5yYW5kb20oKSA8IGdsb2JhbE9wdGlvbnMuc2FtcGxlUmF0ZSkge1xuICAgICAgICB0aGlzLl9zZW5kUHJvY2Vzc2VkUGF5bG9hZChkYXRhKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc2VuZFByb2Nlc3NlZFBheWxvYWQoZGF0YSk7XG4gICAgfVxuICB9LFxuXG4gIF9zYW5pdGl6ZURhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICByZXR1cm4gc2FuaXRpemUoZGF0YSwgdGhpcy5fZ2xvYmFsT3B0aW9ucy5zYW5pdGl6ZUtleXMpO1xuICB9LFxuXG4gIF9nZXRVdWlkOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdXVpZDQoKTtcbiAgfSxcblxuICBfc2VuZFByb2Nlc3NlZFBheWxvYWQ6IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBnbG9iYWxPcHRpb25zID0gdGhpcy5fZ2xvYmFsT3B0aW9ucztcblxuICAgIGlmICghdGhpcy5pc1NldHVwKCkpIHJldHVybjtcblxuICAgIC8vIFRyeSBhbmQgY2xlYW4gdXAgdGhlIHBhY2tldCBiZWZvcmUgc2VuZGluZyBieSB0cnVuY2F0aW5nIGxvbmcgdmFsdWVzXG4gICAgZGF0YSA9IHRoaXMuX3RyaW1QYWNrZXQoZGF0YSk7XG5cbiAgICAvLyBpZGVhbGx5IGR1cGxpY2F0ZSBlcnJvciB0ZXN0aW5nIHNob3VsZCBvY2N1ciAqYmVmb3JlKiBkYXRhQ2FsbGJhY2svc2hvdWxkU2VuZENhbGxiYWNrLFxuICAgIC8vIGJ1dCB0aGlzIHdvdWxkIHJlcXVpcmUgY29weWluZyBhbiB1bi10cnVuY2F0ZWQgY29weSBvZiB0aGUgZGF0YSBwYWNrZXQsIHdoaWNoIGNhbiBiZVxuICAgIC8vIGFyYml0cmFyaWx5IGRlZXAgKGV4dHJhX2RhdGEpIC0tIGNvdWxkIGJlIHdvcnRod2hpbGU/IHdpbGwgcmV2aXNpdFxuICAgIGlmICghdGhpcy5fZ2xvYmFsT3B0aW9ucy5hbGxvd0R1cGxpY2F0ZXMgJiYgdGhpcy5faXNSZXBlYXREYXRhKGRhdGEpKSB7XG4gICAgICB0aGlzLl9sb2dEZWJ1Zygnd2FybicsICdSYXZlbiBkcm9wcGVkIHJlcGVhdCBldmVudDogJywgZGF0YSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2VuZCBhbG9uZyBhbiBldmVudF9pZCBpZiBub3QgZXhwbGljaXRseSBwYXNzZWQuXG4gICAgLy8gVGhpcyBldmVudF9pZCBjYW4gYmUgdXNlZCB0byByZWZlcmVuY2UgdGhlIGVycm9yIHdpdGhpbiBTZW50cnkgaXRzZWxmLlxuICAgIC8vIFNldCBsYXN0RXZlbnRJZCBhZnRlciB3ZSBrbm93IHRoZSBlcnJvciBzaG91bGQgYWN0dWFsbHkgYmUgc2VudFxuICAgIHRoaXMuX2xhc3RFdmVudElkID0gZGF0YS5ldmVudF9pZCB8fCAoZGF0YS5ldmVudF9pZCA9IHRoaXMuX2dldFV1aWQoKSk7XG5cbiAgICAvLyBTdG9yZSBvdXRib3VuZCBwYXlsb2FkIGFmdGVyIHRyaW1cbiAgICB0aGlzLl9sYXN0RGF0YSA9IGRhdGE7XG5cbiAgICB0aGlzLl9sb2dEZWJ1ZygnZGVidWcnLCAnUmF2ZW4gYWJvdXQgdG8gc2VuZDonLCBkYXRhKTtcblxuICAgIHZhciBhdXRoID0ge1xuICAgICAgc2VudHJ5X3ZlcnNpb246ICc3JyxcbiAgICAgIHNlbnRyeV9jbGllbnQ6ICdyYXZlbi1qcy8nICsgdGhpcy5WRVJTSU9OLFxuICAgICAgc2VudHJ5X2tleTogdGhpcy5fZ2xvYmFsS2V5XG4gICAgfTtcblxuICAgIGlmICh0aGlzLl9nbG9iYWxTZWNyZXQpIHtcbiAgICAgIGF1dGguc2VudHJ5X3NlY3JldCA9IHRoaXMuX2dsb2JhbFNlY3JldDtcbiAgICB9XG5cbiAgICB2YXIgZXhjZXB0aW9uID0gZGF0YS5leGNlcHRpb24gJiYgZGF0YS5leGNlcHRpb24udmFsdWVzWzBdO1xuXG4gICAgLy8gb25seSBjYXB0dXJlICdzZW50cnknIGJyZWFkY3J1bWIgaXMgYXV0b0JyZWFkY3J1bWJzIGlzIHRydXRoeVxuICAgIGlmIChcbiAgICAgIHRoaXMuX2dsb2JhbE9wdGlvbnMuYXV0b0JyZWFkY3J1bWJzICYmXG4gICAgICB0aGlzLl9nbG9iYWxPcHRpb25zLmF1dG9CcmVhZGNydW1icy5zZW50cnlcbiAgICApIHtcbiAgICAgIHRoaXMuY2FwdHVyZUJyZWFkY3J1bWIoe1xuICAgICAgICBjYXRlZ29yeTogJ3NlbnRyeScsXG4gICAgICAgIG1lc3NhZ2U6IGV4Y2VwdGlvblxuICAgICAgICAgID8gKGV4Y2VwdGlvbi50eXBlID8gZXhjZXB0aW9uLnR5cGUgKyAnOiAnIDogJycpICsgZXhjZXB0aW9uLnZhbHVlXG4gICAgICAgICAgOiBkYXRhLm1lc3NhZ2UsXG4gICAgICAgIGV2ZW50X2lkOiBkYXRhLmV2ZW50X2lkLFxuICAgICAgICBsZXZlbDogZGF0YS5sZXZlbCB8fCAnZXJyb3InIC8vIHByZXN1bWUgZXJyb3IgdW5sZXNzIHNwZWNpZmllZFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHVybCA9IHRoaXMuX2dsb2JhbEVuZHBvaW50O1xuICAgIChnbG9iYWxPcHRpb25zLnRyYW5zcG9ydCB8fCB0aGlzLl9tYWtlUmVxdWVzdCkuY2FsbCh0aGlzLCB7XG4gICAgICB1cmw6IHVybCxcbiAgICAgIGF1dGg6IGF1dGgsXG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgb3B0aW9uczogZ2xvYmFsT3B0aW9ucyxcbiAgICAgIG9uU3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcygpIHtcbiAgICAgICAgc2VsZi5fcmVzZXRCYWNrb2ZmKCk7XG5cbiAgICAgICAgc2VsZi5fdHJpZ2dlckV2ZW50KCdzdWNjZXNzJywge1xuICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgc3JjOiB1cmxcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG4gICAgICB9LFxuICAgICAgb25FcnJvcjogZnVuY3Rpb24gZmFpbHVyZShlcnJvcikge1xuICAgICAgICBzZWxmLl9sb2dEZWJ1ZygnZXJyb3InLCAnUmF2ZW4gdHJhbnNwb3J0IGZhaWxlZCB0byBzZW5kOiAnLCBlcnJvcik7XG5cbiAgICAgICAgaWYgKGVycm9yLnJlcXVlc3QpIHtcbiAgICAgICAgICBzZWxmLl9zZXRCYWNrb2ZmU3RhdGUoZXJyb3IucmVxdWVzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBzZWxmLl90cmlnZ2VyRXZlbnQoJ2ZhaWx1cmUnLCB7XG4gICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgICBzcmM6IHVybFxuICAgICAgICB9KTtcbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBuZXcgRXJyb3IoJ1JhdmVuIHNlbmQgZmFpbGVkIChubyBhZGRpdGlvbmFsIGRldGFpbHMgcHJvdmlkZWQpJyk7XG4gICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICBfbWFrZVJlcXVlc3Q6IGZ1bmN0aW9uKG9wdHMpIHtcbiAgICAvLyBBdXRoIGlzIGludGVudGlvbmFsbHkgc2VudCBhcyBwYXJ0IG9mIHF1ZXJ5IHN0cmluZyAoTk9UIGFzIGN1c3RvbSBIVFRQIGhlYWRlcikgdG8gYXZvaWQgcHJlZmxpZ2h0IENPUlMgcmVxdWVzdHNcbiAgICB2YXIgdXJsID0gb3B0cy51cmwgKyAnPycgKyB1cmxlbmNvZGUob3B0cy5hdXRoKTtcblxuICAgIHZhciBldmFsdWF0ZWRIZWFkZXJzID0gbnVsbDtcbiAgICB2YXIgZXZhbHVhdGVkRmV0Y2hQYXJhbWV0ZXJzID0ge307XG5cbiAgICBpZiAob3B0cy5vcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgIGV2YWx1YXRlZEhlYWRlcnMgPSB0aGlzLl9ldmFsdWF0ZUhhc2gob3B0cy5vcHRpb25zLmhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLm9wdGlvbnMuZmV0Y2hQYXJhbWV0ZXJzKSB7XG4gICAgICBldmFsdWF0ZWRGZXRjaFBhcmFtZXRlcnMgPSB0aGlzLl9ldmFsdWF0ZUhhc2gob3B0cy5vcHRpb25zLmZldGNoUGFyYW1ldGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN1cHBvcnRzRmV0Y2goKSkge1xuICAgICAgZXZhbHVhdGVkRmV0Y2hQYXJhbWV0ZXJzLmJvZHkgPSBzdHJpbmdpZnkob3B0cy5kYXRhKTtcblxuICAgICAgdmFyIGRlZmF1bHRGZXRjaE9wdGlvbnMgPSBvYmplY3RNZXJnZSh7fSwgdGhpcy5fZmV0Y2hEZWZhdWx0cyk7XG4gICAgICB2YXIgZmV0Y2hPcHRpb25zID0gb2JqZWN0TWVyZ2UoZGVmYXVsdEZldGNoT3B0aW9ucywgZXZhbHVhdGVkRmV0Y2hQYXJhbWV0ZXJzKTtcblxuICAgICAgaWYgKGV2YWx1YXRlZEhlYWRlcnMpIHtcbiAgICAgICAgZmV0Y2hPcHRpb25zLmhlYWRlcnMgPSBldmFsdWF0ZWRIZWFkZXJzO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX3dpbmRvd1xuICAgICAgICAuZmV0Y2godXJsLCBmZXRjaE9wdGlvbnMpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBvcHRzLm9uU3VjY2VzcyAmJiBvcHRzLm9uU3VjY2VzcygpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoJ1NlbnRyeSBlcnJvciBjb2RlOiAnICsgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgIC8vIEl0J3MgY2FsbGVkIHJlcXVlc3Qgb25seSB0byBrZWVwIGNvbXBhdGliaWxpdHkgd2l0aCBYSFIgaW50ZXJmYWNlXG4gICAgICAgICAgICAvLyBhbmQgbm90IGFkZCBtb3JlIHJlZHVuZGFudCBjaGVja3MgaW4gc2V0QmFja29mZlN0YXRlIG1ldGhvZFxuICAgICAgICAgICAgZXJyb3IucmVxdWVzdCA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgb3B0cy5vbkVycm9yICYmIG9wdHMub25FcnJvcihlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBbJ2NhdGNoJ10oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgb3B0cy5vbkVycm9yICYmXG4gICAgICAgICAgICBvcHRzLm9uRXJyb3IobmV3IEVycm9yKCdTZW50cnkgZXJyb3IgY29kZTogbmV0d29yayB1bmF2YWlsYWJsZScpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBfd2luZG93LlhNTEh0dHBSZXF1ZXN0ICYmIG5ldyBfd2luZG93LlhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgaWYgKCFyZXF1ZXN0KSByZXR1cm47XG5cbiAgICAvLyBpZiBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBDT1JTIChlLmcuIElFNyksIHdlIGFyZSBvdXQgb2YgbHVja1xuICAgIHZhciBoYXNDT1JTID0gJ3dpdGhDcmVkZW50aWFscycgaW4gcmVxdWVzdCB8fCB0eXBlb2YgWERvbWFpblJlcXVlc3QgIT09ICd1bmRlZmluZWQnO1xuXG4gICAgaWYgKCFoYXNDT1JTKSByZXR1cm47XG5cbiAgICBpZiAoJ3dpdGhDcmVkZW50aWFscycgaW4gcmVxdWVzdCkge1xuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgb3B0cy5vblN1Y2Nlc3MgJiYgb3B0cy5vblN1Y2Nlc3MoKTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRzLm9uRXJyb3IpIHtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdTZW50cnkgZXJyb3IgY29kZTogJyArIHJlcXVlc3Quc3RhdHVzKTtcbiAgICAgICAgICBlcnIucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgb3B0cy5vbkVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3QgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAgIC8vIHhkb21haW5yZXF1ZXN0IGNhbm5vdCBnbyBodHRwIC0+IGh0dHBzIChvciB2aWNlIHZlcnNhKSxcbiAgICAgIC8vIHNvIGFsd2F5cyB1c2UgcHJvdG9jb2wgcmVsYXRpdmVcbiAgICAgIHVybCA9IHVybC5yZXBsYWNlKC9eaHR0cHM/Oi8sICcnKTtcblxuICAgICAgLy8gb25yZWFkeXN0YXRlY2hhbmdlIG5vdCBzdXBwb3J0ZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgICAgIGlmIChvcHRzLm9uU3VjY2Vzcykge1xuICAgICAgICByZXF1ZXN0Lm9ubG9hZCA9IG9wdHMub25TdWNjZXNzO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMub25FcnJvcikge1xuICAgICAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdTZW50cnkgZXJyb3IgY29kZTogWERvbWFpblJlcXVlc3QnKTtcbiAgICAgICAgICBlcnIucmVxdWVzdCA9IHJlcXVlc3Q7XG4gICAgICAgICAgb3B0cy5vbkVycm9yKGVycik7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmVxdWVzdC5vcGVuKCdQT1NUJywgdXJsKTtcblxuICAgIGlmIChldmFsdWF0ZWRIZWFkZXJzKSB7XG4gICAgICBlYWNoKGV2YWx1YXRlZEhlYWRlcnMsIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5zZW5kKHN0cmluZ2lmeShvcHRzLmRhdGEpKTtcbiAgfSxcblxuICBfZXZhbHVhdGVIYXNoOiBmdW5jdGlvbihoYXNoKSB7XG4gICAgdmFyIGV2YWx1YXRlZCA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIGhhc2gpIHtcbiAgICAgIGlmIChoYXNoLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gaGFzaFtrZXldO1xuICAgICAgICBldmFsdWF0ZWRba2V5XSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlKCkgOiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZXZhbHVhdGVkO1xuICB9LFxuXG4gIF9sb2dEZWJ1ZzogZnVuY3Rpb24obGV2ZWwpIHtcbiAgICAvLyBXZSBhbGxvdyBgUmF2ZW4uZGVidWdgIGFuZCBgUmF2ZW4uY29uZmlnKERTTiwgeyBkZWJ1ZzogdHJ1ZSB9KWAgdG8gbm90IG1ha2UgYmFja3dhcmQgaW5jb21wYXRpYmxlIEFQSSBjaGFuZ2VcbiAgICBpZiAoXG4gICAgICB0aGlzLl9vcmlnaW5hbENvbnNvbGVNZXRob2RzW2xldmVsXSAmJlxuICAgICAgKHRoaXMuZGVidWcgfHwgdGhpcy5fZ2xvYmFsT3B0aW9ucy5kZWJ1ZylcbiAgICApIHtcbiAgICAgIC8vIEluIElFPDEwIGNvbnNvbGUgbWV0aG9kcyBkbyBub3QgaGF2ZSB0aGVpciBvd24gJ2FwcGx5JyBtZXRob2RcbiAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKFxuICAgICAgICB0aGlzLl9vcmlnaW5hbENvbnNvbGVNZXRob2RzW2xldmVsXSxcbiAgICAgICAgdGhpcy5fb3JpZ2luYWxDb25zb2xlLFxuICAgICAgICBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSlcbiAgICAgICk7XG4gICAgfVxuICB9LFxuXG4gIF9tZXJnZUNvbnRleHQ6IGZ1bmN0aW9uKGtleSwgY29udGV4dCkge1xuICAgIGlmIChpc1VuZGVmaW5lZChjb250ZXh0KSkge1xuICAgICAgZGVsZXRlIHRoaXMuX2dsb2JhbENvbnRleHRba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZ2xvYmFsQ29udGV4dFtrZXldID0gb2JqZWN0TWVyZ2UodGhpcy5fZ2xvYmFsQ29udGV4dFtrZXldIHx8IHt9LCBjb250ZXh0KTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERlcHJlY2F0aW9uc1xuUmF2ZW4ucHJvdG90eXBlLnNldFVzZXIgPSBSYXZlbi5wcm90b3R5cGUuc2V0VXNlckNvbnRleHQ7XG5SYXZlbi5wcm90b3R5cGUuc2V0UmVsZWFzZUNvbnRleHQgPSBSYXZlbi5wcm90b3R5cGUuc2V0UmVsZWFzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBSYXZlbjtcbiIsIi8qKlxuICogRW5mb3JjZXMgYSBzaW5nbGUgaW5zdGFuY2Ugb2YgdGhlIFJhdmVuIGNsaWVudCwgYW5kIHRoZVxuICogbWFpbiBlbnRyeSBwb2ludCBmb3IgUmF2ZW4uIElmIHlvdSBhcmUgYSBjb25zdW1lciBvZiB0aGVcbiAqIFJhdmVuIGxpYnJhcnksIHlvdSBTSE9VTEQgbG9hZCB0aGlzIGZpbGUgKHZzIHJhdmVuLmpzKS5cbiAqKi9cblxudmFyIFJhdmVuQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuL3JhdmVuJyk7XG5cbi8vIFRoaXMgaXMgdG8gYmUgZGVmZW5zaXZlIGluIGVudmlyb25tZW50cyB3aGVyZSB3aW5kb3cgZG9lcyBub3QgZXhpc3QgKHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3JhdmVuLWpzL3B1bGwvNzg1KVxudmFyIF93aW5kb3cgPVxuICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gd2luZG93XG4gICAgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcbnZhciBfUmF2ZW4gPSBfd2luZG93LlJhdmVuO1xuXG52YXIgUmF2ZW4gPSBuZXcgUmF2ZW5Db25zdHJ1Y3RvcigpO1xuXG4vKlxuICogQWxsb3cgbXVsdGlwbGUgdmVyc2lvbnMgb2YgUmF2ZW4gdG8gYmUgaW5zdGFsbGVkLlxuICogU3RyaXAgUmF2ZW4gZnJvbSB0aGUgZ2xvYmFsIGNvbnRleHQgYW5kIHJldHVybnMgdGhlIGluc3RhbmNlLlxuICpcbiAqIEByZXR1cm4ge1JhdmVufVxuICovXG5SYXZlbi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gIF93aW5kb3cuUmF2ZW4gPSBfUmF2ZW47XG4gIHJldHVybiBSYXZlbjtcbn07XG5cblJhdmVuLmFmdGVyTG9hZCgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJhdmVuO1xuXG4vKipcbiAqIERJU0NMQUlNRVI6XG4gKlxuICogRXhwb3NlIGBDbGllbnRgIGNvbnN0cnVjdG9yIGZvciBjYXNlcyB3aGVyZSB1c2VyIHdhbnQgdG8gdHJhY2sgbXVsdGlwbGUgXCJzdWItYXBwbGljYXRpb25zXCIgaW4gb25lIGxhcmdlciBhcHAuXG4gKiBJdCdzIG5vdCBtZWFudCB0byBiZSB1c2VkIGJ5IGEgd2lkZSBhdWRpZW5jZSwgc28gcGxlYWFhc2UgbWFrZSBzdXJlIHRoYXQgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgYmVmb3JlIHVzaW5nIGl0LlxuICogQWNjaWRlbnRhbGx5IGNhbGxpbmcgYGluc3RhbGxgIG11bHRpcGxlIHRpbWVzLCBtYXkgcmVzdWx0IGluIGFuIHVuZXhwZWN0ZWQgYmVoYXZpb3IgdGhhdCdzIHZlcnkgaGFyZCB0byBkZWJ1Zy5cbiAqXG4gKiBJdCdzIGNhbGxlZCBgQ2xpZW50JyB0byBiZSBpbi1saW5lIHdpdGggUmF2ZW4gTm9kZSBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBIT1dUTzpcbiAqXG4gKiBpbXBvcnQgUmF2ZW4gZnJvbSAncmF2ZW4tanMnO1xuICpcbiAqIGNvbnN0IHNvbWVBcHBSZXBvcnRlciA9IG5ldyBSYXZlbi5DbGllbnQoKTtcbiAqIGNvbnN0IHNvbWVPdGhlckFwcFJlcG9ydGVyID0gbmV3IFJhdmVuLkNsaWVudCgpO1xuICpcbiAqIHNvbWVBcHBSZXBvcnRlci5jb25maWcoJ19fRFNOX18nLCB7XG4gKiAgIC4uLmNvbmZpZyBnb2VzIGhlcmVcbiAqIH0pO1xuICpcbiAqIHNvbWVPdGhlckFwcFJlcG9ydGVyLmNvbmZpZygnX19PVEhFUl9EU05fXycsIHtcbiAqICAgLi4uY29uZmlnIGdvZXMgaGVyZVxuICogfSk7XG4gKlxuICogc29tZUFwcFJlcG9ydGVyLmNhcHR1cmVNZXNzYWdlKC4uLik7XG4gKiBzb21lQXBwUmVwb3J0ZXIuY2FwdHVyZUV4Y2VwdGlvbiguLi4pO1xuICogc29tZUFwcFJlcG9ydGVyLmNhcHR1cmVCcmVhZGNydW1iKC4uLik7XG4gKlxuICogc29tZU90aGVyQXBwUmVwb3J0ZXIuY2FwdHVyZU1lc3NhZ2UoLi4uKTtcbiAqIHNvbWVPdGhlckFwcFJlcG9ydGVyLmNhcHR1cmVFeGNlcHRpb24oLi4uKTtcbiAqIHNvbWVPdGhlckFwcFJlcG9ydGVyLmNhcHR1cmVCcmVhZGNydW1iKC4uLik7XG4gKlxuICogSXQgc2hvdWxkIFwianVzdCB3b3JrXCIuXG4gKi9cbm1vZHVsZS5leHBvcnRzLkNsaWVudCA9IFJhdmVuQ29uc3RydWN0b3I7XG4iLCJ2YXIgc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi4vdmVuZG9yL2pzb24tc3RyaW5naWZ5LXNhZmUvc3RyaW5naWZ5Jyk7XG5cbnZhciBfd2luZG93ID1cbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgID8gZ2xvYmFsXG4gICAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICA/IHNlbGZcbiAgICAgICAgOiB7fTtcblxuZnVuY3Rpb24gaXNPYmplY3Qod2hhdCkge1xuICByZXR1cm4gdHlwZW9mIHdoYXQgPT09ICdvYmplY3QnICYmIHdoYXQgIT09IG51bGw7XG59XG5cbi8vIFlhbmtlZCBmcm9tIGh0dHBzOi8vZ2l0LmlvL3ZTOERWIHJlLXVzZWQgdW5kZXIgQ0MwXG4vLyB3aXRoIHNvbWUgdGlueSBtb2RpZmljYXRpb25zXG5mdW5jdGlvbiBpc0Vycm9yKHZhbHVlKSB7XG4gIHN3aXRjaCAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSkge1xuICAgIGNhc2UgJ1tvYmplY3QgRXJyb3JdJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGNhc2UgJ1tvYmplY3QgRXhjZXB0aW9uXSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjYXNlICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRXJyb3JFdmVudCh2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRXJyb3JFdmVudF0nO1xufVxuXG5mdW5jdGlvbiBpc0RPTUVycm9yKHZhbHVlKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBET01FcnJvcl0nO1xufVxuXG5mdW5jdGlvbiBpc0RPTUV4Y2VwdGlvbih2YWx1ZSkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRE9NRXhjZXB0aW9uXSc7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHdoYXQpIHtcbiAgcmV0dXJuIHdoYXQgPT09IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gaXNGdW5jdGlvbih3aGF0KSB7XG4gIHJldHVybiB0eXBlb2Ygd2hhdCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh3aGF0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2hhdCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG5mdW5jdGlvbiBpc1N0cmluZyh3aGF0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwod2hhdCkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuXG5mdW5jdGlvbiBpc0FycmF5KHdoYXQpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh3aGF0KSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuZnVuY3Rpb24gaXNFbXB0eU9iamVjdCh3aGF0KSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh3aGF0KSkgcmV0dXJuIGZhbHNlO1xuXG4gIGZvciAodmFyIF8gaW4gd2hhdCkge1xuICAgIGlmICh3aGF0Lmhhc093blByb3BlcnR5KF8pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBzdXBwb3J0c0Vycm9yRXZlbnQoKSB7XG4gIHRyeSB7XG4gICAgbmV3IEVycm9yRXZlbnQoJycpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzRE9NRXJyb3IoKSB7XG4gIHRyeSB7XG4gICAgbmV3IERPTUVycm9yKCcnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdXBwb3J0c0RPTUV4Y2VwdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBuZXcgRE9NRXhjZXB0aW9uKCcnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdXBwb3J0c0ZldGNoKCkge1xuICBpZiAoISgnZmV0Y2gnIGluIF93aW5kb3cpKSByZXR1cm4gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICBuZXcgSGVhZGVycygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgIG5ldyBSZXF1ZXN0KCcnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgUmVzcG9uc2UoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vLyBEZXNwaXRlIGFsbCBzdGFycyBpbiB0aGUgc2t5IHNheWluZyB0aGF0IEVkZ2Ugc3VwcG9ydHMgb2xkIGRyYWZ0IHN5bnRheCwgYWthICduZXZlcicsICdhbHdheXMnLCAnb3JpZ2luJyBhbmQgJ2RlZmF1bHRcbi8vIGh0dHBzOi8vY2FuaXVzZS5jb20vI2ZlYXQ9cmVmZXJyZXItcG9saWN5XG4vLyBJdCBkb2Vzbid0LiBBbmQgaXQgdGhyb3cgZXhjZXB0aW9uIGluc3RlYWQgb2YgaWdub3JpbmcgdGhpcyBwYXJhbWV0ZXIuLi5cbi8vIFJFRjogaHR0cHM6Ly9naXRodWIuY29tL2dldHNlbnRyeS9yYXZlbi1qcy9pc3N1ZXMvMTIzM1xuZnVuY3Rpb24gc3VwcG9ydHNSZWZlcnJlclBvbGljeSgpIHtcbiAgaWYgKCFzdXBwb3J0c0ZldGNoKCkpIHJldHVybiBmYWxzZTtcblxuICB0cnkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcbiAgICBuZXcgUmVxdWVzdCgncGlja2xlUmljaycsIHtcbiAgICAgIHJlZmVycmVyUG9saWN5OiAnb3JpZ2luJ1xuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1cHBvcnRzUHJvbWlzZVJlamVjdGlvbkV2ZW50KCkge1xuICByZXR1cm4gdHlwZW9mIFByb21pc2VSZWplY3Rpb25FdmVudCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gd3JhcHBlZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIGZ1bmN0aW9uIGRhdGFDYWxsYmFjayhkYXRhLCBvcmlnaW5hbCkge1xuICAgIHZhciBub3JtYWxpemVkRGF0YSA9IGNhbGxiYWNrKGRhdGEpIHx8IGRhdGE7XG4gICAgaWYgKG9yaWdpbmFsKSB7XG4gICAgICByZXR1cm4gb3JpZ2luYWwobm9ybWFsaXplZERhdGEpIHx8IG5vcm1hbGl6ZWREYXRhO1xuICAgIH1cbiAgICByZXR1cm4gbm9ybWFsaXplZERhdGE7XG4gIH1cblxuICByZXR1cm4gZGF0YUNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBlYWNoKG9iaiwgY2FsbGJhY2spIHtcbiAgdmFyIGksIGo7XG5cbiAgaWYgKGlzVW5kZWZpbmVkKG9iai5sZW5ndGgpKSB7XG4gICAgZm9yIChpIGluIG9iaikge1xuICAgICAgaWYgKGhhc0tleShvYmosIGkpKSB7XG4gICAgICAgIGNhbGxiYWNrLmNhbGwobnVsbCwgaSwgb2JqW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaiA9IG9iai5sZW5ndGg7XG4gICAgaWYgKGopIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBqOyBpKyspIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLCBpLCBvYmpbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvYmplY3RNZXJnZShvYmoxLCBvYmoyKSB7XG4gIGlmICghb2JqMikge1xuICAgIHJldHVybiBvYmoxO1xuICB9XG4gIGVhY2gob2JqMiwgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIG9iajFba2V5XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIG9iajE7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBvbmx5IHVzZWQgZm9yIHJlYWN0LW5hdGl2ZS5cbiAqIHJlYWN0LW5hdGl2ZSBmcmVlemVzIG9iamVjdCB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIHNlbnQgb3ZlciB0aGVcbiAqIGpzIGJyaWRnZS4gV2UgbmVlZCB0aGlzIGZ1bmN0aW9uIGluIG9yZGVyIHRvIGNoZWNrIGlmIHRoZSBvYmplY3QgaXMgZnJvemVuLlxuICogU28gaXQncyBvayB0aGF0IG9iamVjdEZyb3plbiByZXR1cm5zIGZhbHNlIGlmIE9iamVjdC5pc0Zyb3plbiBpcyBub3RcbiAqIHN1cHBvcnRlZCBiZWNhdXNlIGl0J3Mgbm90IHJlbGV2YW50IGZvciBvdGhlciBcInBsYXRmb3Jtc1wiLiBTZWUgcmVsYXRlZCBpc3N1ZTpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvcmVhY3QtbmF0aXZlLXNlbnRyeS9pc3N1ZXMvNTdcbiAqL1xuZnVuY3Rpb24gb2JqZWN0RnJvemVuKG9iaikge1xuICBpZiAoIU9iamVjdC5pc0Zyb3plbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmlzRnJvemVuKG9iaik7XG59XG5cbmZ1bmN0aW9uIHRydW5jYXRlKHN0ciwgbWF4KSB7XG4gIGlmICh0eXBlb2YgbWF4ICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBFcnJvcignMm5kIGFyZ3VtZW50IHRvIGB0cnVuY2F0ZWAgZnVuY3Rpb24gc2hvdWxkIGJlIGEgbnVtYmVyJyk7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnIHx8IG1heCA9PT0gMCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbiAgcmV0dXJuIHN0ci5sZW5ndGggPD0gbWF4ID8gc3RyIDogc3RyLnN1YnN0cigwLCBtYXgpICsgJ1xcdTIwMjYnO1xufVxuXG4vKipcbiAqIGhhc0tleSwgYSBiZXR0ZXIgZm9ybSBvZiBoYXNPd25Qcm9wZXJ0eVxuICogRXhhbXBsZTogaGFzS2V5KE1haW5Ib3N0T2JqZWN0LCBwcm9wZXJ0eSkgPT09IHRydWUvZmFsc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaG9zdCBvYmplY3QgdG8gY2hlY2sgcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gY2hlY2tcbiAqL1xuZnVuY3Rpb24gaGFzS2V5KG9iamVjdCwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpO1xufVxuXG5mdW5jdGlvbiBqb2luUmVnRXhwKHBhdHRlcm5zKSB7XG4gIC8vIENvbWJpbmUgYW4gYXJyYXkgb2YgcmVndWxhciBleHByZXNzaW9ucyBhbmQgc3RyaW5ncyBpbnRvIG9uZSBsYXJnZSByZWdleHBcbiAgLy8gQmUgbWFkLlxuICB2YXIgc291cmNlcyA9IFtdLFxuICAgIGkgPSAwLFxuICAgIGxlbiA9IHBhdHRlcm5zLmxlbmd0aCxcbiAgICBwYXR0ZXJuO1xuXG4gIGZvciAoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBwYXR0ZXJuID0gcGF0dGVybnNbaV07XG4gICAgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgICAvLyBJZiBpdCdzIGEgc3RyaW5nLCB3ZSBuZWVkIHRvIGVzY2FwZSBpdFxuICAgICAgLy8gVGFrZW4gZnJvbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX0V4cHJlc3Npb25zXG4gICAgICBzb3VyY2VzLnB1c2gocGF0dGVybi5yZXBsYWNlKC8oWy4qKz9ePSE6JHt9KCl8XFxbXFxdXFwvXFxcXF0pL2csICdcXFxcJDEnKSk7XG4gICAgfSBlbHNlIGlmIChwYXR0ZXJuICYmIHBhdHRlcm4uc291cmNlKSB7XG4gICAgICAvLyBJZiBpdCdzIGEgcmVnZXhwIGFscmVhZHksIHdlIHdhbnQgdG8gZXh0cmFjdCB0aGUgc291cmNlXG4gICAgICBzb3VyY2VzLnB1c2gocGF0dGVybi5zb3VyY2UpO1xuICAgIH1cbiAgICAvLyBJbnRlbnRpb25hbGx5IHNraXAgb3RoZXIgY2FzZXNcbiAgfVxuICByZXR1cm4gbmV3IFJlZ0V4cChzb3VyY2VzLmpvaW4oJ3wnKSwgJ2knKTtcbn1cblxuZnVuY3Rpb24gdXJsZW5jb2RlKG8pIHtcbiAgdmFyIHBhaXJzID0gW107XG4gIGVhY2gobywgZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcbiAgfSk7XG4gIHJldHVybiBwYWlycy5qb2luKCcmJyk7XG59XG5cbi8vIGJvcnJvd2VkIGZyb20gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjYXBwZW5kaXgtQlxuLy8gaW50ZW50aW9uYWxseSB1c2luZyByZWdleCBhbmQgbm90IDxhLz4gaHJlZiBwYXJzaW5nIHRyaWNrIGJlY2F1c2UgUmVhY3QgTmF0aXZlIGFuZCBvdGhlclxuLy8gZW52aXJvbm1lbnRzIHdoZXJlIERPTSBtaWdodCBub3QgYmUgYXZhaWxhYmxlXG5mdW5jdGlvbiBwYXJzZVVybCh1cmwpIHtcbiAgaWYgKHR5cGVvZiB1cmwgIT09ICdzdHJpbmcnKSByZXR1cm4ge307XG4gIHZhciBtYXRjaCA9IHVybC5tYXRjaCgvXigoW146XFwvPyNdKyk6KT8oXFwvXFwvKFteXFwvPyNdKikpPyhbXj8jXSopKFxcPyhbXiNdKikpPygjKC4qKSk/JC8pO1xuXG4gIC8vIGNvZXJjZSB0byB1bmRlZmluZWQgdmFsdWVzIHRvIGVtcHR5IHN0cmluZyBzbyB3ZSBkb24ndCBnZXQgJ3VuZGVmaW5lZCdcbiAgdmFyIHF1ZXJ5ID0gbWF0Y2hbNl0gfHwgJyc7XG4gIHZhciBmcmFnbWVudCA9IG1hdGNoWzhdIHx8ICcnO1xuICByZXR1cm4ge1xuICAgIHByb3RvY29sOiBtYXRjaFsyXSxcbiAgICBob3N0OiBtYXRjaFs0XSxcbiAgICBwYXRoOiBtYXRjaFs1XSxcbiAgICByZWxhdGl2ZTogbWF0Y2hbNV0gKyBxdWVyeSArIGZyYWdtZW50IC8vIGV2ZXJ5dGhpbmcgbWludXMgb3JpZ2luXG4gIH07XG59XG5mdW5jdGlvbiB1dWlkNCgpIHtcbiAgdmFyIGNyeXB0byA9IF93aW5kb3cuY3J5cHRvIHx8IF93aW5kb3cubXNDcnlwdG87XG5cbiAgaWYgKCFpc1VuZGVmaW5lZChjcnlwdG8pICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBVc2Ugd2luZG93LmNyeXB0byBBUEkgaWYgYXZhaWxhYmxlXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gICAgdmFyIGFyciA9IG5ldyBVaW50MTZBcnJheSg4KTtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XG5cbiAgICAvLyBzZXQgNCBpbiBieXRlIDdcbiAgICBhcnJbM10gPSAoYXJyWzNdICYgMHhmZmYpIHwgMHg0MDAwO1xuICAgIC8vIHNldCAyIG1vc3Qgc2lnbmlmaWNhbnQgYml0cyBvZiBieXRlIDkgdG8gJzEwJ1xuICAgIGFycls0XSA9IChhcnJbNF0gJiAweDNmZmYpIHwgMHg4MDAwO1xuXG4gICAgdmFyIHBhZCA9IGZ1bmN0aW9uKG51bSkge1xuICAgICAgdmFyIHYgPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgd2hpbGUgKHYubGVuZ3RoIDwgNCkge1xuICAgICAgICB2ID0gJzAnICsgdjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2O1xuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgcGFkKGFyclswXSkgK1xuICAgICAgcGFkKGFyclsxXSkgK1xuICAgICAgcGFkKGFyclsyXSkgK1xuICAgICAgcGFkKGFyclszXSkgK1xuICAgICAgcGFkKGFycls0XSkgK1xuICAgICAgcGFkKGFycls1XSkgK1xuICAgICAgcGFkKGFycls2XSkgK1xuICAgICAgcGFkKGFycls3XSlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA1MDM0L2hvdy10by1jcmVhdGUtYS1ndWlkLXV1aWQtaW4tamF2YXNjcmlwdC8yMTE3NTIzIzIxMTc1MjNcbiAgICByZXR1cm4gJ3h4eHh4eHh4eHh4eDR4eHh5eHh4eHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcbiAgICAgIHZhciByID0gKE1hdGgucmFuZG9tKCkgKiAxNikgfCAwLFxuICAgICAgICB2ID0gYyA9PT0gJ3gnID8gciA6IChyICYgMHgzKSB8IDB4ODtcbiAgICAgIHJldHVybiB2LnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGEgY2hpbGQgRE9NIGVsZW1lbnQsIHJldHVybnMgYSBxdWVyeS1zZWxlY3RvciBzdGF0ZW1lbnQgZGVzY3JpYmluZyB0aGF0XG4gKiBhbmQgaXRzIGFuY2VzdG9yc1xuICogZS5nLiBbSFRNTEVsZW1lbnRdID0+IGJvZHkgPiBkaXYgPiBpbnB1dCNmb28uYnRuW25hbWU9YmF6XVxuICogQHBhcmFtIGVsZW1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh0bWxUcmVlQXNTdHJpbmcoZWxlbSkge1xuICAvKiBlc2xpbnQgbm8tZXh0cmEtcGFyZW5zOjAqL1xuICB2YXIgTUFYX1RSQVZFUlNFX0hFSUdIVCA9IDUsXG4gICAgTUFYX09VVFBVVF9MRU4gPSA4MCxcbiAgICBvdXQgPSBbXSxcbiAgICBoZWlnaHQgPSAwLFxuICAgIGxlbiA9IDAsXG4gICAgc2VwYXJhdG9yID0gJyA+ICcsXG4gICAgc2VwTGVuZ3RoID0gc2VwYXJhdG9yLmxlbmd0aCxcbiAgICBuZXh0U3RyO1xuXG4gIHdoaWxlIChlbGVtICYmIGhlaWdodCsrIDwgTUFYX1RSQVZFUlNFX0hFSUdIVCkge1xuICAgIG5leHRTdHIgPSBodG1sRWxlbWVudEFzU3RyaW5nKGVsZW0pO1xuICAgIC8vIGJhaWwgb3V0IGlmXG4gICAgLy8gLSBuZXh0U3RyIGlzIHRoZSAnaHRtbCcgZWxlbWVudFxuICAgIC8vIC0gdGhlIGxlbmd0aCBvZiB0aGUgc3RyaW5nIHRoYXQgd291bGQgYmUgY3JlYXRlZCBleGNlZWRzIE1BWF9PVVRQVVRfTEVOXG4gICAgLy8gICAoaWdub3JlIHRoaXMgbGltaXQgaWYgd2UgYXJlIG9uIHRoZSBmaXJzdCBpdGVyYXRpb24pXG4gICAgaWYgKFxuICAgICAgbmV4dFN0ciA9PT0gJ2h0bWwnIHx8XG4gICAgICAoaGVpZ2h0ID4gMSAmJiBsZW4gKyBvdXQubGVuZ3RoICogc2VwTGVuZ3RoICsgbmV4dFN0ci5sZW5ndGggPj0gTUFYX09VVFBVVF9MRU4pXG4gICAgKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBvdXQucHVzaChuZXh0U3RyKTtcblxuICAgIGxlbiArPSBuZXh0U3RyLmxlbmd0aDtcbiAgICBlbGVtID0gZWxlbS5wYXJlbnROb2RlO1xuICB9XG5cbiAgcmV0dXJuIG91dC5yZXZlcnNlKCkuam9pbihzZXBhcmF0b3IpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBzaW1wbGUsIHF1ZXJ5LXNlbGVjdG9yIHJlcHJlc2VudGF0aW9uIG9mIGEgRE9NIGVsZW1lbnRcbiAqIGUuZy4gW0hUTUxFbGVtZW50XSA9PiBpbnB1dCNmb28uYnRuW25hbWU9YmF6XVxuICogQHBhcmFtIEhUTUxFbGVtZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBodG1sRWxlbWVudEFzU3RyaW5nKGVsZW0pIHtcbiAgdmFyIG91dCA9IFtdLFxuICAgIGNsYXNzTmFtZSxcbiAgICBjbGFzc2VzLFxuICAgIGtleSxcbiAgICBhdHRyLFxuICAgIGk7XG5cbiAgaWYgKCFlbGVtIHx8ICFlbGVtLnRhZ05hbWUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBvdXQucHVzaChlbGVtLnRhZ05hbWUudG9Mb3dlckNhc2UoKSk7XG4gIGlmIChlbGVtLmlkKSB7XG4gICAgb3V0LnB1c2goJyMnICsgZWxlbS5pZCk7XG4gIH1cblxuICBjbGFzc05hbWUgPSBlbGVtLmNsYXNzTmFtZTtcbiAgaWYgKGNsYXNzTmFtZSAmJiBpc1N0cmluZyhjbGFzc05hbWUpKSB7XG4gICAgY2xhc3NlcyA9IGNsYXNzTmFtZS5zcGxpdCgvXFxzKy8pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvdXQucHVzaCgnLicgKyBjbGFzc2VzW2ldKTtcbiAgICB9XG4gIH1cbiAgdmFyIGF0dHJXaGl0ZWxpc3QgPSBbJ3R5cGUnLCAnbmFtZScsICd0aXRsZScsICdhbHQnXTtcbiAgZm9yIChpID0gMDsgaSA8IGF0dHJXaGl0ZWxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBhdHRyV2hpdGVsaXN0W2ldO1xuICAgIGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShrZXkpO1xuICAgIGlmIChhdHRyKSB7XG4gICAgICBvdXQucHVzaCgnWycgKyBrZXkgKyAnPVwiJyArIGF0dHIgKyAnXCJdJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQuam9pbignJyk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGVpdGhlciBhIE9SIGIgaXMgdHJ1dGh5LCBidXQgbm90IGJvdGhcbiAqL1xuZnVuY3Rpb24gaXNPbmx5T25lVHJ1dGh5KGEsIGIpIHtcbiAgcmV0dXJuICEhKCEhYSBeICEhYik7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGJvdGggcGFyYW1ldGVycyBhcmUgdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGlzQm90aFVuZGVmaW5lZChhLCBiKSB7XG4gIHJldHVybiBpc1VuZGVmaW5lZChhKSAmJiBpc1VuZGVmaW5lZChiKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHR3byBpbnB1dCBleGNlcHRpb24gaW50ZXJmYWNlcyBoYXZlIHRoZSBzYW1lIGNvbnRlbnRcbiAqL1xuZnVuY3Rpb24gaXNTYW1lRXhjZXB0aW9uKGV4MSwgZXgyKSB7XG4gIGlmIChpc09ubHlPbmVUcnV0aHkoZXgxLCBleDIpKSByZXR1cm4gZmFsc2U7XG5cbiAgZXgxID0gZXgxLnZhbHVlc1swXTtcbiAgZXgyID0gZXgyLnZhbHVlc1swXTtcblxuICBpZiAoZXgxLnR5cGUgIT09IGV4Mi50eXBlIHx8IGV4MS52YWx1ZSAhPT0gZXgyLnZhbHVlKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gaW4gY2FzZSBib3RoIHN0YWNrdHJhY2VzIGFyZSB1bmRlZmluZWQsIHdlIGNhbid0IGRlY2lkZSBzbyBkZWZhdWx0IHRvIGZhbHNlXG4gIGlmIChpc0JvdGhVbmRlZmluZWQoZXgxLnN0YWNrdHJhY2UsIGV4Mi5zdGFja3RyYWNlKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiBpc1NhbWVTdGFja3RyYWNlKGV4MS5zdGFja3RyYWNlLCBleDIuc3RhY2t0cmFjZSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0d28gaW5wdXQgc3RhY2sgdHJhY2UgaW50ZXJmYWNlcyBoYXZlIHRoZSBzYW1lIGNvbnRlbnRcbiAqL1xuZnVuY3Rpb24gaXNTYW1lU3RhY2t0cmFjZShzdGFjazEsIHN0YWNrMikge1xuICBpZiAoaXNPbmx5T25lVHJ1dGh5KHN0YWNrMSwgc3RhY2syKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBmcmFtZXMxID0gc3RhY2sxLmZyYW1lcztcbiAgdmFyIGZyYW1lczIgPSBzdGFjazIuZnJhbWVzO1xuXG4gIC8vIEV4aXQgZWFybHkgaWYgc3RhY2t0cmFjZSBpcyBtYWxmb3JtZWRcbiAgaWYgKGZyYW1lczEgPT09IHVuZGVmaW5lZCB8fCBmcmFtZXMyID09PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcblxuICAvLyBFeGl0IGVhcmx5IGlmIGZyYW1lIGNvdW50IGRpZmZlcnNcbiAgaWYgKGZyYW1lczEubGVuZ3RoICE9PSBmcmFtZXMyLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBldmVyeSBmcmFtZTsgYmFpbCBvdXQgaWYgYW55dGhpbmcgZGlmZmVyc1xuICB2YXIgYSwgYjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZXMxLmxlbmd0aDsgaSsrKSB7XG4gICAgYSA9IGZyYW1lczFbaV07XG4gICAgYiA9IGZyYW1lczJbaV07XG4gICAgaWYgKFxuICAgICAgYS5maWxlbmFtZSAhPT0gYi5maWxlbmFtZSB8fFxuICAgICAgYS5saW5lbm8gIT09IGIubGluZW5vIHx8XG4gICAgICBhLmNvbG5vICE9PSBiLmNvbG5vIHx8XG4gICAgICBhWydmdW5jdGlvbiddICE9PSBiWydmdW5jdGlvbiddXG4gICAgKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIFBvbHlmaWxsIGEgbWV0aG9kXG4gKiBAcGFyYW0gb2JqIG9iamVjdCBlLmcuIGBkb2N1bWVudGBcbiAqIEBwYXJhbSBuYW1lIG1ldGhvZCBuYW1lIHByZXNlbnQgb24gb2JqZWN0IGUuZy4gYGFkZEV2ZW50TGlzdGVuZXJgXG4gKiBAcGFyYW0gcmVwbGFjZW1lbnQgcmVwbGFjZW1lbnQgZnVuY3Rpb25cbiAqIEBwYXJhbSB0cmFjayB7b3B0aW9uYWx9IHJlY29yZCBpbnN0cnVtZW50YXRpb24gdG8gYW4gYXJyYXlcbiAqL1xuZnVuY3Rpb24gZmlsbChvYmosIG5hbWUsIHJlcGxhY2VtZW50LCB0cmFjaykge1xuICBpZiAob2JqID09IG51bGwpIHJldHVybjtcbiAgdmFyIG9yaWcgPSBvYmpbbmFtZV07XG4gIG9ialtuYW1lXSA9IHJlcGxhY2VtZW50KG9yaWcpO1xuICBvYmpbbmFtZV0uX19yYXZlbl9fID0gdHJ1ZTtcbiAgb2JqW25hbWVdLl9fb3JpZ19fID0gb3JpZztcbiAgaWYgKHRyYWNrKSB7XG4gICAgdHJhY2sucHVzaChbb2JqLCBuYW1lLCBvcmlnXSk7XG4gIH1cbn1cblxuLyoqXG4gKiBKb2luIHZhbHVlcyBpbiBhcnJheVxuICogQHBhcmFtIGlucHV0IGFycmF5IG9mIHZhbHVlcyB0byBiZSBqb2luZWQgdG9nZXRoZXJcbiAqIEBwYXJhbSBkZWxpbWl0ZXIgc3RyaW5nIHRvIGJlIHBsYWNlZCBpbi1iZXR3ZWVuIHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc2FmZUpvaW4oaW5wdXQsIGRlbGltaXRlcikge1xuICBpZiAoIWlzQXJyYXkoaW5wdXQpKSByZXR1cm4gJyc7XG5cbiAgdmFyIG91dHB1dCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICB0cnkge1xuICAgICAgb3V0cHV0LnB1c2goU3RyaW5nKGlucHV0W2ldKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgb3V0cHV0LnB1c2goJ1t2YWx1ZSBjYW5ub3QgYmUgc2VyaWFsaXplZF0nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0LmpvaW4oZGVsaW1pdGVyKTtcbn1cblxuLy8gRGVmYXVsdCBOb2RlLmpzIFJFUEwgZGVwdGhcbnZhciBNQVhfU0VSSUFMSVpFX0VYQ0VQVElPTl9ERVBUSCA9IDM7XG4vLyA1MGtCLCBhcyAxMDBrQiBpcyBtYXggcGF5bG9hZCBzaXplLCBzbyBoYWxmIHNvdW5kcyByZWFzb25hYmxlXG52YXIgTUFYX1NFUklBTElaRV9FWENFUFRJT05fU0laRSA9IDUwICogMTAyNDtcbnZhciBNQVhfU0VSSUFMSVpFX0tFWVNfTEVOR1RIID0gNDA7XG5cbmZ1bmN0aW9uIHV0ZjhMZW5ndGgodmFsdWUpIHtcbiAgcmV0dXJuIH4tZW5jb2RlVVJJKHZhbHVlKS5zcGxpdCgvJS4ufC4vKS5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGpzb25TaXplKHZhbHVlKSB7XG4gIHJldHVybiB1dGY4TGVuZ3RoKEpTT04uc3RyaW5naWZ5KHZhbHVlKSk7XG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZVZhbHVlKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1heExlbmd0aCA9IDQwO1xuICAgIHJldHVybiB0cnVuY2F0ZSh2YWx1ZSwgbWF4TGVuZ3RoKTtcbiAgfSBlbHNlIGlmIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgfHxcbiAgICB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHZhciB0eXBlID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKTtcblxuICAvLyBOb2RlLmpzIFJFUEwgbm90YXRpb25cbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE9iamVjdF0nKSByZXR1cm4gJ1tPYmplY3RdJztcbiAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IEFycmF5XScpIHJldHVybiAnW0FycmF5XSc7XG4gIGlmICh0eXBlID09PSAnW29iamVjdCBGdW5jdGlvbl0nKVxuICAgIHJldHVybiB2YWx1ZS5uYW1lID8gJ1tGdW5jdGlvbjogJyArIHZhbHVlLm5hbWUgKyAnXScgOiAnW0Z1bmN0aW9uXSc7XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemVPYmplY3QodmFsdWUsIGRlcHRoKSB7XG4gIGlmIChkZXB0aCA9PT0gMCkgcmV0dXJuIHNlcmlhbGl6ZVZhbHVlKHZhbHVlKTtcblxuICBpZiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZShmdW5jdGlvbihhY2MsIGtleSkge1xuICAgICAgYWNjW2tleV0gPSBzZXJpYWxpemVPYmplY3QodmFsdWVba2V5XSwgZGVwdGggLSAxKTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVPYmplY3QodmFsLCBkZXB0aCAtIDEpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHNlcmlhbGl6ZVZhbHVlKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplRXhjZXB0aW9uKGV4LCBkZXB0aCwgbWF4U2l6ZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QoZXgpKSByZXR1cm4gZXg7XG5cbiAgZGVwdGggPSB0eXBlb2YgZGVwdGggIT09ICdudW1iZXInID8gTUFYX1NFUklBTElaRV9FWENFUFRJT05fREVQVEggOiBkZXB0aDtcbiAgbWF4U2l6ZSA9IHR5cGVvZiBkZXB0aCAhPT0gJ251bWJlcicgPyBNQVhfU0VSSUFMSVpFX0VYQ0VQVElPTl9TSVpFIDogbWF4U2l6ZTtcblxuICB2YXIgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZU9iamVjdChleCwgZGVwdGgpO1xuXG4gIGlmIChqc29uU2l6ZShzdHJpbmdpZnkoc2VyaWFsaXplZCkpID4gbWF4U2l6ZSkge1xuICAgIHJldHVybiBzZXJpYWxpemVFeGNlcHRpb24oZXgsIGRlcHRoIC0gMSk7XG4gIH1cblxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplS2V5c0Zvck1lc3NhZ2Uoa2V5cywgbWF4TGVuZ3RoKSB7XG4gIGlmICh0eXBlb2Yga2V5cyA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGtleXMgPT09ICdzdHJpbmcnKSByZXR1cm4ga2V5cy50b1N0cmluZygpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoa2V5cykpIHJldHVybiAnJztcblxuICBrZXlzID0ga2V5cy5maWx0ZXIoZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnO1xuICB9KTtcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSByZXR1cm4gJ1tvYmplY3QgaGFzIG5vIGtleXNdJztcblxuICBtYXhMZW5ndGggPSB0eXBlb2YgbWF4TGVuZ3RoICE9PSAnbnVtYmVyJyA/IE1BWF9TRVJJQUxJWkVfS0VZU19MRU5HVEggOiBtYXhMZW5ndGg7XG4gIGlmIChrZXlzWzBdLmxlbmd0aCA+PSBtYXhMZW5ndGgpIHJldHVybiBrZXlzWzBdO1xuXG4gIGZvciAodmFyIHVzZWRLZXlzID0ga2V5cy5sZW5ndGg7IHVzZWRLZXlzID4gMDsgdXNlZEtleXMtLSkge1xuICAgIHZhciBzZXJpYWxpemVkID0ga2V5cy5zbGljZSgwLCB1c2VkS2V5cykuam9pbignLCAnKTtcbiAgICBpZiAoc2VyaWFsaXplZC5sZW5ndGggPiBtYXhMZW5ndGgpIGNvbnRpbnVlO1xuICAgIGlmICh1c2VkS2V5cyA9PT0ga2V5cy5sZW5ndGgpIHJldHVybiBzZXJpYWxpemVkO1xuICAgIHJldHVybiBzZXJpYWxpemVkICsgJ1xcdTIwMjYnO1xuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZShpbnB1dCwgc2FuaXRpemVLZXlzKSB7XG4gIGlmICghaXNBcnJheShzYW5pdGl6ZUtleXMpIHx8IChpc0FycmF5KHNhbml0aXplS2V5cykgJiYgc2FuaXRpemVLZXlzLmxlbmd0aCA9PT0gMCkpXG4gICAgcmV0dXJuIGlucHV0O1xuXG4gIHZhciBzYW5pdGl6ZVJlZ0V4cCA9IGpvaW5SZWdFeHAoc2FuaXRpemVLZXlzKTtcbiAgdmFyIHNhbml0aXplTWFzayA9ICcqKioqKioqKic7XG4gIHZhciBzYWZlSW5wdXQ7XG5cbiAgdHJ5IHtcbiAgICBzYWZlSW5wdXQgPSBKU09OLnBhcnNlKHN0cmluZ2lmeShpbnB1dCkpO1xuICB9IGNhdGNoIChvX08pIHtcbiAgICByZXR1cm4gaW5wdXQ7XG4gIH1cblxuICBmdW5jdGlvbiBzYW5pdGl6ZVdvcmtlcih3b3JrZXJJbnB1dCkge1xuICAgIGlmIChpc0FycmF5KHdvcmtlcklucHV0KSkge1xuICAgICAgcmV0dXJuIHdvcmtlcklucHV0Lm1hcChmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgcmV0dXJuIHNhbml0aXplV29ya2VyKHZhbCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoaXNQbGFpbk9iamVjdCh3b3JrZXJJbnB1dCkpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyh3b3JrZXJJbnB1dCkucmVkdWNlKGZ1bmN0aW9uKGFjYywgaykge1xuICAgICAgICBpZiAoc2FuaXRpemVSZWdFeHAudGVzdChrKSkge1xuICAgICAgICAgIGFjY1trXSA9IHNhbml0aXplTWFzaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2Nba10gPSBzYW5pdGl6ZVdvcmtlcih3b3JrZXJJbnB1dFtrXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgIH0sIHt9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya2VySW5wdXQ7XG4gIH1cblxuICByZXR1cm4gc2FuaXRpemVXb3JrZXIoc2FmZUlucHV0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNFcnJvcjogaXNFcnJvcixcbiAgaXNFcnJvckV2ZW50OiBpc0Vycm9yRXZlbnQsXG4gIGlzRE9NRXJyb3I6IGlzRE9NRXJyb3IsXG4gIGlzRE9NRXhjZXB0aW9uOiBpc0RPTUV4Y2VwdGlvbixcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1BsYWluT2JqZWN0OiBpc1BsYWluT2JqZWN0LFxuICBpc1N0cmluZzogaXNTdHJpbmcsXG4gIGlzQXJyYXk6IGlzQXJyYXksXG4gIGlzRW1wdHlPYmplY3Q6IGlzRW1wdHlPYmplY3QsXG4gIHN1cHBvcnRzRXJyb3JFdmVudDogc3VwcG9ydHNFcnJvckV2ZW50LFxuICBzdXBwb3J0c0RPTUVycm9yOiBzdXBwb3J0c0RPTUVycm9yLFxuICBzdXBwb3J0c0RPTUV4Y2VwdGlvbjogc3VwcG9ydHNET01FeGNlcHRpb24sXG4gIHN1cHBvcnRzRmV0Y2g6IHN1cHBvcnRzRmV0Y2gsXG4gIHN1cHBvcnRzUmVmZXJyZXJQb2xpY3k6IHN1cHBvcnRzUmVmZXJyZXJQb2xpY3ksXG4gIHN1cHBvcnRzUHJvbWlzZVJlamVjdGlvbkV2ZW50OiBzdXBwb3J0c1Byb21pc2VSZWplY3Rpb25FdmVudCxcbiAgd3JhcHBlZENhbGxiYWNrOiB3cmFwcGVkQ2FsbGJhY2ssXG4gIGVhY2g6IGVhY2gsXG4gIG9iamVjdE1lcmdlOiBvYmplY3RNZXJnZSxcbiAgdHJ1bmNhdGU6IHRydW5jYXRlLFxuICBvYmplY3RGcm96ZW46IG9iamVjdEZyb3plbixcbiAgaGFzS2V5OiBoYXNLZXksXG4gIGpvaW5SZWdFeHA6IGpvaW5SZWdFeHAsXG4gIHVybGVuY29kZTogdXJsZW5jb2RlLFxuICB1dWlkNDogdXVpZDQsXG4gIGh0bWxUcmVlQXNTdHJpbmc6IGh0bWxUcmVlQXNTdHJpbmcsXG4gIGh0bWxFbGVtZW50QXNTdHJpbmc6IGh0bWxFbGVtZW50QXNTdHJpbmcsXG4gIGlzU2FtZUV4Y2VwdGlvbjogaXNTYW1lRXhjZXB0aW9uLFxuICBpc1NhbWVTdGFja3RyYWNlOiBpc1NhbWVTdGFja3RyYWNlLFxuICBwYXJzZVVybDogcGFyc2VVcmwsXG4gIGZpbGw6IGZpbGwsXG4gIHNhZmVKb2luOiBzYWZlSm9pbixcbiAgc2VyaWFsaXplRXhjZXB0aW9uOiBzZXJpYWxpemVFeGNlcHRpb24sXG4gIHNlcmlhbGl6ZUtleXNGb3JNZXNzYWdlOiBzZXJpYWxpemVLZXlzRm9yTWVzc2FnZSxcbiAgc2FuaXRpemU6IHNhbml0aXplXG59O1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vc3JjL3V0aWxzJyk7XG5cbi8qXG4gVHJhY2VLaXQgLSBDcm9zcyBicm93ZXIgc3RhY2sgdHJhY2VzXG5cbiBUaGlzIHdhcyBvcmlnaW5hbGx5IGZvcmtlZCBmcm9tIGdpdGh1Yi5jb20vb2NjL1RyYWNlS2l0LCBidXQgaGFzIHNpbmNlIGJlZW5cbiBsYXJnZWx5IHJlLXdyaXR0ZW4gYW5kIGlzIG5vdyBtYWludGFpbmVkIGFzIHBhcnQgb2YgcmF2ZW4tanMuICBUZXN0cyBmb3JcbiB0aGlzIGFyZSBpbiB0ZXN0L3ZlbmRvci5cblxuIE1JVCBsaWNlbnNlXG4qL1xuXG52YXIgVHJhY2VLaXQgPSB7XG4gIGNvbGxlY3RXaW5kb3dFcnJvcnM6IHRydWUsXG4gIGRlYnVnOiBmYWxzZVxufTtcblxuLy8gVGhpcyBpcyB0byBiZSBkZWZlbnNpdmUgaW4gZW52aXJvbm1lbnRzIHdoZXJlIHdpbmRvdyBkb2VzIG5vdCBleGlzdCAoc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9nZXRzZW50cnkvcmF2ZW4tanMvcHVsbC83ODUpXG52YXIgX3dpbmRvdyA9XG4gIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgPyB3aW5kb3dcbiAgICA6IHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnXG4gICAgPyBnbG9iYWxcbiAgICA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJ1xuICAgID8gc2VsZlxuICAgIDoge307XG5cbi8vIGdsb2JhbCByZWZlcmVuY2UgdG8gc2xpY2VcbnZhciBfc2xpY2UgPSBbXS5zbGljZTtcbnZhciBVTktOT1dOX0ZVTkNUSU9OID0gJz8nO1xuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9FcnJvciNFcnJvcl90eXBlc1xudmFyIEVSUk9SX1RZUEVTX1JFID0gL14oPzpbVXVdbmNhdWdodCAoPzpleGNlcHRpb246ICk/KT8oPzooKD86RXZhbHxJbnRlcm5hbHxSYW5nZXxSZWZlcmVuY2V8U3ludGF4fFR5cGV8VVJJfClFcnJvcik6ICk/KC4qKSQvO1xuXG5mdW5jdGlvbiBnZXRMb2NhdGlvbkhyZWYoKSB7XG4gIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnIHx8IGRvY3VtZW50LmxvY2F0aW9uID09IG51bGwpIHJldHVybiAnJztcbiAgcmV0dXJuIGRvY3VtZW50LmxvY2F0aW9uLmhyZWY7XG59XG5cbmZ1bmN0aW9uIGdldExvY2F0aW9uT3JpZ2luKCkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyB8fCBkb2N1bWVudC5sb2NhdGlvbiA9PSBudWxsKSByZXR1cm4gJyc7XG5cbiAgLy8gT2ggZGVhciBJRTEwLi4uXG4gIGlmICghZG9jdW1lbnQubG9jYXRpb24ub3JpZ2luKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGRvY3VtZW50LmxvY2F0aW9uLnByb3RvY29sICtcbiAgICAgICcvLycgK1xuICAgICAgZG9jdW1lbnQubG9jYXRpb24uaG9zdG5hbWUgK1xuICAgICAgKGRvY3VtZW50LmxvY2F0aW9uLnBvcnQgPyAnOicgKyBkb2N1bWVudC5sb2NhdGlvbi5wb3J0IDogJycpXG4gICAgKTtcbiAgfVxuXG4gIHJldHVybiBkb2N1bWVudC5sb2NhdGlvbi5vcmlnaW47XG59XG5cbi8qKlxuICogVHJhY2VLaXQucmVwb3J0OiBjcm9zcy1icm93c2VyIHByb2Nlc3Npbmcgb2YgdW5oYW5kbGVkIGV4Y2VwdGlvbnNcbiAqXG4gKiBTeW50YXg6XG4gKiAgIFRyYWNlS2l0LnJlcG9ydC5zdWJzY3JpYmUoZnVuY3Rpb24oc3RhY2tJbmZvKSB7IC4uLiB9KVxuICogICBUcmFjZUtpdC5yZXBvcnQudW5zdWJzY3JpYmUoZnVuY3Rpb24oc3RhY2tJbmZvKSB7IC4uLiB9KVxuICogICBUcmFjZUtpdC5yZXBvcnQoZXhjZXB0aW9uKVxuICogICB0cnkgeyAuLi5jb2RlLi4uIH0gY2F0Y2goZXgpIHsgVHJhY2VLaXQucmVwb3J0KGV4KTsgfVxuICpcbiAqIFN1cHBvcnRzOlxuICogICAtIEZpcmVmb3g6IGZ1bGwgc3RhY2sgdHJhY2Ugd2l0aCBsaW5lIG51bWJlcnMsIHBsdXMgY29sdW1uIG51bWJlclxuICogICAgICAgICAgICAgIG9uIHRvcCBmcmFtZTsgY29sdW1uIG51bWJlciBpcyBub3QgZ3VhcmFudGVlZFxuICogICAtIE9wZXJhOiAgIGZ1bGwgc3RhY2sgdHJhY2Ugd2l0aCBsaW5lIGFuZCBjb2x1bW4gbnVtYmVyc1xuICogICAtIENocm9tZTogIGZ1bGwgc3RhY2sgdHJhY2Ugd2l0aCBsaW5lIGFuZCBjb2x1bW4gbnVtYmVyc1xuICogICAtIFNhZmFyaTogIGxpbmUgYW5kIGNvbHVtbiBudW1iZXIgZm9yIHRoZSB0b3AgZnJhbWUgb25seTsgc29tZSBmcmFtZXNcbiAqICAgICAgICAgICAgICBtYXkgYmUgbWlzc2luZywgYW5kIGNvbHVtbiBudW1iZXIgaXMgbm90IGd1YXJhbnRlZWRcbiAqICAgLSBJRTogICAgICBsaW5lIGFuZCBjb2x1bW4gbnVtYmVyIGZvciB0aGUgdG9wIGZyYW1lIG9ubHk7IHNvbWUgZnJhbWVzXG4gKiAgICAgICAgICAgICAgbWF5IGJlIG1pc3NpbmcsIGFuZCBjb2x1bW4gbnVtYmVyIGlzIG5vdCBndWFyYW50ZWVkXG4gKlxuICogSW4gdGhlb3J5LCBUcmFjZUtpdCBzaG91bGQgd29yayBvbiBhbGwgb2YgdGhlIGZvbGxvd2luZyB2ZXJzaW9uczpcbiAqICAgLSBJRTUuNSsgKG9ubHkgOC4wIHRlc3RlZClcbiAqICAgLSBGaXJlZm94IDAuOSsgKG9ubHkgMy41KyB0ZXN0ZWQpXG4gKiAgIC0gT3BlcmEgNysgKG9ubHkgMTAuNTAgdGVzdGVkOyB2ZXJzaW9ucyA5IGFuZCBlYXJsaWVyIG1heSByZXF1aXJlXG4gKiAgICAgRXhjZXB0aW9ucyBIYXZlIFN0YWNrdHJhY2UgdG8gYmUgZW5hYmxlZCBpbiBvcGVyYTpjb25maWcpXG4gKiAgIC0gU2FmYXJpIDMrIChvbmx5IDQrIHRlc3RlZClcbiAqICAgLSBDaHJvbWUgMSsgKG9ubHkgNSsgdGVzdGVkKVxuICogICAtIEtvbnF1ZXJvciAzLjUrICh1bnRlc3RlZClcbiAqXG4gKiBSZXF1aXJlcyBUcmFjZUtpdC5jb21wdXRlU3RhY2tUcmFjZS5cbiAqXG4gKiBUcmllcyB0byBjYXRjaCBhbGwgdW5oYW5kbGVkIGV4Y2VwdGlvbnMgYW5kIHJlcG9ydCB0aGVtIHRvIHRoZVxuICogc3Vic2NyaWJlZCBoYW5kbGVycy4gUGxlYXNlIG5vdGUgdGhhdCBUcmFjZUtpdC5yZXBvcnQgd2lsbCByZXRocm93IHRoZVxuICogZXhjZXB0aW9uLiBUaGlzIGlzIFJFUVVJUkVEIGluIG9yZGVyIHRvIGdldCBhIHVzZWZ1bCBzdGFjayB0cmFjZSBpbiBJRS5cbiAqIElmIHRoZSBleGNlcHRpb24gZG9lcyBub3QgcmVhY2ggdGhlIHRvcCBvZiB0aGUgYnJvd3NlciwgeW91IHdpbGwgb25seVxuICogZ2V0IGEgc3RhY2sgdHJhY2UgZnJvbSB0aGUgcG9pbnQgd2hlcmUgVHJhY2VLaXQucmVwb3J0IHdhcyBjYWxsZWQuXG4gKlxuICogSGFuZGxlcnMgcmVjZWl2ZSBhIHN0YWNrSW5mbyBvYmplY3QgYXMgZGVzY3JpYmVkIGluIHRoZVxuICogVHJhY2VLaXQuY29tcHV0ZVN0YWNrVHJhY2UgZG9jcy5cbiAqL1xuVHJhY2VLaXQucmVwb3J0ID0gKGZ1bmN0aW9uIHJlcG9ydE1vZHVsZVdyYXBwZXIoKSB7XG4gIHZhciBoYW5kbGVycyA9IFtdLFxuICAgIGxhc3RBcmdzID0gbnVsbCxcbiAgICBsYXN0RXhjZXB0aW9uID0gbnVsbCxcbiAgICBsYXN0RXhjZXB0aW9uU3RhY2sgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBBZGQgYSBjcmFzaCBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiBzdWJzY3JpYmUoaGFuZGxlcikge1xuICAgIGluc3RhbGxHbG9iYWxIYW5kbGVyKCk7XG4gICAgaGFuZGxlcnMucHVzaChoYW5kbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYSBjcmFzaCBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICBmdW5jdGlvbiB1bnN1YnNjcmliZShoYW5kbGVyKSB7XG4gICAgZm9yICh2YXIgaSA9IGhhbmRsZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICBpZiAoaGFuZGxlcnNbaV0gPT09IGhhbmRsZXIpIHtcbiAgICAgICAgaGFuZGxlcnMuc3BsaWNlKGksIDEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYWxsIGNyYXNoIGhhbmRsZXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5zdWJzY3JpYmVBbGwoKSB7XG4gICAgdW5pbnN0YWxsR2xvYmFsSGFuZGxlcigpO1xuICAgIGhhbmRsZXJzID0gW107XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2ggc3RhY2sgaW5mb3JtYXRpb24gdG8gYWxsIGhhbmRsZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCAqPn0gc3RhY2tcbiAgICovXG4gIGZ1bmN0aW9uIG5vdGlmeUhhbmRsZXJzKHN0YWNrLCBpc1dpbmRvd0Vycm9yKSB7XG4gICAgdmFyIGV4Y2VwdGlvbiA9IG51bGw7XG4gICAgaWYgKGlzV2luZG93RXJyb3IgJiYgIVRyYWNlS2l0LmNvbGxlY3RXaW5kb3dFcnJvcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSBpbiBoYW5kbGVycykge1xuICAgICAgaWYgKGhhbmRsZXJzLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaGFuZGxlcnNbaV0uYXBwbHkobnVsbCwgW3N0YWNrXS5jb25jYXQoX3NsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSkpO1xuICAgICAgICB9IGNhdGNoIChpbm5lcikge1xuICAgICAgICAgIGV4Y2VwdGlvbiA9IGlubmVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4Y2VwdGlvbikge1xuICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHZhciBfb2xkT25lcnJvckhhbmRsZXIsIF9vbkVycm9ySGFuZGxlckluc3RhbGxlZDtcblxuICAvKipcbiAgICogRW5zdXJlcyBhbGwgZ2xvYmFsIHVuaGFuZGxlZCBleGNlcHRpb25zIGFyZSByZWNvcmRlZC5cbiAgICogU3VwcG9ydGVkIGJ5IEdlY2tvIGFuZCBJRS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1zZyBFcnJvciBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsIFVSTCBvZiBzY3JpcHQgdGhhdCBnZW5lcmF0ZWQgdGhlIGV4Y2VwdGlvbi5cbiAgICogQHBhcmFtIHsobnVtYmVyfHN0cmluZyl9IGxpbmVObyBUaGUgbGluZSBudW1iZXIgYXQgd2hpY2ggdGhlIGVycm9yXG4gICAqIG9jY3VycmVkLlxuICAgKiBAcGFyYW0gez8obnVtYmVyfHN0cmluZyl9IGNvbE5vIFRoZSBjb2x1bW4gbnVtYmVyIGF0IHdoaWNoIHRoZSBlcnJvclxuICAgKiBvY2N1cnJlZC5cbiAgICogQHBhcmFtIHs/RXJyb3J9IGV4IFRoZSBhY3R1YWwgRXJyb3Igb2JqZWN0LlxuICAgKi9cbiAgZnVuY3Rpb24gdHJhY2VLaXRXaW5kb3dPbkVycm9yKG1zZywgdXJsLCBsaW5lTm8sIGNvbE5vLCBleCkge1xuICAgIHZhciBzdGFjayA9IG51bGw7XG4gICAgLy8gSWYgJ2V4JyBpcyBFcnJvckV2ZW50LCBnZXQgcmVhbCBFcnJvciBmcm9tIGluc2lkZVxuICAgIHZhciBleGNlcHRpb24gPSB1dGlscy5pc0Vycm9yRXZlbnQoZXgpID8gZXguZXJyb3IgOiBleDtcbiAgICAvLyBJZiAnbXNnJyBpcyBFcnJvckV2ZW50LCBnZXQgcmVhbCBtZXNzYWdlIGZyb20gaW5zaWRlXG4gICAgdmFyIG1lc3NhZ2UgPSB1dGlscy5pc0Vycm9yRXZlbnQobXNnKSA/IG1zZy5tZXNzYWdlIDogbXNnO1xuXG4gICAgaWYgKGxhc3RFeGNlcHRpb25TdGFjaykge1xuICAgICAgVHJhY2VLaXQuY29tcHV0ZVN0YWNrVHJhY2UuYXVnbWVudFN0YWNrVHJhY2VXaXRoSW5pdGlhbEVsZW1lbnQoXG4gICAgICAgIGxhc3RFeGNlcHRpb25TdGFjayxcbiAgICAgICAgdXJsLFxuICAgICAgICBsaW5lTm8sXG4gICAgICAgIG1lc3NhZ2VcbiAgICAgICk7XG4gICAgICBwcm9jZXNzTGFzdEV4Y2VwdGlvbigpO1xuICAgIH0gZWxzZSBpZiAoZXhjZXB0aW9uICYmIHV0aWxzLmlzRXJyb3IoZXhjZXB0aW9uKSkge1xuICAgICAgLy8gbm9uLXN0cmluZyBgZXhjZXB0aW9uYCBhcmc7IGF0dGVtcHQgdG8gZXh0cmFjdCBzdGFjayB0cmFjZVxuXG4gICAgICAvLyBOZXcgY2hyb21lIGFuZCBibGluayBzZW5kIGFsb25nIGEgcmVhbCBlcnJvciBvYmplY3RcbiAgICAgIC8vIExldCdzIGp1c3QgcmVwb3J0IHRoYXQgbGlrZSBhIG5vcm1hbCBlcnJvci5cbiAgICAgIC8vIFNlZTogaHR0cHM6Ly9taWtld2VzdC5vcmcvMjAxMy8wOC9kZWJ1Z2dpbmctcnVudGltZS1lcnJvcnMtd2l0aC13aW5kb3ctb25lcnJvclxuICAgICAgc3RhY2sgPSBUcmFjZUtpdC5jb21wdXRlU3RhY2tUcmFjZShleGNlcHRpb24pO1xuICAgICAgbm90aWZ5SGFuZGxlcnMoc3RhY2ssIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbG9jYXRpb24gPSB7XG4gICAgICAgIHVybDogdXJsLFxuICAgICAgICBsaW5lOiBsaW5lTm8sXG4gICAgICAgIGNvbHVtbjogY29sTm9cbiAgICAgIH07XG5cbiAgICAgIHZhciBuYW1lID0gdW5kZWZpbmVkO1xuICAgICAgdmFyIGdyb3VwcztcblxuICAgICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwobWVzc2FnZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nKSB7XG4gICAgICAgIHZhciBncm91cHMgPSBtZXNzYWdlLm1hdGNoKEVSUk9SX1RZUEVTX1JFKTtcbiAgICAgICAgaWYgKGdyb3Vwcykge1xuICAgICAgICAgIG5hbWUgPSBncm91cHNbMV07XG4gICAgICAgICAgbWVzc2FnZSA9IGdyb3Vwc1syXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsb2NhdGlvbi5mdW5jID0gVU5LTk9XTl9GVU5DVElPTjtcblxuICAgICAgc3RhY2sgPSB7XG4gICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIHVybDogZ2V0TG9jYXRpb25IcmVmKCksXG4gICAgICAgIHN0YWNrOiBbbG9jYXRpb25dXG4gICAgICB9O1xuICAgICAgbm90aWZ5SGFuZGxlcnMoc3RhY2ssIHRydWUpO1xuICAgIH1cblxuICAgIGlmIChfb2xkT25lcnJvckhhbmRsZXIpIHtcbiAgICAgIHJldHVybiBfb2xkT25lcnJvckhhbmRsZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBpbnN0YWxsR2xvYmFsSGFuZGxlcigpIHtcbiAgICBpZiAoX29uRXJyb3JIYW5kbGVySW5zdGFsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIF9vbGRPbmVycm9ySGFuZGxlciA9IF93aW5kb3cub25lcnJvcjtcbiAgICBfd2luZG93Lm9uZXJyb3IgPSB0cmFjZUtpdFdpbmRvd09uRXJyb3I7XG4gICAgX29uRXJyb3JIYW5kbGVySW5zdGFsbGVkID0gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVuaW5zdGFsbEdsb2JhbEhhbmRsZXIoKSB7XG4gICAgaWYgKCFfb25FcnJvckhhbmRsZXJJbnN0YWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgX3dpbmRvdy5vbmVycm9yID0gX29sZE9uZXJyb3JIYW5kbGVyO1xuICAgIF9vbkVycm9ySGFuZGxlckluc3RhbGxlZCA9IGZhbHNlO1xuICAgIF9vbGRPbmVycm9ySGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByb2Nlc3NMYXN0RXhjZXB0aW9uKCkge1xuICAgIHZhciBfbGFzdEV4Y2VwdGlvblN0YWNrID0gbGFzdEV4Y2VwdGlvblN0YWNrLFxuICAgICAgX2xhc3RBcmdzID0gbGFzdEFyZ3M7XG4gICAgbGFzdEFyZ3MgPSBudWxsO1xuICAgIGxhc3RFeGNlcHRpb25TdGFjayA9IG51bGw7XG4gICAgbGFzdEV4Y2VwdGlvbiA9IG51bGw7XG4gICAgbm90aWZ5SGFuZGxlcnMuYXBwbHkobnVsbCwgW19sYXN0RXhjZXB0aW9uU3RhY2ssIGZhbHNlXS5jb25jYXQoX2xhc3RBcmdzKSk7XG4gIH1cblxuICAvKipcbiAgICogUmVwb3J0cyBhbiB1bmhhbmRsZWQgRXJyb3IgdG8gVHJhY2VLaXQuXG4gICAqIEBwYXJhbSB7RXJyb3J9IGV4XG4gICAqIEBwYXJhbSB7P2Jvb2xlYW59IHJldGhyb3cgSWYgZmFsc2UsIGRvIG5vdCByZS10aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgKiBPbmx5IHVzZWQgZm9yIHdpbmRvdy5vbmVycm9yIHRvIG5vdCBjYXVzZSBhbiBpbmZpbml0ZSBsb29wIG9mXG4gICAqIHJldGhyb3dpbmcuXG4gICAqL1xuICBmdW5jdGlvbiByZXBvcnQoZXgsIHJldGhyb3cpIHtcbiAgICB2YXIgYXJncyA9IF9zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgaWYgKGxhc3RFeGNlcHRpb25TdGFjaykge1xuICAgICAgaWYgKGxhc3RFeGNlcHRpb24gPT09IGV4KSB7XG4gICAgICAgIHJldHVybjsgLy8gYWxyZWFkeSBjYXVnaHQgYnkgYW4gaW5uZXIgY2F0Y2ggYmxvY2ssIGlnbm9yZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzc0xhc3RFeGNlcHRpb24oKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgc3RhY2sgPSBUcmFjZUtpdC5jb21wdXRlU3RhY2tUcmFjZShleCk7XG4gICAgbGFzdEV4Y2VwdGlvblN0YWNrID0gc3RhY2s7XG4gICAgbGFzdEV4Y2VwdGlvbiA9IGV4O1xuICAgIGxhc3RBcmdzID0gYXJncztcblxuICAgIC8vIElmIHRoZSBzdGFjayB0cmFjZSBpcyBpbmNvbXBsZXRlLCB3YWl0IGZvciAyIHNlY29uZHMgZm9yXG4gICAgLy8gc2xvdyBzbG93IElFIHRvIHNlZSBpZiBvbmVycm9yIG9jY3VycyBvciBub3QgYmVmb3JlIHJlcG9ydGluZ1xuICAgIC8vIHRoaXMgZXhjZXB0aW9uOyBvdGhlcndpc2UsIHdlIHdpbGwgZW5kIHVwIHdpdGggYW4gaW5jb21wbGV0ZVxuICAgIC8vIHN0YWNrIHRyYWNlXG4gICAgc2V0VGltZW91dChcbiAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobGFzdEV4Y2VwdGlvbiA9PT0gZXgpIHtcbiAgICAgICAgICBwcm9jZXNzTGFzdEV4Y2VwdGlvbigpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc3RhY2suaW5jb21wbGV0ZSA/IDIwMDAgOiAwXG4gICAgKTtcblxuICAgIGlmIChyZXRocm93ICE9PSBmYWxzZSkge1xuICAgICAgdGhyb3cgZXg7IC8vIHJlLXRocm93IHRvIHByb3BhZ2F0ZSB0byB0aGUgdG9wIGxldmVsIChhbmQgY2F1c2Ugd2luZG93Lm9uZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgcmVwb3J0LnN1YnNjcmliZSA9IHN1YnNjcmliZTtcbiAgcmVwb3J0LnVuc3Vic2NyaWJlID0gdW5zdWJzY3JpYmU7XG4gIHJlcG9ydC51bmluc3RhbGwgPSB1bnN1YnNjcmliZUFsbDtcbiAgcmV0dXJuIHJlcG9ydDtcbn0pKCk7XG5cbi8qKlxuICogVHJhY2VLaXQuY29tcHV0ZVN0YWNrVHJhY2U6IGNyb3NzLWJyb3dzZXIgc3RhY2sgdHJhY2VzIGluIEphdmFTY3JpcHRcbiAqXG4gKiBTeW50YXg6XG4gKiAgIHMgPSBUcmFjZUtpdC5jb21wdXRlU3RhY2tUcmFjZShleGNlcHRpb24pIC8vIGNvbnNpZGVyIHVzaW5nIFRyYWNlS2l0LnJlcG9ydCBpbnN0ZWFkIChzZWUgYmVsb3cpXG4gKiBSZXR1cm5zOlxuICogICBzLm5hbWUgICAgICAgICAgICAgIC0gZXhjZXB0aW9uIG5hbWVcbiAqICAgcy5tZXNzYWdlICAgICAgICAgICAtIGV4Y2VwdGlvbiBtZXNzYWdlXG4gKiAgIHMuc3RhY2tbaV0udXJsICAgICAgLSBKYXZhU2NyaXB0IG9yIEhUTUwgZmlsZSBVUkxcbiAqICAgcy5zdGFja1tpXS5mdW5jICAgICAtIGZ1bmN0aW9uIG5hbWUsIG9yIGVtcHR5IGZvciBhbm9ueW1vdXMgZnVuY3Rpb25zIChpZiBndWVzc2luZyBkaWQgbm90IHdvcmspXG4gKiAgIHMuc3RhY2tbaV0uYXJncyAgICAgLSBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiwgaWYga25vd25cbiAqICAgcy5zdGFja1tpXS5saW5lICAgICAtIGxpbmUgbnVtYmVyLCBpZiBrbm93blxuICogICBzLnN0YWNrW2ldLmNvbHVtbiAgIC0gY29sdW1uIG51bWJlciwgaWYga25vd25cbiAqXG4gKiBTdXBwb3J0czpcbiAqICAgLSBGaXJlZm94OiAgZnVsbCBzdGFjayB0cmFjZSB3aXRoIGxpbmUgbnVtYmVycyBhbmQgdW5yZWxpYWJsZSBjb2x1bW5cbiAqICAgICAgICAgICAgICAgbnVtYmVyIG9uIHRvcCBmcmFtZVxuICogICAtIE9wZXJhIDEwOiBmdWxsIHN0YWNrIHRyYWNlIHdpdGggbGluZSBhbmQgY29sdW1uIG51bWJlcnNcbiAqICAgLSBPcGVyYSA5LTogZnVsbCBzdGFjayB0cmFjZSB3aXRoIGxpbmUgbnVtYmVyc1xuICogICAtIENocm9tZTogICBmdWxsIHN0YWNrIHRyYWNlIHdpdGggbGluZSBhbmQgY29sdW1uIG51bWJlcnNcbiAqICAgLSBTYWZhcmk6ICAgbGluZSBhbmQgY29sdW1uIG51bWJlciBmb3IgdGhlIHRvcG1vc3Qgc3RhY2t0cmFjZSBlbGVtZW50XG4gKiAgICAgICAgICAgICAgIG9ubHlcbiAqICAgLSBJRTogICAgICAgbm8gbGluZSBudW1iZXJzIHdoYXRzb2V2ZXJcbiAqXG4gKiBUcmllcyB0byBndWVzcyBuYW1lcyBvZiBhbm9ueW1vdXMgZnVuY3Rpb25zIGJ5IGxvb2tpbmcgZm9yIGFzc2lnbm1lbnRzXG4gKiBpbiB0aGUgc291cmNlIGNvZGUuIEluIElFIGFuZCBTYWZhcmksIHdlIGhhdmUgdG8gZ3Vlc3Mgc291cmNlIGZpbGUgbmFtZXNcbiAqIGJ5IHNlYXJjaGluZyBmb3IgZnVuY3Rpb24gYm9kaWVzIGluc2lkZSBhbGwgcGFnZSBzY3JpcHRzLiBUaGlzIHdpbGwgbm90XG4gKiB3b3JrIGZvciBzY3JpcHRzIHRoYXQgYXJlIGxvYWRlZCBjcm9zcy1kb21haW4uXG4gKiBIZXJlIGJlIGRyYWdvbnM6IHNvbWUgZnVuY3Rpb24gbmFtZXMgbWF5IGJlIGd1ZXNzZWQgaW5jb3JyZWN0bHksIGFuZFxuICogZHVwbGljYXRlIGZ1bmN0aW9ucyBtYXkgYmUgbWlzbWF0Y2hlZC5cbiAqXG4gKiBUcmFjZUtpdC5jb21wdXRlU3RhY2tUcmFjZSBzaG91bGQgb25seSBiZSB1c2VkIGZvciB0cmFjaW5nIHB1cnBvc2VzLlxuICogTG9nZ2luZyBvZiB1bmhhbmRsZWQgZXhjZXB0aW9ucyBzaG91bGQgYmUgZG9uZSB3aXRoIFRyYWNlS2l0LnJlcG9ydCxcbiAqIHdoaWNoIGJ1aWxkcyBvbiB0b3Agb2YgVHJhY2VLaXQuY29tcHV0ZVN0YWNrVHJhY2UgYW5kIHByb3ZpZGVzIGJldHRlclxuICogSUUgc3VwcG9ydCBieSB1dGlsaXppbmcgdGhlIHdpbmRvdy5vbmVycm9yIGV2ZW50IHRvIHJldHJpZXZlIGluZm9ybWF0aW9uXG4gKiBhYm91dCB0aGUgdG9wIG9mIHRoZSBzdGFjay5cbiAqXG4gKiBOb3RlOiBJbiBJRSBhbmQgU2FmYXJpLCBubyBzdGFjayB0cmFjZSBpcyByZWNvcmRlZCBvbiB0aGUgRXJyb3Igb2JqZWN0LFxuICogc28gY29tcHV0ZVN0YWNrVHJhY2UgaW5zdGVhZCB3YWxrcyBpdHMgKm93biogY2hhaW4gb2YgY2FsbGVycy5cbiAqIFRoaXMgbWVhbnMgdGhhdDpcbiAqICAqIGluIFNhZmFyaSwgc29tZSBtZXRob2RzIG1heSBiZSBtaXNzaW5nIGZyb20gdGhlIHN0YWNrIHRyYWNlO1xuICogICogaW4gSUUsIHRoZSB0b3Btb3N0IGZ1bmN0aW9uIGluIHRoZSBzdGFjayB0cmFjZSB3aWxsIGFsd2F5cyBiZSB0aGVcbiAqICAgIGNhbGxlciBvZiBjb21wdXRlU3RhY2tUcmFjZS5cbiAqXG4gKiBUaGlzIGlzIG9rYXkgZm9yIHRyYWNpbmcgKGJlY2F1c2UgeW91IGFyZSBsaWtlbHkgdG8gYmUgY2FsbGluZ1xuICogY29tcHV0ZVN0YWNrVHJhY2UgZnJvbSB0aGUgZnVuY3Rpb24geW91IHdhbnQgdG8gYmUgdGhlIHRvcG1vc3QgZWxlbWVudFxuICogb2YgdGhlIHN0YWNrIHRyYWNlIGFueXdheSksIGJ1dCBub3Qgb2theSBmb3IgbG9nZ2luZyB1bmhhbmRsZWRcbiAqIGV4Y2VwdGlvbnMgKGJlY2F1c2UgeW91ciBjYXRjaCBibG9jayB3aWxsIGxpa2VseSBiZSBmYXIgYXdheSBmcm9tIHRoZVxuICogaW5uZXIgZnVuY3Rpb24gdGhhdCBhY3R1YWxseSBjYXVzZWQgdGhlIGV4Y2VwdGlvbikuXG4gKlxuICovXG5UcmFjZUtpdC5jb21wdXRlU3RhY2tUcmFjZSA9IChmdW5jdGlvbiBjb21wdXRlU3RhY2tUcmFjZVdyYXBwZXIoKSB7XG4gIC8vIENvbnRlbnRzIG9mIEV4Y2VwdGlvbiBpbiB2YXJpb3VzIGJyb3dzZXJzLlxuICAvL1xuICAvLyBTQUZBUkk6XG4gIC8vIGV4Lm1lc3NhZ2UgPSBDYW4ndCBmaW5kIHZhcmlhYmxlOiBxcVxuICAvLyBleC5saW5lID0gNTlcbiAgLy8gZXguc291cmNlSWQgPSA1ODAyMzgxOTJcbiAgLy8gZXguc291cmNlVVJMID0gaHR0cDovLy4uLlxuICAvLyBleC5leHByZXNzaW9uQmVnaW5PZmZzZXQgPSA5NlxuICAvLyBleC5leHByZXNzaW9uQ2FyZXRPZmZzZXQgPSA5OFxuICAvLyBleC5leHByZXNzaW9uRW5kT2Zmc2V0ID0gOThcbiAgLy8gZXgubmFtZSA9IFJlZmVyZW5jZUVycm9yXG4gIC8vXG4gIC8vIEZJUkVGT1g6XG4gIC8vIGV4Lm1lc3NhZ2UgPSBxcSBpcyBub3QgZGVmaW5lZFxuICAvLyBleC5maWxlTmFtZSA9IGh0dHA6Ly8uLi5cbiAgLy8gZXgubGluZU51bWJlciA9IDU5XG4gIC8vIGV4LmNvbHVtbk51bWJlciA9IDY5XG4gIC8vIGV4LnN0YWNrID0gLi4uc3RhY2sgdHJhY2UuLi4gKHNlZSB0aGUgZXhhbXBsZSBiZWxvdylcbiAgLy8gZXgubmFtZSA9IFJlZmVyZW5jZUVycm9yXG4gIC8vXG4gIC8vIENIUk9NRTpcbiAgLy8gZXgubWVzc2FnZSA9IHFxIGlzIG5vdCBkZWZpbmVkXG4gIC8vIGV4Lm5hbWUgPSBSZWZlcmVuY2VFcnJvclxuICAvLyBleC50eXBlID0gbm90X2RlZmluZWRcbiAgLy8gZXguYXJndW1lbnRzID0gWydhYSddXG4gIC8vIGV4LnN0YWNrID0gLi4uc3RhY2sgdHJhY2UuLi5cbiAgLy9cbiAgLy8gSU5URVJORVQgRVhQTE9SRVI6XG4gIC8vIGV4Lm1lc3NhZ2UgPSAuLi5cbiAgLy8gZXgubmFtZSA9IFJlZmVyZW5jZUVycm9yXG4gIC8vXG4gIC8vIE9QRVJBOlxuICAvLyBleC5tZXNzYWdlID0gLi4ubWVzc2FnZS4uLiAoc2VlIHRoZSBleGFtcGxlIGJlbG93KVxuICAvLyBleC5uYW1lID0gUmVmZXJlbmNlRXJyb3JcbiAgLy8gZXgub3BlcmEjc291cmNlbG9jID0gMTEgIChwcmV0dHkgbXVjaCB1c2VsZXNzLCBkdXBsaWNhdGVzIHRoZSBpbmZvIGluIGV4Lm1lc3NhZ2UpXG4gIC8vIGV4LnN0YWNrdHJhY2UgPSBuL2E7IHNlZSAnb3BlcmE6Y29uZmlnI1VzZXJQcmVmc3xFeGNlcHRpb25zIEhhdmUgU3RhY2t0cmFjZSdcblxuICAvKipcbiAgICogQ29tcHV0ZXMgc3RhY2sgdHJhY2UgaW5mb3JtYXRpb24gZnJvbSB0aGUgc3RhY2sgcHJvcGVydHkuXG4gICAqIENocm9tZSBhbmQgR2Vja28gdXNlIHRoaXMgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7RXJyb3J9IGV4XG4gICAqIEByZXR1cm4gez9PYmplY3QuPHN0cmluZywgKj59IFN0YWNrIHRyYWNlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcHV0ZVN0YWNrVHJhY2VGcm9tU3RhY2tQcm9wKGV4KSB7XG4gICAgaWYgKHR5cGVvZiBleC5zdGFjayA9PT0gJ3VuZGVmaW5lZCcgfHwgIWV4LnN0YWNrKSByZXR1cm47XG5cbiAgICB2YXIgY2hyb21lID0gL15cXHMqYXQgKD86KC4qPykgP1xcKCk/KCg/OmZpbGV8aHR0cHM/fGJsb2J8Y2hyb21lLWV4dGVuc2lvbnxuYXRpdmV8ZXZhbHx3ZWJwYWNrfDxhbm9ueW1vdXM+fFthLXpdOnxcXC8pLio/KSg/OjooXFxkKykpPyg/OjooXFxkKykpP1xcKT9cXHMqJC9pO1xuICAgIHZhciB3aW5qcyA9IC9eXFxzKmF0ICg/OigoPzpcXFtvYmplY3Qgb2JqZWN0XFxdKT8uKykgKT9cXCg/KCg/OmZpbGV8bXMtYXBweCg/Oi13ZWIpfGh0dHBzP3x3ZWJwYWNrfGJsb2IpOi4qPyk6KFxcZCspKD86OihcXGQrKSk/XFwpP1xccyokL2k7XG4gICAgLy8gTk9URTogYmxvYiB1cmxzIGFyZSBub3cgc3VwcG9zZWQgdG8gYWx3YXlzIGhhdmUgYW4gb3JpZ2luLCB0aGVyZWZvcmUgaXQncyBmb3JtYXRcbiAgICAvLyB3aGljaCBpcyBgYmxvYjpodHRwOi8vdXJsL3BhdGgvd2l0aC1zb21lLXV1aWRgLCBpcyBtYXRjaGVkIGJ5IGBibG9iLio/OlxcL2AgYXMgd2VsbFxuICAgIHZhciBnZWNrbyA9IC9eXFxzKiguKj8pKD86XFwoKC4qPylcXCkpPyg/Ol58QCkoKD86ZmlsZXxodHRwcz98YmxvYnxjaHJvbWV8d2VicGFja3xyZXNvdXJjZXxtb3otZXh0ZW5zaW9uKS4qPzpcXC8uKj98XFxbbmF0aXZlIGNvZGVcXF18W15AXSooPzpidW5kbGV8XFxkK1xcLmpzKSkoPzo6KFxcZCspKT8oPzo6KFxcZCspKT9cXHMqJC9pO1xuICAgIC8vIFVzZWQgdG8gYWRkaXRpb25hbGx5IHBhcnNlIFVSTC9saW5lL2NvbHVtbiBmcm9tIGV2YWwgZnJhbWVzXG4gICAgdmFyIGdlY2tvRXZhbCA9IC8oXFxTKykgbGluZSAoXFxkKykoPzogPiBldmFsIGxpbmUgXFxkKykqID4gZXZhbC9pO1xuICAgIHZhciBjaHJvbWVFdmFsID0gL1xcKChcXFMqKSg/OjooXFxkKykpKD86OihcXGQrKSlcXCkvO1xuICAgIHZhciBsaW5lcyA9IGV4LnN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgc3RhY2sgPSBbXTtcbiAgICB2YXIgc3VibWF0Y2g7XG4gICAgdmFyIHBhcnRzO1xuICAgIHZhciBlbGVtZW50O1xuICAgIHZhciByZWZlcmVuY2UgPSAvXiguKikgaXMgdW5kZWZpbmVkJC8uZXhlYyhleC5tZXNzYWdlKTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBqID0gbGluZXMubGVuZ3RoOyBpIDwgajsgKytpKSB7XG4gICAgICBpZiAoKHBhcnRzID0gY2hyb21lLmV4ZWMobGluZXNbaV0pKSkge1xuICAgICAgICB2YXIgaXNOYXRpdmUgPSBwYXJ0c1syXSAmJiBwYXJ0c1syXS5pbmRleE9mKCduYXRpdmUnKSA9PT0gMDsgLy8gc3RhcnQgb2YgbGluZVxuICAgICAgICB2YXIgaXNFdmFsID0gcGFydHNbMl0gJiYgcGFydHNbMl0uaW5kZXhPZignZXZhbCcpID09PSAwOyAvLyBzdGFydCBvZiBsaW5lXG4gICAgICAgIGlmIChpc0V2YWwgJiYgKHN1Ym1hdGNoID0gY2hyb21lRXZhbC5leGVjKHBhcnRzWzJdKSkpIHtcbiAgICAgICAgICAvLyB0aHJvdyBvdXQgZXZhbCBsaW5lL2NvbHVtbiBhbmQgdXNlIHRvcC1tb3N0IGxpbmUvY29sdW1uIG51bWJlclxuICAgICAgICAgIHBhcnRzWzJdID0gc3VibWF0Y2hbMV07IC8vIHVybFxuICAgICAgICAgIHBhcnRzWzNdID0gc3VibWF0Y2hbMl07IC8vIGxpbmVcbiAgICAgICAgICBwYXJ0c1s0XSA9IHN1Ym1hdGNoWzNdOyAvLyBjb2x1bW5cbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50ID0ge1xuICAgICAgICAgIHVybDogIWlzTmF0aXZlID8gcGFydHNbMl0gOiBudWxsLFxuICAgICAgICAgIGZ1bmM6IHBhcnRzWzFdIHx8IFVOS05PV05fRlVOQ1RJT04sXG4gICAgICAgICAgYXJnczogaXNOYXRpdmUgPyBbcGFydHNbMl1dIDogW10sXG4gICAgICAgICAgbGluZTogcGFydHNbM10gPyArcGFydHNbM10gOiBudWxsLFxuICAgICAgICAgIGNvbHVtbjogcGFydHNbNF0gPyArcGFydHNbNF0gOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKChwYXJ0cyA9IHdpbmpzLmV4ZWMobGluZXNbaV0pKSkge1xuICAgICAgICBlbGVtZW50ID0ge1xuICAgICAgICAgIHVybDogcGFydHNbMl0sXG4gICAgICAgICAgZnVuYzogcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTixcbiAgICAgICAgICBhcmdzOiBbXSxcbiAgICAgICAgICBsaW5lOiArcGFydHNbM10sXG4gICAgICAgICAgY29sdW1uOiBwYXJ0c1s0XSA/ICtwYXJ0c1s0XSA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoKHBhcnRzID0gZ2Vja28uZXhlYyhsaW5lc1tpXSkpKSB7XG4gICAgICAgIHZhciBpc0V2YWwgPSBwYXJ0c1szXSAmJiBwYXJ0c1szXS5pbmRleE9mKCcgPiBldmFsJykgPiAtMTtcbiAgICAgICAgaWYgKGlzRXZhbCAmJiAoc3VibWF0Y2ggPSBnZWNrb0V2YWwuZXhlYyhwYXJ0c1szXSkpKSB7XG4gICAgICAgICAgLy8gdGhyb3cgb3V0IGV2YWwgbGluZS9jb2x1bW4gYW5kIHVzZSB0b3AtbW9zdCBsaW5lIG51bWJlclxuICAgICAgICAgIHBhcnRzWzNdID0gc3VibWF0Y2hbMV07XG4gICAgICAgICAgcGFydHNbNF0gPSBzdWJtYXRjaFsyXTtcbiAgICAgICAgICBwYXJ0c1s1XSA9IG51bGw7IC8vIG5vIGNvbHVtbiB3aGVuIGV2YWxcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSAwICYmICFwYXJ0c1s1XSAmJiB0eXBlb2YgZXguY29sdW1uTnVtYmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIEZpcmVGb3ggdXNlcyB0aGlzIGF3ZXNvbWUgY29sdW1uTnVtYmVyIHByb3BlcnR5IGZvciBpdHMgdG9wIGZyYW1lXG4gICAgICAgICAgLy8gQWxzbyBub3RlLCBGaXJlZm94J3MgY29sdW1uIG51bWJlciBpcyAwLWJhc2VkIGFuZCBldmVyeXRoaW5nIGVsc2UgZXhwZWN0cyAxLWJhc2VkLFxuICAgICAgICAgIC8vIHNvIGFkZGluZyAxXG4gICAgICAgICAgLy8gTk9URTogdGhpcyBoYWNrIGRvZXNuJ3Qgd29yayBpZiB0b3AtbW9zdCBmcmFtZSBpcyBldmFsXG4gICAgICAgICAgc3RhY2tbMF0uY29sdW1uID0gZXguY29sdW1uTnVtYmVyICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50ID0ge1xuICAgICAgICAgIHVybDogcGFydHNbM10sXG4gICAgICAgICAgZnVuYzogcGFydHNbMV0gfHwgVU5LTk9XTl9GVU5DVElPTixcbiAgICAgICAgICBhcmdzOiBwYXJ0c1syXSA/IHBhcnRzWzJdLnNwbGl0KCcsJykgOiBbXSxcbiAgICAgICAgICBsaW5lOiBwYXJ0c1s0XSA/ICtwYXJ0c1s0XSA6IG51bGwsXG4gICAgICAgICAgY29sdW1uOiBwYXJ0c1s1XSA/ICtwYXJ0c1s1XSA6IG51bGxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIWVsZW1lbnQuZnVuYyAmJiBlbGVtZW50LmxpbmUpIHtcbiAgICAgICAgZWxlbWVudC5mdW5jID0gVU5LTk9XTl9GVU5DVElPTjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQudXJsICYmIGVsZW1lbnQudXJsLnN1YnN0cigwLCA1KSA9PT0gJ2Jsb2I6Jykge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGhhbmRsaW5nIEphdmFTY3JpcHQgbG9hZGVkIGludG8gYSBibG9iLlxuICAgICAgICAvLyBXZSB1c2UgYSBzeW5jaHJvbm91cyBBSkFYIHJlcXVlc3QgaGVyZSBhcyBhIGJsb2IgaXMgYWxyZWFkeSBpblxuICAgICAgICAvLyBtZW1vcnkgLSBpdCdzIG5vdCBtYWtpbmcgYSBuZXR3b3JrIHJlcXVlc3QuICBUaGlzIHdpbGwgZ2VuZXJhdGUgYSB3YXJuaW5nXG4gICAgICAgIC8vIGluIHRoZSBicm93c2VyIGNvbnNvbGUsIGJ1dCB0aGVyZSBoYXMgYWxyZWFkeSBiZWVuIGFuIGVycm9yIHNvIHRoYXQncyBub3RcbiAgICAgICAgLy8gdGhhdCBtdWNoIG9mIGFuIGlzc3VlLlxuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBlbGVtZW50LnVybCwgZmFsc2UpO1xuICAgICAgICB4aHIuc2VuZChudWxsKTtcblxuICAgICAgICAvLyBJZiB3ZSBmYWlsZWQgdG8gZG93bmxvYWQgdGhlIHNvdXJjZSwgc2tpcCB0aGlzIHBhdGNoXG4gICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICB2YXIgc291cmNlID0geGhyLnJlc3BvbnNlVGV4dCB8fCAnJztcblxuICAgICAgICAgIC8vIFdlIHRyaW0gdGhlIHNvdXJjZSBkb3duIHRvIHRoZSBsYXN0IDMwMCBjaGFyYWN0ZXJzIGFzIHNvdXJjZU1hcHBpbmdVUkwgaXMgYWx3YXlzIGF0IHRoZSBlbmQgb2YgdGhlIGZpbGUuXG4gICAgICAgICAgLy8gV2h5IDMwMD8gVG8gYmUgaW4gbGluZSB3aXRoOiBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3NlbnRyeS9ibG9iLzRhZjI5ZThmMjM1MGUyMGMyOGE2OTMzMzU0ZTRmNDI0MzdiNGJhNDIvc3JjL3NlbnRyeS9sYW5nL2phdmFzY3JpcHQvcHJvY2Vzc29yLnB5I0wxNjQtTDE3NVxuICAgICAgICAgIHNvdXJjZSA9IHNvdXJjZS5zbGljZSgtMzAwKTtcblxuICAgICAgICAgIC8vIE5vdyB3ZSBkaWcgb3V0IHRoZSBzb3VyY2UgbWFwIFVSTFxuICAgICAgICAgIHZhciBzb3VyY2VNYXBzID0gc291cmNlLm1hdGNoKC9cXC9cXC8jIHNvdXJjZU1hcHBpbmdVUkw9KC4qKSQvKTtcblxuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGZpbmQgYSBzb3VyY2UgbWFwIGNvbW1lbnQgb3Igd2UgZmluZCBtb3JlIHRoYW4gb25lLCBjb250aW51ZSBvbiB0byB0aGUgbmV4dCBlbGVtZW50LlxuICAgICAgICAgIGlmIChzb3VyY2VNYXBzKSB7XG4gICAgICAgICAgICB2YXIgc291cmNlTWFwQWRkcmVzcyA9IHNvdXJjZU1hcHNbMV07XG5cbiAgICAgICAgICAgIC8vIE5vdyB3ZSBjaGVjayB0byBzZWUgaWYgaXQncyBhIHJlbGF0aXZlIFVSTC5cbiAgICAgICAgICAgIC8vIElmIGl0IGlzLCBjb252ZXJ0IGl0IHRvIGFuIGFic29sdXRlIG9uZS5cbiAgICAgICAgICAgIGlmIChzb3VyY2VNYXBBZGRyZXNzLmNoYXJBdCgwKSA9PT0gJ34nKSB7XG4gICAgICAgICAgICAgIHNvdXJjZU1hcEFkZHJlc3MgPSBnZXRMb2NhdGlvbk9yaWdpbigpICsgc291cmNlTWFwQWRkcmVzcy5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTm93IHdlIHN0cmlwIHRoZSAnLm1hcCcgb2ZmIG9mIHRoZSBlbmQgb2YgdGhlIFVSTCBhbmQgdXBkYXRlIHRoZVxuICAgICAgICAgICAgLy8gZWxlbWVudCBzbyB0aGF0IFNlbnRyeSBjYW4gbWF0Y2ggdGhlIG1hcCB0byB0aGUgYmxvYi5cbiAgICAgICAgICAgIGVsZW1lbnQudXJsID0gc291cmNlTWFwQWRkcmVzcy5zbGljZSgwLCAtNCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YWNrLnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBleC5uYW1lLFxuICAgICAgbWVzc2FnZTogZXgubWVzc2FnZSxcbiAgICAgIHVybDogZ2V0TG9jYXRpb25IcmVmKCksXG4gICAgICBzdGFjazogc3RhY2tcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGZpcnN0IGZyYW1lIHRvIGluY29tcGxldGUgc3RhY2sgdHJhY2VzLlxuICAgKiBTYWZhcmkgYW5kIElFIHJlcXVpcmUgdGhpcyB0byBnZXQgY29tcGxldGUgZGF0YSBvbiB0aGUgZmlyc3QgZnJhbWUuXG4gICAqIEBwYXJhbSB7T2JqZWN0LjxzdHJpbmcsICo+fSBzdGFja0luZm8gU3RhY2sgdHJhY2UgaW5mb3JtYXRpb24gZnJvbVxuICAgKiBvbmUgb2YgdGhlIGNvbXB1dGUqIG1ldGhvZHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCBvZiB0aGUgc2NyaXB0IHRoYXQgY2F1c2VkIGFuIGVycm9yLlxuICAgKiBAcGFyYW0geyhudW1iZXJ8c3RyaW5nKX0gbGluZU5vIFRoZSBsaW5lIG51bWJlciBvZiB0aGUgc2NyaXB0IHRoYXRcbiAgICogY2F1c2VkIGFuIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIGVycm9yIGdlbmVyYXRlZCBieSB0aGUgYnJvd3Nlciwgd2hpY2hcbiAgICogaG9wZWZ1bGx5IGNvbnRhaW5zIHRoZSBuYW1lIG9mIHRoZSBvYmplY3QgdGhhdCBjYXVzZWQgdGhlIGVycm9yLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgc3RhY2sgaW5mb3JtYXRpb24gd2FzXG4gICAqIGF1Z21lbnRlZC5cbiAgICovXG4gIGZ1bmN0aW9uIGF1Z21lbnRTdGFja1RyYWNlV2l0aEluaXRpYWxFbGVtZW50KHN0YWNrSW5mbywgdXJsLCBsaW5lTm8sIG1lc3NhZ2UpIHtcbiAgICB2YXIgaW5pdGlhbCA9IHtcbiAgICAgIHVybDogdXJsLFxuICAgICAgbGluZTogbGluZU5vXG4gICAgfTtcblxuICAgIGlmIChpbml0aWFsLnVybCAmJiBpbml0aWFsLmxpbmUpIHtcbiAgICAgIHN0YWNrSW5mby5pbmNvbXBsZXRlID0gZmFsc2U7XG5cbiAgICAgIGlmICghaW5pdGlhbC5mdW5jKSB7XG4gICAgICAgIGluaXRpYWwuZnVuYyA9IFVOS05PV05fRlVOQ1RJT047XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFja0luZm8uc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoc3RhY2tJbmZvLnN0YWNrWzBdLnVybCA9PT0gaW5pdGlhbC51cmwpIHtcbiAgICAgICAgICBpZiAoc3RhY2tJbmZvLnN0YWNrWzBdLmxpbmUgPT09IGluaXRpYWwubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBhbHJlYWR5IGluIHN0YWNrIHRyYWNlXG4gICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICFzdGFja0luZm8uc3RhY2tbMF0ubGluZSAmJlxuICAgICAgICAgICAgc3RhY2tJbmZvLnN0YWNrWzBdLmZ1bmMgPT09IGluaXRpYWwuZnVuY1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgc3RhY2tJbmZvLnN0YWNrWzBdLmxpbmUgPSBpbml0aWFsLmxpbmU7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0YWNrSW5mby5zdGFjay51bnNoaWZ0KGluaXRpYWwpO1xuICAgICAgc3RhY2tJbmZvLnBhcnRpYWwgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrSW5mby5pbmNvbXBsZXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgc3RhY2sgdHJhY2UgaW5mb3JtYXRpb24gYnkgd2Fsa2luZyB0aGUgYXJndW1lbnRzLmNhbGxlclxuICAgKiBjaGFpbiBhdCB0aGUgdGltZSB0aGUgZXhjZXB0aW9uIG9jY3VycmVkLiBUaGlzIHdpbGwgY2F1c2UgZWFybGllclxuICAgKiBmcmFtZXMgdG8gYmUgbWlzc2VkIGJ1dCBpcyB0aGUgb25seSB3YXkgdG8gZ2V0IGFueSBzdGFjayB0cmFjZSBpblxuICAgKiBTYWZhcmkgYW5kIElFLiBUaGUgdG9wIGZyYW1lIGlzIHJlc3RvcmVkIGJ5XG4gICAqIHtAbGluayBhdWdtZW50U3RhY2tUcmFjZVdpdGhJbml0aWFsRWxlbWVudH0uXG4gICAqIEBwYXJhbSB7RXJyb3J9IGV4XG4gICAqIEByZXR1cm4gez9PYmplY3QuPHN0cmluZywgKj59IFN0YWNrIHRyYWNlIGluZm9ybWF0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY29tcHV0ZVN0YWNrVHJhY2VCeVdhbGtpbmdDYWxsZXJDaGFpbihleCwgZGVwdGgpIHtcbiAgICB2YXIgZnVuY3Rpb25OYW1lID0gL2Z1bmN0aW9uXFxzKyhbXyRhLXpBLVpcXHhBMC1cXHVGRkZGXVtfJGEtekEtWjAtOVxceEEwLVxcdUZGRkZdKik/XFxzKlxcKC9pLFxuICAgICAgc3RhY2sgPSBbXSxcbiAgICAgIGZ1bmNzID0ge30sXG4gICAgICByZWN1cnNpb24gPSBmYWxzZSxcbiAgICAgIHBhcnRzLFxuICAgICAgaXRlbSxcbiAgICAgIHNvdXJjZTtcblxuICAgIGZvciAoXG4gICAgICB2YXIgY3VyciA9IGNvbXB1dGVTdGFja1RyYWNlQnlXYWxraW5nQ2FsbGVyQ2hhaW4uY2FsbGVyO1xuICAgICAgY3VyciAmJiAhcmVjdXJzaW9uO1xuICAgICAgY3VyciA9IGN1cnIuY2FsbGVyXG4gICAgKSB7XG4gICAgICBpZiAoY3VyciA9PT0gY29tcHV0ZVN0YWNrVHJhY2UgfHwgY3VyciA9PT0gVHJhY2VLaXQucmVwb3J0KSB7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdza2lwcGluZyBpbnRlcm5hbCBmdW5jdGlvbicpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdXJsOiBudWxsLFxuICAgICAgICBmdW5jOiBVTktOT1dOX0ZVTkNUSU9OLFxuICAgICAgICBsaW5lOiBudWxsLFxuICAgICAgICBjb2x1bW46IG51bGxcbiAgICAgIH07XG5cbiAgICAgIGlmIChjdXJyLm5hbWUpIHtcbiAgICAgICAgaXRlbS5mdW5jID0gY3Vyci5uYW1lO1xuICAgICAgfSBlbHNlIGlmICgocGFydHMgPSBmdW5jdGlvbk5hbWUuZXhlYyhjdXJyLnRvU3RyaW5nKCkpKSkge1xuICAgICAgICBpdGVtLmZ1bmMgPSBwYXJ0c1sxXTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpdGVtLmZ1bmMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaXRlbS5mdW5jID0gcGFydHMuaW5wdXQuc3Vic3RyaW5nKDAsIHBhcnRzLmlucHV0LmluZGV4T2YoJ3snKSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICB9XG5cbiAgICAgIGlmIChmdW5jc1snJyArIGN1cnJdKSB7XG4gICAgICAgIHJlY3Vyc2lvbiA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmdW5jc1snJyArIGN1cnJdID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgc3RhY2sucHVzaChpdGVtKTtcbiAgICB9XG5cbiAgICBpZiAoZGVwdGgpIHtcbiAgICAgIC8vIGNvbnNvbGUubG9nKCdkZXB0aCBpcyAnICsgZGVwdGgpO1xuICAgICAgLy8gY29uc29sZS5sb2coJ3N0YWNrIGlzICcgKyBzdGFjay5sZW5ndGgpO1xuICAgICAgc3RhY2suc3BsaWNlKDAsIGRlcHRoKTtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgbmFtZTogZXgubmFtZSxcbiAgICAgIG1lc3NhZ2U6IGV4Lm1lc3NhZ2UsXG4gICAgICB1cmw6IGdldExvY2F0aW9uSHJlZigpLFxuICAgICAgc3RhY2s6IHN0YWNrXG4gICAgfTtcbiAgICBhdWdtZW50U3RhY2tUcmFjZVdpdGhJbml0aWFsRWxlbWVudChcbiAgICAgIHJlc3VsdCxcbiAgICAgIGV4LnNvdXJjZVVSTCB8fCBleC5maWxlTmFtZSxcbiAgICAgIGV4LmxpbmUgfHwgZXgubGluZU51bWJlcixcbiAgICAgIGV4Lm1lc3NhZ2UgfHwgZXguZGVzY3JpcHRpb25cbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgYSBzdGFjayB0cmFjZSBmb3IgYW4gZXhjZXB0aW9uLlxuICAgKiBAcGFyYW0ge0Vycm9yfSBleFxuICAgKiBAcGFyYW0geyhzdHJpbmd8bnVtYmVyKT19IGRlcHRoXG4gICAqL1xuICBmdW5jdGlvbiBjb21wdXRlU3RhY2tUcmFjZShleCwgZGVwdGgpIHtcbiAgICB2YXIgc3RhY2sgPSBudWxsO1xuICAgIGRlcHRoID0gZGVwdGggPT0gbnVsbCA/IDAgOiArZGVwdGg7XG5cbiAgICB0cnkge1xuICAgICAgc3RhY2sgPSBjb21wdXRlU3RhY2tUcmFjZUZyb21TdGFja1Byb3AoZXgpO1xuICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoVHJhY2VLaXQuZGVidWcpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgc3RhY2sgPSBjb21wdXRlU3RhY2tUcmFjZUJ5V2Fsa2luZ0NhbGxlckNoYWluKGV4LCBkZXB0aCArIDEpO1xuICAgICAgaWYgKHN0YWNrKSB7XG4gICAgICAgIHJldHVybiBzdGFjaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoVHJhY2VLaXQuZGVidWcpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IGV4Lm5hbWUsXG4gICAgICBtZXNzYWdlOiBleC5tZXNzYWdlLFxuICAgICAgdXJsOiBnZXRMb2NhdGlvbkhyZWYoKVxuICAgIH07XG4gIH1cblxuICBjb21wdXRlU3RhY2tUcmFjZS5hdWdtZW50U3RhY2tUcmFjZVdpdGhJbml0aWFsRWxlbWVudCA9IGF1Z21lbnRTdGFja1RyYWNlV2l0aEluaXRpYWxFbGVtZW50O1xuICBjb21wdXRlU3RhY2tUcmFjZS5jb21wdXRlU3RhY2tUcmFjZUZyb21TdGFja1Byb3AgPSBjb21wdXRlU3RhY2tUcmFjZUZyb21TdGFja1Byb3A7XG5cbiAgcmV0dXJuIGNvbXB1dGVTdGFja1RyYWNlO1xufSkoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFjZUtpdDtcbiIsIi8qXG4ganNvbi1zdHJpbmdpZnktc2FmZVxuIExpa2UgSlNPTi5zdHJpbmdpZnksIGJ1dCBkb2Vzbid0IHRocm93IG9uIGNpcmN1bGFyIHJlZmVyZW5jZXMuXG5cbiBPcmlnaW5hbGx5IGZvcmtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvanNvbi1zdHJpbmdpZnktc2FmZVxuIHZlcnNpb24gNS4wLjEgb24gMy84LzIwMTcgYW5kIG1vZGlmaWVkIHRvIGhhbmRsZSBFcnJvcnMgc2VyaWFsaXphdGlvblxuIGFuZCBJRTggY29tcGF0aWJpbGl0eS4gVGVzdHMgZm9yIHRoaXMgYXJlIGluIHRlc3QvdmVuZG9yLlxuXG4gSVNDIGxpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9pc2FhY3MvanNvbi1zdHJpbmdpZnktc2FmZS9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdpZnk7XG5leHBvcnRzLmdldFNlcmlhbGl6ZSA9IHNlcmlhbGl6ZXI7XG5cbmZ1bmN0aW9uIGluZGV4T2YoaGF5c3RhY2ssIG5lZWRsZSkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGhheXN0YWNrLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKGhheXN0YWNrW2ldID09PSBuZWVkbGUpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcywgY3ljbGVSZXBsYWNlcikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBzZXJpYWxpemVyKHJlcGxhY2VyLCBjeWNsZVJlcGxhY2VyKSwgc3BhY2VzKTtcbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Z0bGFicy9qcy1hYmJyZXZpYXRlL2Jsb2IvZmE3MDllNWYxMzllNzc3MGE3MTgyN2IxODkzZjIyNDE4MDk3ZmJkYS9pbmRleC5qcyNMOTUtTDEwNlxuZnVuY3Rpb24gc3RyaW5naWZ5RXJyb3IodmFsdWUpIHtcbiAgdmFyIGVyciA9IHtcbiAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBpbXBsZW1lbnRlZCBhcyBtYWdpY2FsIGdldHRlcnMgYW5kIGRvbid0IHNob3cgdXAgaW4gZm9yIGluXG4gICAgc3RhY2s6IHZhbHVlLnN0YWNrLFxuICAgIG1lc3NhZ2U6IHZhbHVlLm1lc3NhZ2UsXG4gICAgbmFtZTogdmFsdWUubmFtZVxuICB9O1xuXG4gIGZvciAodmFyIGkgaW4gdmFsdWUpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBpKSkge1xuICAgICAgZXJyW2ldID0gdmFsdWVbaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVycjtcbn1cblxuZnVuY3Rpb24gc2VyaWFsaXplcihyZXBsYWNlciwgY3ljbGVSZXBsYWNlcikge1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIGtleXMgPSBbXTtcblxuICBpZiAoY3ljbGVSZXBsYWNlciA9PSBudWxsKSB7XG4gICAgY3ljbGVSZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmIChzdGFja1swXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXIgfl0nO1xuICAgICAgfVxuICAgICAgcmV0dXJuICdbQ2lyY3VsYXIgfi4nICsga2V5cy5zbGljZSgwLCBpbmRleE9mKHN0YWNrLCB2YWx1ZSkpLmpvaW4oJy4nKSArICddJztcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgdmFyIHRoaXNQb3MgPSBpbmRleE9mKHN0YWNrLCB0aGlzKTtcbiAgICAgIH50aGlzUG9zID8gc3RhY2suc3BsaWNlKHRoaXNQb3MgKyAxKSA6IHN0YWNrLnB1c2godGhpcyk7XG4gICAgICB+dGhpc1BvcyA/IGtleXMuc3BsaWNlKHRoaXNQb3MsIEluZmluaXR5LCBrZXkpIDoga2V5cy5wdXNoKGtleSk7XG5cbiAgICAgIGlmICh+aW5kZXhPZihzdGFjaywgdmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gY3ljbGVSZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVwbGFjZXIgPT0gbnVsbFxuICAgICAgPyB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yID8gc3RyaW5naWZ5RXJyb3IodmFsdWUpIDogdmFsdWVcbiAgICAgIDogcmVwbGFjZXIuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgfTtcbn1cbiIsIi8qXG4gKiBKYXZhU2NyaXB0IE1ENVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb25cbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuXG4vKlxuKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4qIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4qL1xuZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gIHZhciBsc3cgPSAoeCAmIDB4ZmZmZikgKyAoeSAmIDB4ZmZmZik7XG4gIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KTtcbiAgcmV0dXJuIChtc3cgPDwgMTYpIHwgKGxzdyAmIDB4ZmZmZik7XG59XG5cbi8qXG4qIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiovXG5mdW5jdGlvbiBiaXRSb3RhdGVMZWZ0KG51bSwgY250KSB7XG4gIHJldHVybiAobnVtIDw8IGNudCkgfCAobnVtID4+PiAoMzIgLSBjbnQpKTtcbn1cblxuLypcbiogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiovXG5mdW5jdGlvbiBtZDVjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICByZXR1cm4gc2FmZUFkZChiaXRSb3RhdGVMZWZ0KHNhZmVBZGQoc2FmZUFkZChhLCBxKSwgc2FmZUFkZCh4LCB0KSksIHMpLCBiKTtcbn1cbmZ1bmN0aW9uIG1kNWZmKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbigoYiAmIGMpIHwgKH5iICYgZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuZnVuY3Rpb24gbWQ1Z2coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKChiICYgZCkgfCAoYyAmIH5kKSwgYSwgYiwgeCwgcywgdCk7XG59XG5mdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cbmZ1bmN0aW9uIG1kNWlpKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihjIF4gKGIgfCB+ZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG4vKlxuKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuKi9cbmZ1bmN0aW9uIGJpbmxNRDUoeCwgbGVuKSB7XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKGxlbiAlIDMyKTtcbiAgeFsoKChsZW4gKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbGVuO1xuXG4gIHZhciBpO1xuICB2YXIgb2xkYTtcbiAgdmFyIG9sZGI7XG4gIHZhciBvbGRjO1xuICB2YXIgb2xkZDtcbiAgdmFyIGEgPSAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gMjcxNzMzODc4O1xuXG4gIGZvciAoaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuICAgIG9sZGEgPSBhO1xuICAgIG9sZGIgPSBiO1xuICAgIG9sZGMgPSBjO1xuICAgIG9sZGQgPSBkO1xuXG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcblxuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNSwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDZdLCA5LCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaV0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgNV0sIDUsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxMF0sIDksIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDldLCA1LCA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sIDksIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgOF0sIDIwLCAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCA1LCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDJdLCA5LCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTQsIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG5cbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgNV0sIDQsIC0zNzg1NTgpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTFdLCAxNiwgMTgzOTAzMDU2Mik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDE0XSwgMjMsIC0zNTMwOTU1Nik7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA0LCAtMTUzMDk5MjA2MCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDRdLCAxMSwgMTI3Mjg5MzM1Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDddLCAxNiwgLTE1NTQ5NzYzMik7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMTNdLCA0LCA2ODEyNzkxNzQpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2ldLCAxMSwgLTM1ODUzNzIyMik7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNiwgLTcyMjUyMTk3OSk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDZdLCAyMywgNzYwMjkxODkpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNCwgLTY0MDM2NDQ4Nyk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDEyXSwgMTEsIC00MjE4MTU4MzUpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxNV0sIDE2LCA1MzA3NDI1MjApO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xuXG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuXG4gICAgYSA9IHNhZmVBZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVBZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVBZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVBZGQoZCwgb2xkZCk7XG4gIH1cbiAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbn1cblxuLypcbiogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGEgc3RyaW5nXG4qL1xuZnVuY3Rpb24gYmlubDJyc3RyKGlucHV0KSB7XG4gIHZhciBpO1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciBsZW5ndGgzMiA9IGlucHV0Lmxlbmd0aCAqIDMyO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoMzI7IGkgKz0gOCkge1xuICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnB1dFtpID4+IDVdID4+PiAoaSAlIDMyKSkgJiAweGZmKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzXG4qIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuKi9cbmZ1bmN0aW9uIHJzdHIyYmlubChpbnB1dCkge1xuICB2YXIgaTtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBvdXRwdXRbKGlucHV0Lmxlbmd0aCA+PiAyKSAtIDFdID0gdW5kZWZpbmVkO1xuICBmb3IgKGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgb3V0cHV0W2ldID0gMDtcbiAgfVxuICB2YXIgbGVuZ3RoOCA9IGlucHV0Lmxlbmd0aCAqIDg7XG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg4OyBpICs9IDgpIHtcbiAgICBvdXRwdXRbaSA+PiA1XSB8PSAoaW5wdXQuY2hhckNvZGVBdChpIC8gOCkgJiAweGZmKSA8PCAoaSAlIDMyKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhIHJhdyBzdHJpbmdcbiovXG5mdW5jdGlvbiByc3RyTUQ1KHMpIHtcbiAgcmV0dXJuIGJpbmwycnN0cihiaW5sTUQ1KHJzdHIyYmlubChzKSwgcy5sZW5ndGggKiA4KSk7XG59XG5cbi8qXG4qIENhbGN1bGF0ZSB0aGUgSE1BQy1NRDUsIG9mIGEga2V5IGFuZCBzb21lIGRhdGEgKHJhdyBzdHJpbmdzKVxuKi9cbmZ1bmN0aW9uIHJzdHJITUFDTUQ1KGtleSwgZGF0YSkge1xuICB2YXIgaTtcbiAgdmFyIGJrZXkgPSByc3RyMmJpbmwoa2V5KTtcbiAgdmFyIGlwYWQgPSBbXTtcbiAgdmFyIG9wYWQgPSBbXTtcbiAgdmFyIGhhc2g7XG4gIGlwYWRbMTVdID0gb3BhZFsxNV0gPSB1bmRlZmluZWQ7XG4gIGlmIChia2V5Lmxlbmd0aCA+IDE2KSB7XG4gICAgYmtleSA9IGJpbmxNRDUoYmtleSwga2V5Lmxlbmd0aCAqIDgpO1xuICB9XG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgaXBhZFtpXSA9IGJrZXlbaV0gXiAweDM2MzYzNjM2O1xuICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1YzVjNWM1YztcbiAgfVxuICBoYXNoID0gYmlubE1ENShpcGFkLmNvbmNhdChyc3RyMmJpbmwoZGF0YSkpLCA1MTIgKyBkYXRhLmxlbmd0aCAqIDgpO1xuICByZXR1cm4gYmlubDJyc3RyKGJpbmxNRDUob3BhZC5jb25jYXQoaGFzaCksIDUxMiArIDEyOCkpO1xufVxuXG4vKlxuKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhIGhleCBzdHJpbmdcbiovXG5mdW5jdGlvbiByc3RyMmhleChpbnB1dCkge1xuICB2YXIgaGV4VGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuICB2YXIgb3V0cHV0ID0gJyc7XG4gIHZhciB4O1xuICB2YXIgaTtcbiAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSArPSAxKSB7XG4gICAgeCA9IGlucHV0LmNoYXJDb2RlQXQoaSk7XG4gICAgb3V0cHV0ICs9IGhleFRhYi5jaGFyQXQoKHggPj4+IDQpICYgMHgwZikgKyBoZXhUYWIuY2hhckF0KHggJiAweDBmKTtcbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufVxuXG4vKlxuKiBFbmNvZGUgYSBzdHJpbmcgYXMgdXRmLThcbiovXG5mdW5jdGlvbiBzdHIycnN0clVURjgoaW5wdXQpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCkpO1xufVxuXG4vKlxuKiBUYWtlIHN0cmluZyBhcmd1bWVudHMgYW5kIHJldHVybiBlaXRoZXIgcmF3IG9yIGhleCBlbmNvZGVkIHN0cmluZ3NcbiovXG5mdW5jdGlvbiByYXdNRDUocykge1xuICByZXR1cm4gcnN0ck1ENShzdHIycnN0clVURjgocykpO1xufVxuZnVuY3Rpb24gaGV4TUQ1KHMpIHtcbiAgcmV0dXJuIHJzdHIyaGV4KHJhd01ENShzKSk7XG59XG5mdW5jdGlvbiByYXdITUFDTUQ1KGssIGQpIHtcbiAgcmV0dXJuIHJzdHJITUFDTUQ1KHN0cjJyc3RyVVRGOChrKSwgc3RyMnJzdHJVVEY4KGQpKTtcbn1cbmZ1bmN0aW9uIGhleEhNQUNNRDUoaywgZCkge1xuICByZXR1cm4gcnN0cjJoZXgocmF3SE1BQ01ENShrLCBkKSk7XG59XG5cbmZ1bmN0aW9uIG1kNShzdHJpbmcsIGtleSwgcmF3KSB7XG4gIGlmICgha2V5KSB7XG4gICAgaWYgKCFyYXcpIHtcbiAgICAgIHJldHVybiBoZXhNRDUoc3RyaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhd01ENShzdHJpbmcpO1xuICB9XG4gIGlmICghcmF3KSB7XG4gICAgcmV0dXJuIGhleEhNQUNNRDUoa2V5LCBzdHJpbmcpO1xuICB9XG4gIHJldHVybiByYXdITUFDTUQ1KGtleSwgc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZDU7XG4iLCIndXNlIHN0cmljdCc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHIpLnJlcGxhY2UoL1shJygpKl0vZywgZnVuY3Rpb24gKGMpIHtcblx0XHRyZXR1cm4gJyUnICsgYy5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpO1xuXHR9KTtcbn07XG4iLCJpbXBvcnQgc2V0dGluZ3MgZnJvbSAnLi9zZXR0aW5ncyc7XG5pbXBvcnQgVGFiU3RhdGUgZnJvbSAnLi90YWItc3RhdGUnO1xuXG4vLyBDYWNoZSB0aGUgdGFiIHN0YXRlIGNvbnN0YW50cy5cbnZhciBzdGF0ZXMgPSBUYWJTdGF0ZS5zdGF0ZXM7XG5cbi8vIEVhY2ggYnV0dG9uIHN0YXRlIGhhcyB0d28gaWNvbnMgb25lIGZvciBub3JtYWwgcmVzb2x1dGlvbiAoMTkpIGFuZCBvbmVcbi8vIGZvciBoaS1yZXMgc2NyZWVucyAoMzgpLlxudmFyIGljb25zID0ge307XG5pY29uc1tzdGF0ZXMuQUNUSVZFXSA9IHtcbiAgMTk6ICdpbWFnZXMvYnJvd3Nlci1pY29uLWFjdGl2ZS5wbmcnLFxuICAzODogJ2ltYWdlcy9icm93c2VyLWljb24tYWN0aXZlQDJ4LnBuZycsXG59O1xuaWNvbnNbc3RhdGVzLklOQUNUSVZFXSA9IHtcbiAgMTk6ICdpbWFnZXMvYnJvd3Nlci1pY29uLWluYWN0aXZlLnBuZycsXG4gIDM4OiAnaW1hZ2VzL2Jyb3dzZXItaWNvbi1pbmFjdGl2ZUAyeC5wbmcnLFxufTtcblxuLy8gdGhlbWVzIHRvIGFwcGx5IHRvIHRoZSB0b29sYmFyIGljb24gYmFkZ2UgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mXG4vLyBidWlsZC4gUHJvZHVjdGlvbiBidWlsZHMgdXNlIHRoZSBkZWZhdWx0IGNvbG9yIGFuZCBubyB0ZXh0XG52YXIgYmFkZ2VUaGVtZXMgPSB7XG4gIGRldjoge1xuICAgIGRlZmF1bHRUZXh0OiAnREVWJyxcbiAgICBjb2xvcjogJyM1QkNGNTknLCAvLyBFbWVyYWxkIGdyZWVuXG4gIH0sXG4gIHFhOiB7XG4gICAgZGVmYXVsdFRleHQ6ICdRQScsXG4gICAgY29sb3I6ICcjRURBMDYxJywgLy8gUG9yY2hlIG9yYW5nZS1waW5rXG4gIH0sXG59O1xuXG4vLyBGYWtlIGxvY2FsaXphdGlvbiBmdW5jdGlvbi5cbmZ1bmN0aW9uIF8oc3RyKSB7XG4gIHJldHVybiBzdHI7XG59XG5cbi8qIENvbnRyb2xzIHRoZSBkaXNwbGF5IG9mIHRoZSBicm93c2VyIGFjdGlvbiBidXR0b24gc2V0dGluZyB0aGUgaWNvbiwgdGl0bGVcbiAqIGFuZCBiYWRnZXMgZGVwZW5kaW5nIG9uIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB0YWIuXG4gKlxuICogQnJvd3NlckFjdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgbWFwcGluZyB0aGUgbG9naWNhbCBIIHN0YXRlIG9mXG4gKiBhIHRhYiAod2hldGhlciB0aGUgZXh0ZW5zaW9uIGlzIGFjdGl2ZSwgYW5ub3RhdGlvbiBjb3VudCkgdG9cbiAqIHRoZSBiYWRnZSBzdGF0ZS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQnJvd3NlckFjdGlvbihjaHJvbWVCcm93c2VyQWN0aW9uKSB7XG4gIHZhciBidWlsZFR5cGUgPSBzZXR0aW5ncy5idWlsZFR5cGU7XG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIHN0YXRlIG9mIHRoZSBicm93c2VyIGFjdGlvbiB0byByZWZsZWN0IHRoZSBsb2dpY2FsXG4gICAqIEggc3RhdGUgb2YgYSB0YWIuXG4gICAqXG4gICAqIEBwYXJhbSBzdGF0ZSAtIFRoZSBIIHN0YXRlIG9mIGEgdGFiLiBTZWUgdGhlICd0YWItc3RhdGUnIG1vZHVsZS5cbiAgICovXG4gIHRoaXMudXBkYXRlID0gZnVuY3Rpb24gKHRhYklkLCBzdGF0ZSkge1xuICAgIHZhciBhY3RpdmVJY29uID0gaWNvbnNbc3RhdGVzLklOQUNUSVZFXTtcbiAgICB2YXIgdGl0bGUgPSAnJztcbiAgICB2YXIgYmFkZ2VUZXh0ID0gJyc7XG5cbiAgICBpZiAoc3RhdGUuc3RhdGUgPT09IHN0YXRlcy5BQ1RJVkUpIHtcbiAgICAgIGFjdGl2ZUljb24gPSBpY29uc1tzdGF0ZXMuQUNUSVZFXTtcbiAgICAgIHRpdGxlID0gJ0h5cG90aGVzaXMgaXMgYWN0aXZlJztcbiAgICB9IGVsc2UgaWYgKHN0YXRlLnN0YXRlID09PSBzdGF0ZXMuSU5BQ1RJVkUpIHtcbiAgICAgIHRpdGxlID0gJ0h5cG90aGVzaXMgaXMgaW5hY3RpdmUnO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuc3RhdGUgPT09IHN0YXRlcy5FUlJPUkVEKSB7XG4gICAgICB0aXRsZSA9ICdIeXBvdGhlc2lzIGZhaWxlZCB0byBsb2FkJztcbiAgICAgIGJhZGdlVGV4dCA9ICchJztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHRhYiBzdGF0ZScpO1xuICAgIH1cblxuICAgIC8vIGRpc3BsYXkgdGhlIGFubm90YXRpb24gY291bnQgb24gdGhlIGJhZGdlXG4gICAgaWYgKHN0YXRlLnN0YXRlICE9PSBzdGF0ZXMuRVJST1JFRCAmJiBzdGF0ZS5hbm5vdGF0aW9uQ291bnQpIHtcbiAgICAgIHZhciBjb3VudExhYmVsO1xuICAgICAgdmFyIHRvdGFsU3RyaW5nID0gc3RhdGUuYW5ub3RhdGlvbkNvdW50LnRvU3RyaW5nKCk7XG4gICAgICBpZiAoc3RhdGUuYW5ub3RhdGlvbkNvdW50ID4gOTk5KSB7XG4gICAgICAgIHRvdGFsU3RyaW5nID0gJzk5OSsnO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmFubm90YXRpb25Db3VudCA9PT0gMSkge1xuICAgICAgICBjb3VudExhYmVsID0gXyhcIlRoZXJlJ3MgMSBhbm5vdGF0aW9uIG9uIHRoaXMgcGFnZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50TGFiZWwgPSBfKFxuICAgICAgICAgICdUaGVyZSBhcmUgJyArIHRvdGFsU3RyaW5nICsgJyBhbm5vdGF0aW9ucyBvbiB0aGlzIHBhZ2UnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0aXRsZSA9IGNvdW50TGFiZWw7XG4gICAgICBiYWRnZVRleHQgPSB0b3RhbFN0cmluZztcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdGhlIGJhZGdlIHN0eWxlIHRvIHJlZmxlY3QgdGhlIGJ1aWxkIHR5cGVcbiAgICB2YXIgYmFkZ2VUaGVtZSA9IGJhZGdlVGhlbWVzW2J1aWxkVHlwZV07XG4gICAgaWYgKGJhZGdlVGhlbWUpIHtcbiAgICAgIGNocm9tZUJyb3dzZXJBY3Rpb24uc2V0QmFkZ2VCYWNrZ3JvdW5kQ29sb3Ioe1xuICAgICAgICB0YWJJZDogdGFiSWQsXG4gICAgICAgIGNvbG9yOiBiYWRnZVRoZW1lLmNvbG9yLFxuICAgICAgfSk7XG4gICAgICBpZiAoIWJhZGdlVGV4dCkge1xuICAgICAgICBiYWRnZVRleHQgPSBiYWRnZVRoZW1lLmRlZmF1bHRUZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGNocm9tZUJyb3dzZXJBY3Rpb24uc2V0QmFkZ2VUZXh0KHsgdGFiSWQ6IHRhYklkLCB0ZXh0OiBiYWRnZVRleHQgfSk7XG4gICAgY2hyb21lQnJvd3NlckFjdGlvbi5zZXRJY29uKHsgdGFiSWQ6IHRhYklkLCBwYXRoOiBhY3RpdmVJY29uIH0pO1xuICAgIGNocm9tZUJyb3dzZXJBY3Rpb24uc2V0VGl0bGUoeyB0YWJJZDogdGFiSWQsIHRpdGxlOiB0aXRsZSB9KTtcbiAgfTtcbn1cblxuQnJvd3NlckFjdGlvbi5pY29ucyA9IGljb25zO1xuIiwiLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHJldHVybiB7J2Nocm9tZSd8J2ZpcmVmb3gnfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBicm93c2VyTmFtZSgpIHtcbiAgaWYgKHdpbmRvdy5icm93c2VyKSB7XG4gICAgcmV0dXJuICdmaXJlZm94JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ2Nocm9tZSc7XG4gIH1cbn1cbiIsIi8qKlxuICogUmV0dXJucyB0aGUgdHlwZSBvZiBjb250ZW50IGluIHRoZSBjdXJyZW50IGRvY3VtZW50LFxuICogY3VycmVudGx5IGVpdGhlciAnUERGJyBvciAnSFRNTCcuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBpbmplY3RlZCBhcyBhIGNvbnRlbnQgc2NyaXB0IGludG8gdGFicyBpblxuICogb3JkZXIgdG8gZGV0ZWN0IHRoZSB0eXBlIG9mIGNvbnRlbnQgb24gdGhlIHBhZ2UgKFBERiwgSFRNTCkgZXRjLlxuICogYnkgc25pZmZpbmcgZm9yIHZpZXdlciBwbHVnaW5zLlxuICpcbiAqIEluIGZ1dHVyZSB0aGlzIGNvdWxkIGFsc28gYmUgZXh0ZW5kZWQgdG8gc3VwcG9ydCBleHRyYWN0aW9uIG9mIHRoZSBVUkxzXG4gKiBvZiBjb250ZW50IGluIGVtYmVkZGVkIHZpZXdlcnMgd2hlcmUgdGhhdCBkaWZmZXJzIGZyb20gdGhlIHRhYidzXG4gKiBtYWluIFVSTC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGV0ZWN0Q29udGVudFR5cGUoZG9jdW1lbnRfKSB7XG4gIGRvY3VtZW50XyA9IGRvY3VtZW50XyB8fCBkb2N1bWVudDtcblxuICBmdW5jdGlvbiBkZXRlY3RDaHJvbWVQREZWaWV3ZXIoKSB7XG4gICAgLy8gV2hlbiB2aWV3aW5nIGEgUERGIGluIENocm9tZSwgdGhlIHZpZXdlciBjb25zaXN0cyBvZiBhIHRvcC1sZXZlbFxuICAgIC8vIGRvY3VtZW50IHdpdGggYW4gPGVtYmVkPiB0YWcsIHdoaWNoIGluIHR1cm4gaW5zdGFudGlhdGVzIGFuIGlubmVyIEhUTUxcbiAgICAvLyBkb2N1bWVudCBwcm92aWRpbmcgdGhlIFBERiB2aWV3ZXIgVUkgcGx1cyBhbm90aGVyIDxlbWJlZD4gdGFnIHdoaWNoXG4gICAgLy8gaW5zdGFudGlhdGVzIHRoZSBuYXRpdmUgUERGIHJlbmRlcmVyLlxuICAgIC8vXG4gICAgLy8gVGhlIHNlbGVjdG9yIGJlbG93IG1hdGNoZXMgdGhlIDxlbWJlZD4gdGFnIGluIHRoZSB0b3AtbGV2ZWwgZG9jdW1lbnQuIFRvXG4gICAgLy8gc2VlIHRoaXMgZG9jdW1lbnQsIG9wZW4gdGhlIGRldmVsb3BlciB0b29scyBmcm9tIENocm9tZSdzIG1lbnUgcmF0aGVyXG4gICAgLy8gdGhhbiByaWdodC1jbGlja2luZyBvbiB0aGUgdmlld3BvcnQgYW5kIHNlbGVjdGluZyB0aGUgJ0luc3BlY3QnIG9wdGlvblxuICAgIC8vIHdoaWNoIHdpbGwgaW5zdGVhZCBzaG93IHRoZSBfaW5uZXJfIGRvY3VtZW50LlxuICAgIGlmIChkb2N1bWVudF8ucXVlcnlTZWxlY3RvcignZW1iZWRbdHlwZT1cImFwcGxpY2F0aW9uL3BkZlwiXScpKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiAnUERGJyB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGVjdEZpcmVmb3hQREZWaWV3ZXIoKSB7XG4gICAgLy8gVGhlIEZpcmVmb3ggUERGIHZpZXdlciBpcyBhbiBpbnN0YW5jZSBvZiBQREYuanMuXG4gICAgLy9cbiAgICAvLyBUaGUgRmlyZWZveCBQREYgcGx1Z2luIHNwZWNpZmljYWxseSBjYW4gYmUgZGV0ZWN0ZWQgdmlhIHRoZSA8YmFzZT5cbiAgICAvLyB0YWcgaXQgaW5jbHVkZXMsIHdoaWNoIGNhbiBiZSBkb25lIGZyb20gYSBjb250ZW50IHNjcmlwdCAod2hpY2ggcnVuc1xuICAgIC8vIGluIGFuIGlzb2xhdGVkIEpTIHdvcmxkIGZyb20gdGhlIHBhZ2UncyBvd24gc2NyaXB0cykuXG4gICAgLy9cbiAgICAvLyBHZW5lcmljIFBERi5qcyBkZXRlY3Rpb24gY2FuIGJlIGRvbmUgYnkgbG9va2luZyBmb3IgdGhlXG4gICAgLy8gYHdpbmRvdy5QREZWaWV3ZXJBcHBsaWNhdGlvbmAgb2JqZWN0LiBUaGlzIGhvd2V2ZXIgcmVxdWlyZXMgcnVubmluZyBKU1xuICAgIC8vIGNvZGUgaW4gdGhlIHNhbWUgSlMgY29udGV4dCBhcyB0aGUgcGFnZSdzIG93biBjb2RlLlxuICAgIGlmIChkb2N1bWVudF8uYmFzZVVSSS5pbmRleE9mKCdyZXNvdXJjZTovL3BkZi5qcycpID09PSAwKSB7XG4gICAgICByZXR1cm4geyB0eXBlOiAnUERGJyB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBkZXRlY3RGbnMgPSBbZGV0ZWN0Q2hyb21lUERGVmlld2VyLCBkZXRlY3RGaXJlZm94UERGVmlld2VyXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXRlY3RGbnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdHlwZUluZm8gPSBkZXRlY3RGbnNbaV0oKTtcbiAgICBpZiAodHlwZUluZm8pIHtcbiAgICAgIHJldHVybiB0eXBlSW5mbztcbiAgICB9XG4gIH1cblxuICByZXR1cm4geyB0eXBlOiAnSFRNTCcgfTtcbn1cbiIsIi8qKlxuICogU3Vic2V0IG9mIHRoZSBjbGllbnQgY29uZmlndXJhdGlvbiB3aGljaCBjYXVzZXMgdGhlIGNsaWVudCB0byBzaG93IGFcbiAqIHBhcnRpY3VsYXIgc2V0IG9mIGFubm90YXRpb25zIGF1dG9tYXRpY2FsbHkgYWZ0ZXIgaXQgbG9hZHMuXG4gKlxuICogU2VlIGh0dHBzOi8vaC1jbGllbnQucmVhZHRoZWRvY3MuaW8vZW4vbGF0ZXN0L3B1Ymxpc2hlcnMvY29uZmlnLyNjb25maWctc2V0dGluZ3NcbiAqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBRdWVyeVxuICogQHByb3BlcnR5IHtzdHJpbmd9IFthbm5vdGF0aW9uc10gLSBJRCBvZiB0aGUgZGlyZWN0LWxpbmtlZCBhbm5vdGF0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3F1ZXJ5XSAtIEZpbHRlciBxdWVyeSBmcm9tIHRoZSBzaWRlYmFyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2dyb3VwXSAtIElEIG9mIHRoZSBkaXJlY3QtbGlua2VkIGdyb3VwXG4gKi9cblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgZGlyZWN0LWxpbmtpbmcgcXVlcnkgZnJvbSB0aGUgVVJMIGlmIGFueS5cbiAqXG4gKiBJZiBwcmVzZW50LCB0aGUgcXVlcnkgY2F1c2VzIHRoZSBleHRlbnNpb24gdG8gYWN0aXZhdGUgYXV0b21hdGljYWxseSBhbmRcbiAqIHNob3cgdGhlIG1hdGNoaW5nIHNldCBvZiBhbm5vdGF0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC1cbiAqICAgVGhlIFVSTCB3aGljaCBtYXkgY29udGFpbiBhICcjYW5ub3RhdGlvbnM6JyBmcmFnbWVudCBzcGVjaWZ5aW5nIHdoaWNoXG4gKiAgIGFubm90YXRpb25zIHRvIHNob3cuXG4gKiBAcmV0dXJuIHtRdWVyeXxudWxsfVxuICogICBUaGUgZGlyZWN0IGxpbmsgcXVlcnkgdHJhbnNsYXRlZCBpbnRvIGNsaWVudCBjb25maWd1cmF0aW9uIHNldHRpbmdzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkaXJlY3RMaW5rUXVlcnkodXJsKSB7XG4gIC8vIEFubm90YXRpb24gSURzIGFyZSB1cmwtc2FmZS1iYXNlNjQgaWRlbnRpZmllcnNcbiAgLy8gU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0NjQ4I3BhZ2UtN1xuICB2YXIgaWRNYXRjaCA9IHVybC5tYXRjaCgvI2Fubm90YXRpb25zOihbQS1aYS16MC05Xy1dKykkLyk7XG4gIGlmIChpZE1hdGNoKSB7XG4gICAgcmV0dXJuIHsgYW5ub3RhdGlvbnM6IGlkTWF0Y2hbMV0gfTtcbiAgfVxuXG4gIHZhciBxdWVyeU1hdGNoID0gdXJsLm1hdGNoKC8jYW5ub3RhdGlvbnM6cXVlcnk6KC4qKSQvKTtcbiAgaWYgKHF1ZXJ5TWF0Y2gpIHtcbiAgICBsZXQgcXVlcnkgPSBkZWNvZGVVUklDb21wb25lbnQocXVlcnlNYXRjaFsxXSk7XG4gICAgcmV0dXJuIHsgcXVlcnkgfTtcbiAgfVxuXG4gIC8vIEdyb3VwIElEcyAoYW5kIG90aGVyIFwicHViaWRzXCIgaW4gaCkgYXJlIGEgc3Vic2V0IG9mIEFTQ0lJIGxldHRlcnMgYW5kXG4gIC8vIGRpZ2l0cy4gQXMgYSBzcGVjaWFsIGV4Y2VwdGlvbiwgdGhlIFwiUHVibGljXCIgZ3JvdXAgaGFzIHVuZGVyc2NvcmVzIGluIGl0c1xuICAvLyBJRCAoXCJfX3dvcmxkX19cIikuXG4gIHZhciBncm91cE1hdGNoID0gdXJsLm1hdGNoKC8jYW5ub3RhdGlvbnM6Z3JvdXA6KFtBLVphLXowLTlfXSspJC8pO1xuICBpZiAoZ3JvdXBNYXRjaCkge1xuICAgIHJldHVybiB7IGdyb3VwOiBncm91cE1hdGNoWzFdIH07XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbiIsImltcG9ydCAqIGFzIHJhdmVuIGZyb20gJy4vcmF2ZW4nO1xuXG5leHBvcnQgZnVuY3Rpb24gRXh0ZW5zaW9uRXJyb3IobWVzc2FnZSkge1xuICBFcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5FeHRlbnNpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBMb2NhbEZpbGVFcnJvcihtZXNzYWdlKSB7XG4gIEVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkxvY2FsRmlsZUVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXh0ZW5zaW9uRXJyb3IucHJvdG90eXBlKTtcblxuZXhwb3J0IGZ1bmN0aW9uIE5vRmlsZUFjY2Vzc0Vycm9yKG1lc3NhZ2UpIHtcbiAgRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuTm9GaWxlQWNjZXNzRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFeHRlbnNpb25FcnJvci5wcm90b3R5cGUpO1xuXG5leHBvcnQgZnVuY3Rpb24gUmVzdHJpY3RlZFByb3RvY29sRXJyb3IobWVzc2FnZSkge1xuICBFcnJvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5SZXN0cmljdGVkUHJvdG9jb2xFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV4dGVuc2lvbkVycm9yLnByb3RvdHlwZSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBCbG9ja2VkU2l0ZUVycm9yKG1lc3NhZ2UpIHtcbiAgRXJyb3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQmxvY2tlZFNpdGVFcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV4dGVuc2lvbkVycm9yLnByb3RvdHlwZSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBBbHJlYWR5SW5qZWN0ZWRFcnJvcihtZXNzYWdlKSB7XG4gIEVycm9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkFscmVhZHlJbmplY3RlZEVycm9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXh0ZW5zaW9uRXJyb3IucHJvdG90eXBlKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYGVycmAgaXMgYSByZWNvZ25pemVkICdleHBlY3RlZCcgZXJyb3IuXG4gKi9cbmZ1bmN0aW9uIGlzS25vd25FcnJvcihlcnIpIHtcbiAgcmV0dXJuIGVyciBpbnN0YW5jZW9mIEV4dGVuc2lvbkVycm9yO1xufVxuXG52YXIgSUdOT1JFRF9FUlJPUlMgPSBbXG4gIC8vIEVycm9ycyB0aGF0IGNhbiBoYXBwZW4gd2hlbiB0aGUgdGFiIGlzIGNsb3NlZCBkdXJpbmcgaW5qZWN0aW9uXG4gIC9UaGUgdGFiIHdhcyBjbG9zZWQvLFxuICAvTm8gdGFiIHdpdGggaWQuKi8sXG4gIC8vIEF0dGVtcHRzIHRvIGFjY2VzcyBwYWdlcyBmb3Igd2hpY2ggQ2hyb21lIGRvZXMgbm90IGFsbG93IHNjcmlwdGluZ1xuICAvQ2Fubm90IGFjY2VzcyBjb250ZW50cyBvZi4qLyxcbiAgL1RoZSBleHRlbnNpb25zIGdhbGxlcnkgY2Fubm90IGJlIHNjcmlwdGVkLyxcbl07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgZ2l2ZW4gYGVycmAgaXMgYW50aWNpcGF0ZWQgZHVyaW5nIHNpZGViYXIgaW5qZWN0aW9uLCBzdWNoXG4gKiBhcyB0aGUgdGFiIGJlaW5nIGNsb3NlZCBieSB0aGUgdXNlciwgYW5kIHNob3VsZCBub3QgYmUgcmVwb3J0ZWQgdG8gU2VudHJ5LlxuICpcbiAqIEBwYXJhbSB7e21lc3NhZ2U6IHN0cmluZ319IGVyciAtIFRoZSBFcnJvci1saWtlIG9iamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkSWdub3JlSW5qZWN0aW9uRXJyb3IoZXJyKSB7XG4gIGlmIChcbiAgICBJR05PUkVEX0VSUk9SUy5zb21lKGZ1bmN0aW9uIChwYXR0ZXJuKSB7XG4gICAgICByZXR1cm4gZXJyLm1lc3NhZ2UubWF0Y2gocGF0dGVybik7XG4gICAgfSlcbiAgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKGlzS25vd25FcnJvcihlcnIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcG9ydCBhbiBlcnJvci5cbiAqXG4gKiBBbGwgZXJyb3JzIGFyZSBsb2dnZWQgdG8gdGhlIGNvbnNvbGUuIEFkZGl0aW9uYWxseSB1bmV4cGVjdGVkIGVycm9ycyxcbiAqIGllLiB0aG9zZSB3aGljaCBhcmUgbm90IGluc3RhbmNlcyBvZiBFeHRlbnNpb25FcnJvciwgYXJlIHJlcG9ydGVkIHRvXG4gKiBTZW50cnkuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgLSBUaGUgZXJyb3Igd2hpY2ggaGFwcGVuZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gd2hlbiAtIERlc2NyaWJlcyB0aGUgY29udGV4dCBpbiB3aGljaCB0aGUgZXJyb3Igb2NjdXJyZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dCAtIEFkZGl0aW9uYWwgY29udGV4dCBmb3IgdGhlIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0KGVycm9yLCB3aGVuLCBjb250ZXh0KSB7XG4gIGNvbnNvbGUuZXJyb3Iod2hlbiwgZXJyb3IpO1xuICBpZiAoIWlzS25vd25FcnJvcihlcnJvcikpIHtcbiAgICByYXZlbi5yZXBvcnQoZXJyb3IsIHdoZW4sIGNvbnRleHQpO1xuICB9XG59XG4iLCJpbXBvcnQgYnJvd3Nlck5hbWUgZnJvbSAnLi9icm93c2VyLW5hbWUnO1xuaW1wb3J0ICogYXMgZXJyb3JzIGZyb20gJy4vZXJyb3JzJztcblxuLyogQSBjb250cm9sbGVyIGZvciBkaXNwbGF5aW5nIGhlbHAgcGFnZXMuIFRoZXNlIGFyZSBib3VuZCB0byBleHRlbnNpb25cbiAqIHNwZWNpZmljIGVycm9ycyAoZm91bmQgaW4gZXJyb3JzLmpzKSBidXQgY2FuIGFsc28gYmUgdHJpZ2dlcmVkIG1hbnVhbGx5LlxuICpcbiAqIGNocm9tZVRhYnMgICAtIEFuIGluc3RhbmNlIG9mIGNocm9tZS50YWJzLlxuICogZXh0ZW5zaW9uVVJMIC0gQSBmdW5jdGlvbiB0aGF0IHJlY2lldmVzIGEgcGF0aCBhbmQgcmV0dXJucyBhIGZ1bGwgcGF0aFxuICogICB0byB0aGUgZmlsZSBpbnNpZGUgdGhlIGNocm9tZSBleHRlbnNpb24uIFNlZTpcbiAqICAgaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL2V4dGVuc2lvbiNtZXRob2QtZ2V0VVJMXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEhlbHBQYWdlKGNocm9tZVRhYnMsIGV4dGVuc2lvblVSTCwgYnJvd3Nlck5hbWVfKSB7XG4gIGJyb3dzZXJOYW1lXyA9IGJyb3dzZXJOYW1lXyB8fCBicm93c2VyTmFtZTtcblxuICAvKiBBY2NlcHRzIGFuIGluc3RhbmNlIG9mIGVycm9ycy5FeHRlbnNpb25FcnJvciBhbmQgZGlzcGxheXMgYW4gYXBwcm9wcmlhdGVcbiAgICogaGVscCBwYWdlIGlmIG9uZSBleGlzdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7VGFifSB0YWIgICAtIFRoZSB0YWIgdG8gZGlzcGxheSB0aGUgZXJyb3IgbWVzc2FnZSBpbi5cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgLSBUaGUgZXJyb3IgdG8gZGlzcGxheSwgdXN1YWxseSBhbiBpbnN0YW5jZSBvZlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5FeHRlbnNpb25FcnJvclxuICAgKi9cbiAgdGhpcy5zaG93SGVscEZvckVycm9yID0gZnVuY3Rpb24gKHRhYiwgZXJyb3IpIHtcbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnMuTG9jYWxGaWxlRXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3dMb2NhbEZpbGVIZWxwUGFnZSh0YWIpO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnMuTm9GaWxlQWNjZXNzRXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3dOb0ZpbGVBY2Nlc3NIZWxwUGFnZSh0YWIpO1xuICAgIH0gZWxzZSBpZiAoZXJyb3IgaW5zdGFuY2VvZiBlcnJvcnMuUmVzdHJpY3RlZFByb3RvY29sRXJyb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3dSZXN0cmljdGVkUHJvdG9jb2xQYWdlKHRhYik7XG4gICAgfSBlbHNlIGlmIChlcnJvciBpbnN0YW5jZW9mIGVycm9ycy5CbG9ja2VkU2l0ZUVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5zaG93QmxvY2tlZFNpdGVQYWdlKHRhYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3dPdGhlckVycm9yUGFnZSh0YWIsIGVycm9yKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5zaG93TG9jYWxGaWxlSGVscFBhZ2UgPSBzaG93SGVscFBhZ2UuYmluZChudWxsLCAnbG9jYWwtZmlsZScpO1xuICB0aGlzLnNob3dOb0ZpbGVBY2Nlc3NIZWxwUGFnZSA9IHNob3dIZWxwUGFnZS5iaW5kKG51bGwsICduby1maWxlLWFjY2VzcycpO1xuICB0aGlzLnNob3dSZXN0cmljdGVkUHJvdG9jb2xQYWdlID0gc2hvd0hlbHBQYWdlLmJpbmQoXG4gICAgbnVsbCxcbiAgICAncmVzdHJpY3RlZC1wcm90b2NvbCdcbiAgKTtcbiAgdGhpcy5zaG93QmxvY2tlZFNpdGVQYWdlID0gc2hvd0hlbHBQYWdlLmJpbmQobnVsbCwgJ2Jsb2NrZWQtc2l0ZScpO1xuICB0aGlzLnNob3dPdGhlckVycm9yUGFnZSA9IHNob3dIZWxwUGFnZS5iaW5kKG51bGwsICdvdGhlci1lcnJvcicpO1xuXG4gIC8qKlxuICAgKiBPcGVuIGEgdGFiIGRpc3BsYXlpbmcgdGhlIGhlbHAgcGFnZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhlbHBTZWN0aW9uIC0gSUQgb2YgYSA8c2VjdGlvbj4gd2l0aGluIHRoZSBoZWxwIHBhZ2UuXG4gICAqIEBwYXJhbSB7dGFicy5UYWJ9IHRhYiAtIFRoZSB0YWIgd2hlcmUgdGhlIGVycm9yIG9jY3VycmVkLlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJvciAtIFRoZSBlcnJvciB3aGljaCBwcm9tcHRlZCB0aGUgaGVscCBwYWdlLlxuICAgKi9cbiAgZnVuY3Rpb24gc2hvd0hlbHBQYWdlKGhlbHBTZWN0aW9uLCB0YWIsIGVycm9yKSB7XG4gICAgdmFyIHBhcmFtcyA9ICcnO1xuICAgIGlmIChlcnJvcikge1xuICAgICAgcGFyYW1zID0gJz9tZXNzYWdlPScgKyBlbmNvZGVVUklDb21wb25lbnQoZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuXG4gICAgdmFyIHRhYk9wdHMgPSB7XG4gICAgICBpbmRleDogdGFiLmluZGV4ICsgMSxcbiAgICAgIHVybDogZXh0ZW5zaW9uVVJMKCcvaGVscC9pbmRleC5odG1sJyArIHBhcmFtcyArICcjJyArIGhlbHBTZWN0aW9uKSxcbiAgICB9O1xuXG4gICAgLy8gQWRkIGBvcGVuZXJUYWJJZGAgcHJvcGVydHkgdG8gYXNzb2NpYXRlIHRoZSBoZWxwIHBhZ2UgdGFiIHdpdGggdGhlXG4gICAgLy8gY3VycmVudCB0YWIuIFRoaXMgcHJvcGVydHkgaXMgbm90IHN1cHBvcnRlZCBpbiBGaXJlZm94LlxuICAgIGlmIChicm93c2VyTmFtZV8oKSAhPT0gJ2ZpcmVmb3gnKSB7XG4gICAgICB0YWJPcHRzLm9wZW5lclRhYklkID0gdGFiLmlkO1xuICAgIH1cblxuICAgIGNocm9tZVRhYnMuY3JlYXRlKHRhYk9wdHMpO1xuICB9XG59XG4iLCJpbXBvcnQgQnJvd3NlckFjdGlvbiBmcm9tICcuL2Jyb3dzZXItYWN0aW9uJztcbmltcG9ydCBkaXJlY3RMaW5rUXVlcnkgZnJvbSAnLi9kaXJlY3QtbGluay1xdWVyeSc7XG5pbXBvcnQgKiBhcyBlcnJvcnMgZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IEhlbHBQYWdlIGZyb20gJy4vaGVscC1wYWdlJztcbmltcG9ydCBzZXR0aW5ncyBmcm9tICcuL3NldHRpbmdzJztcbmltcG9ydCBTaWRlYmFySW5qZWN0b3IgZnJvbSAnLi9zaWRlYmFyLWluamVjdG9yJztcbmltcG9ydCBUYWJTdGF0ZSBmcm9tICcuL3RhYi1zdGF0ZSc7XG5pbXBvcnQgVGFiU3RvcmUgZnJvbSAnLi90YWItc3RvcmUnO1xuXG52YXIgVEFCX1NUQVRVU19MT0FESU5HID0gJ2xvYWRpbmcnO1xudmFyIFRBQl9TVEFUVVNfQ09NUExFVEUgPSAnY29tcGxldGUnO1xuXG4vKiBUaGUgbWFpbiBleHRlbnNpb24gYXBwbGljYXRpb24uIFRoaXMgd2lyZXMgdG9nZXRoZXIgYWxsIHRoZSBzbWFsbGVyXG4gKiBtb2R1bGVzLiBUaGUgYXBwIGxpc3RlbnMgdG8gYWxsIG5ldyBjcmVhdGVkL3VwZGF0ZWQvcmVtb3ZlZCB0YWIgZXZlbnRzXG4gKiBhbmQgdXNlcyB0aGUgVGFiU3RhdGUgb2JqZWN0IHRvIGtlZXAgdHJhY2sgb2Ygd2hldGhlciB0aGUgc2lkZWJhciBpc1xuICogYWN0aXZlIG9yIGluYWN0aXZlIGluIHRoZSB0YWIuIFRoZSBhcHAgYWxzbyBsaXN0ZW5zIHRvIGNsaWNrIGV2ZW50cyBvblxuICogdGhlIGJyb3dzZXIgYWN0aW9uIGFuZCB0b2dnbGVzIHRoZSBzdGF0ZSBhbmQgdXNlcyB0aGUgQnJvd3NlckFjdGlvbiBtb2R1bGVcbiAqIHRvIHVwZGF0ZSB0aGUgdmlzdWFsIHN0eWxlIG9mIHRoZSBidXR0b24uXG4gKlxuICogVGhlIFNpZGViYXJJbmplY3RvciBoYW5kbGVzIHRoZSBpbnNlcnRpb24gb2YgdGhlIEh5cG90aGVzaXMgY29kZS4gSWYgaXRcbiAqIHJ1bnMgaW50byBlcnJvcnMgdGhlIHRhYiBpcyBwdXQgaW50byBhbiBlcnJvcmVkIHN0YXRlIGFuZCB3aGVuIHRoZVxuICogYnJvd3NlciBhY3Rpb24gaXMgY2xpY2tlZCBhZ2FpbiB0aGUgSGVscFBhZ2UgbW9kdWxlIGRpc3BsYXlzIG1vcmVcbiAqIGluZm9ybWF0aW9uIHRvIHRoZSB1c2VyLlxuICpcbiAqIExhc3RseSB0aGUgVGFiU3RvcmUgbGlzdGVucyB0byBjaGFuZ2VzIHRvIHRoZSBUYWJTdGF0ZSBtb2R1bGUgYW5kIHBlcnNpc3RzXG4gKiB0aGUgY3VycmVudCBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2UuIFRoaXMgaXMgdGhlbiBsb2FkZWQgaW50byB0aGVcbiAqIGFwcGxpY2F0aW9uIG9uIHN0YXJ0dXAuXG4gKlxuICogUmVsZXZhbnQgQ2hyb21lIEV4dGVuc2lvbiBkb2N1bWVudGF0aW9uOlxuICogLSBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvYnJvd3NlckFjdGlvblxuICogLSBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvdGFic1xuICogLSBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvZXh0ZW5zaW9uXG4gKlxuICogZGVwZW5kZW5jaWVzIC0gQW4gb2JqZWN0IHRvIHNldCB1cCB0aGUgYXBwbGljYXRpb24uXG4gKiAgIGNocm9tZVRhYnM6IEFuIGluc3RhbmNlIG9mIGNocm9tZS50YWJzLlxuICogICBjaHJvbWVCcm93c2VyQWN0aW9uOiBBbiBpbnN0YW5jZSBvZiBjaHJvbWUuYnJvd3NlckFjdGlvbi5cbiAqICAgZXh0ZW5zaW9uVVJMOiBjaHJvbWUuZXh0ZW5zaW9uLmdldFVSTC5cbiAqICAgaXNBbGxvd2VkRmlsZVNjaGVtZUFjY2VzczogY2hyb21lLmV4dGVuc2lvbi5pc0FsbG93ZWRGaWxlU2NoZW1lQWNjZXNzLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBIeXBvdGhlc2lzQ2hyb21lRXh0ZW5zaW9uKGRlcGVuZGVuY2llcykge1xuICB2YXIgY2hyb21lVGFicyA9IGRlcGVuZGVuY2llcy5jaHJvbWVUYWJzO1xuICB2YXIgY2hyb21lRXh0ZW5zaW9uID0gZGVwZW5kZW5jaWVzLmNocm9tZUV4dGVuc2lvbjtcbiAgdmFyIGNocm9tZVN0b3JhZ2UgPSBkZXBlbmRlbmNpZXMuY2hyb21lU3RvcmFnZTtcbiAgdmFyIGNocm9tZUJyb3dzZXJBY3Rpb24gPSBkZXBlbmRlbmNpZXMuY2hyb21lQnJvd3NlckFjdGlvbjtcbiAgdmFyIGhlbHAgPSBuZXcgSGVscFBhZ2UoY2hyb21lVGFicywgZGVwZW5kZW5jaWVzLmV4dGVuc2lvblVSTCk7XG4gIHZhciBzdG9yZSA9IG5ldyBUYWJTdG9yZShsb2NhbFN0b3JhZ2UpO1xuICB2YXIgc3RhdGUgPSBuZXcgVGFiU3RhdGUoc3RvcmUuYWxsKCksIG9uVGFiU3RhdGVDaGFuZ2UpO1xuICB2YXIgYnJvd3NlckFjdGlvbiA9IG5ldyBCcm93c2VyQWN0aW9uKGNocm9tZUJyb3dzZXJBY3Rpb24pO1xuICB2YXIgc2lkZWJhciA9IG5ldyBTaWRlYmFySW5qZWN0b3IoY2hyb21lVGFicywge1xuICAgIGV4dGVuc2lvblVSTDogZGVwZW5kZW5jaWVzLmV4dGVuc2lvblVSTCxcbiAgICBpc0FsbG93ZWRGaWxlU2NoZW1lQWNjZXNzOiBkZXBlbmRlbmNpZXMuaXNBbGxvd2VkRmlsZVNjaGVtZUFjY2VzcyxcbiAgfSk7XG5cbiAgcmVzdG9yZVNhdmVkVGFiU3RhdGUoKTtcblxuICAvKiBTZXRzIHVwIHRoZSBleHRlbnNpb24gYW5kIGJpbmRzIGV2ZW50IGxpc3RlbmVycy4gUmVxdWlyZXMgYSB3aW5kb3dcbiAgICogb2JqZWN0IHRvIGJlIHBhc3NlZCBzbyB0aGF0IGl0IGNhbiBsaXN0ZW4gZm9yIGxvY2FsU3RvcmFnZSBldmVudHMuXG4gICAqL1xuICB0aGlzLmxpc3RlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICBjaHJvbWVCcm93c2VyQWN0aW9uLm9uQ2xpY2tlZC5hZGRMaXN0ZW5lcihvbkJyb3dzZXJBY3Rpb25DbGlja2VkKTtcbiAgICBjaHJvbWVUYWJzLm9uQ3JlYXRlZC5hZGRMaXN0ZW5lcihvblRhYkNyZWF0ZWQpO1xuXG4gICAgLy8gd2hlbiBhIHVzZXIgbmF2aWdhdGVzIHdpdGhpbiBhbiBleGlzdGluZyB0YWIsXG4gICAgLy8gb25VcGRhdGVkIGlzIGZpcmVkIGluIG1vc3QgY2FzZXNcbiAgICBjaHJvbWVUYWJzLm9uVXBkYXRlZC5hZGRMaXN0ZW5lcihvblRhYlVwZGF0ZWQpO1xuXG4gICAgLy8gLi4uIGJ1dCB3aGVuIGEgdXNlciBuYXZpZ2F0ZXMgdG8gYSBwYWdlIHRoYXQgaXMgbG9hZGVkXG4gICAgLy8gdmlhIHByZXJlbmRlcmluZyBvciBpbnN0YW50IHJlc3VsdHMsIG9uVGFiUmVwbGFjZWQgaXNcbiAgICAvLyBmaXJlZCBpbnN0ZWFkLiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3RhYnMjZXZlbnQtb25SZXBsYWNlZFxuICAgIC8vIGFuZCBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MTA5NTU3XG4gICAgY2hyb21lVGFicy5vblJlcGxhY2VkLmFkZExpc3RlbmVyKG9uVGFiUmVwbGFjZWQpO1xuXG4gICAgY2hyb21lVGFicy5vblJlbW92ZWQuYWRkTGlzdGVuZXIob25UYWJSZW1vdmVkKTtcbiAgfTtcblxuICAvKiBBIG1ldGhvZCB0aGF0IGNhbiBiZSB1c2VkIHRvIHNldHVwIHRoZSBleHRlbnNpb24gb24gZXhpc3RpbmcgdGFic1xuICAgKiB3aGVuIHRoZSBleHRlbnNpb24gaXMgcmUtaW5zdGFsbGVkLlxuICAgKi9cbiAgdGhpcy5pbnN0YWxsID0gZnVuY3Rpb24gKCkge1xuICAgIHJlc3RvcmVTYXZlZFRhYlN0YXRlKCk7XG4gIH07XG5cbiAgLyogT3BlbnMgdGhlIG9uYm9hcmRpbmcgcGFnZSAqL1xuICB0aGlzLmZpcnN0UnVuID0gZnVuY3Rpb24gKGV4dGVuc2lvbkluZm8pIHtcbiAgICAvLyBJZiB3ZSd2ZSBiZWVuIGluc3RhbGxlZCBiZWNhdXNlIG9mIGFuIGFkbWluaXN0cmF0aXZlIHBvbGljeSwgdGhlbiBkb24ndFxuICAgIC8vIG9wZW4gdGhlIHdlbGNvbWUgcGFnZSBpbiBhIG5ldyB0YWIuXG4gICAgLy9cbiAgICAvLyBJdCdzIHNhZmUgdG8gYXNzdW1lIHRoYXQgaWYgYW4gYWRtaW4gcG9saWN5IGlzIHJlc3BvbnNpYmxlIGZvciBpbnN0YWxsaW5nXG4gICAgLy8gdGhlIGV4dGVuc2lvbiwgb3BlbmluZyB0aGUgd2VsY29tZSBwYWdlIGlzIGdvaW5nIHRvIGRvIG1vcmUgaGFybSB0aGFuXG4gICAgLy8gZ29vZCwgYXMgaXQgd2lsbCBhcHBlYXIgdGhhdCBhIHRhYiBvcGVuZWQgd2l0aG91dCB1c2VyIGFjdGlvbi5cbiAgICAvL1xuICAgIC8vIFNlZTpcbiAgICAvL1xuICAgIC8vICAgaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL21hbmFnZW1lbnQjdHlwZS1FeHRlbnNpb25JbnN0YWxsVHlwZVxuICAgIC8vXG4gICAgaWYgKGV4dGVuc2lvbkluZm8uaW5zdGFsbFR5cGUgPT09ICdhZG1pbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjaHJvbWVUYWJzLmNyZWF0ZSh7IHVybDogc2V0dGluZ3Muc2VydmljZVVybCArICd3ZWxjb21lJyB9LCBmdW5jdGlvbiAodGFiKSB7XG4gICAgICBzdGF0ZS5hY3RpdmF0ZVRhYih0YWIuaWQpO1xuICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHJlc3RvcmVTYXZlZFRhYlN0YXRlKCkge1xuICAgIHN0b3JlLnJlbG9hZCgpO1xuICAgIHN0YXRlLmxvYWQoc3RvcmUuYWxsKCkpO1xuICAgIGNocm9tZVRhYnMucXVlcnkoe30sIGZ1bmN0aW9uICh0YWJzKSB7XG4gICAgICB0YWJzLmZvckVhY2goZnVuY3Rpb24gKHRhYikge1xuICAgICAgICBvblRhYlN0YXRlQ2hhbmdlKHRhYi5pZCwgc3RhdGUuZ2V0U3RhdGUodGFiLmlkKSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVGFiU3RhdGVDaGFuZ2UodGFiSWQsIGN1cnJlbnQpIHtcbiAgICBpZiAoY3VycmVudCkge1xuICAgICAgYnJvd3NlckFjdGlvbi51cGRhdGUodGFiSWQsIGN1cnJlbnQpO1xuICAgICAgY2hyb21lVGFicy5nZXQodGFiSWQsIHVwZGF0ZVRhYkRvY3VtZW50KTtcblxuICAgICAgaWYgKCFzdGF0ZS5pc1RhYkVycm9yZWQodGFiSWQpKSB7XG4gICAgICAgIHN0b3JlLnNldCh0YWJJZCwgY3VycmVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0b3JlLnVuc2V0KHRhYklkKTtcbiAgICB9XG4gIH1cblxuICAvLyBleHBvc2VkIGZvciB1c2UgYnkgdGVzdHNcbiAgdGhpcy5fb25UYWJTdGF0ZUNoYW5nZSA9IG9uVGFiU3RhdGVDaGFuZ2U7XG5cbiAgZnVuY3Rpb24gb25Ccm93c2VyQWN0aW9uQ2xpY2tlZCh0YWIpIHtcbiAgICB2YXIgdGFiRXJyb3IgPSBzdGF0ZS5nZXRTdGF0ZSh0YWIuaWQpLmVycm9yO1xuICAgIGlmICh0YWJFcnJvcikge1xuICAgICAgaGVscC5zaG93SGVscEZvckVycm9yKHRhYiwgdGFiRXJyb3IpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUuaXNUYWJBY3RpdmUodGFiLmlkKSkge1xuICAgICAgc3RhdGUuZGVhY3RpdmF0ZVRhYih0YWIuaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5hY3RpdmF0ZVRhYih0YWIuaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhY3RpdmUgc3RhdGUgZm9yIGEgdGFiXG4gICAqIHdoaWNoIGhhcyBqdXN0IGJlZW4gbmF2aWdhdGVkIHRvLlxuICAgKi9cbiAgZnVuY3Rpb24gYWN0aXZlU3RhdGVGb3JOYXZpZ2F0ZWRUYWIodGFiSWQpIHtcbiAgICB2YXIgYWN0aXZlU3RhdGUgPSBzdGF0ZS5nZXRTdGF0ZSh0YWJJZCkuc3RhdGU7XG4gICAgaWYgKGFjdGl2ZVN0YXRlID09PSBUYWJTdGF0ZS5zdGF0ZXMuRVJST1JFRCkge1xuICAgICAgLy8gdXNlciBoYWQgdHJpZWQgdG8gYWN0aXZhdGUgSCBvbiB0aGUgcHJldmlvdXMgcGFnZSBidXQgaXQgZmFpbGVkLFxuICAgICAgLy8gcmV0cnkgb24gdGhlIG5ldyBwYWdlXG4gICAgICBhY3RpdmVTdGF0ZSA9IFRhYlN0YXRlLnN0YXRlcy5BQ1RJVkU7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmVTdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VGFiU3RhdGUodGFiSWQsIHVybCkge1xuICAgIHN0YXRlLnNldFN0YXRlKHRhYklkLCB7XG4gICAgICBzdGF0ZTogYWN0aXZlU3RhdGVGb3JOYXZpZ2F0ZWRUYWIodGFiSWQpLFxuICAgICAgcmVhZHk6IGZhbHNlLFxuICAgICAgYW5ub3RhdGlvbkNvdW50OiAwLFxuICAgICAgZXh0ZW5zaW9uU2lkZWJhckluc3RhbGxlZDogZmFsc2UsXG4gICAgfSk7XG4gICAgdXBkYXRlQW5ub3RhdGlvbkNvdW50SWZFbmFibGVkKHRhYklkLCB1cmwpO1xuICB9XG5cbiAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBhcyB0aGUgdGFiIHJlbG9hZHMuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy90YWJzI2V2ZW50LW9uVXBkYXRlZFxuICAvL1xuICAvLyAnY2hhbmdlSW5mbycgY29udGFpbnMgZGV0YWlscyBvZiB3aGF0IGNoYW5nZWQgYWJvdXQgdGhlIHRhYidzIHN0YXR1cy5cbiAgLy8gVHdvIGltcG9ydGFudCBldmVudHMgYXJlIHdoZW4gdGhlIHRhYidzIGBzdGF0dXNgIGNoYW5nZXMgdG8gYGxvYWRpbmdgXG4gIC8vIHdoZW4gdGhlIHVzZXIgYmVnaW5zIGEgbmV3IG5hdmlnYXRpb24gYW5kIHdoZW4gdGhlIHRhYidzIHN0YXR1cyBjaGFuZ2VzXG4gIC8vIHRvIGBjb21wbGV0ZWAgYWZ0ZXIgdGhlIHVzZXIgY29tcGxldGVzIGEgbmF2aWdhdGlvblxuICBmdW5jdGlvbiBvblRhYlVwZGF0ZWQodGFiSWQsIGNoYW5nZUluZm8sIHRhYikge1xuICAgIGlmIChjaGFuZ2VJbmZvLnN0YXR1cyA9PT0gVEFCX1NUQVRVU19MT0FESU5HKSB7XG4gICAgICByZXNldFRhYlN0YXRlKHRhYklkLCB0YWIudXJsKTtcbiAgICAgIHZhciBxdWVyeSA9IGRpcmVjdExpbmtRdWVyeSh0YWIudXJsKTtcbiAgICAgIGlmIChxdWVyeSkge1xuICAgICAgICBzdGF0ZS5zZXRTdGF0ZSh0YWIuaWQsIHsgZGlyZWN0TGlua1F1ZXJ5OiBxdWVyeSB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNoYW5nZUluZm8uc3RhdHVzID09PSBUQUJfU1RBVFVTX0NPTVBMRVRFKSB7XG4gICAgICB2YXIgdGFiU3RhdGUgPSBzdGF0ZS5nZXRTdGF0ZSh0YWJJZCk7XG4gICAgICB2YXIgbmV3QWN0aXZlU3RhdGUgPSB0YWJTdGF0ZS5zdGF0ZTtcbiAgICAgIGlmICh0YWJTdGF0ZS5kaXJlY3RMaW5rUXVlcnkpIHtcbiAgICAgICAgbmV3QWN0aXZlU3RhdGUgPSBUYWJTdGF0ZS5zdGF0ZXMuQUNUSVZFO1xuICAgICAgfVxuICAgICAgc3RhdGUuc2V0U3RhdGUodGFiSWQsIHtcbiAgICAgICAgcmVhZHk6IHRydWUsXG4gICAgICAgIHN0YXRlOiBuZXdBY3RpdmVTdGF0ZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uVGFiUmVwbGFjZWQoYWRkZWRUYWJJZCwgcmVtb3ZlZFRhYklkKSB7XG4gICAgc3RhdGUuc2V0U3RhdGUoYWRkZWRUYWJJZCwge1xuICAgICAgc3RhdGU6IGFjdGl2ZVN0YXRlRm9yTmF2aWdhdGVkVGFiKHJlbW92ZWRUYWJJZCksXG4gICAgICByZWFkeTogdHJ1ZSxcbiAgICB9KTtcbiAgICBzdGF0ZS5jbGVhclRhYihyZW1vdmVkVGFiSWQpO1xuXG4gICAgY2hyb21lVGFicy5nZXQoYWRkZWRUYWJJZCwgZnVuY3Rpb24gKHRhYikge1xuICAgICAgdXBkYXRlQW5ub3RhdGlvbkNvdW50SWZFbmFibGVkKGFkZGVkVGFiSWQsIHRhYi51cmwpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gb25UYWJDcmVhdGVkKHRhYikge1xuICAgIC8vIENsZWFyIHRoZSBzdGF0ZSBpbiBjYXNlIHRoZXJlIGlzIG9sZCwgY29uZmxpY3RpbmcgZGF0YSBpbiBzdG9yYWdlLlxuICAgIHN0YXRlLmNsZWFyVGFiKHRhYi5pZCk7XG4gIH1cblxuICBmdW5jdGlvbiBvblRhYlJlbW92ZWQodGFiSWQpIHtcbiAgICBzdGF0ZS5jbGVhclRhYih0YWJJZCk7XG4gIH1cblxuICAvLyBpbnN0YWxscyBvciB1bmluc3RhbGxzIHRoZSBzaWRlYmFyIGZyb20gYSB0YWIgd2hlbiB0aGUgSFxuICAvLyBzdGF0ZSBmb3IgYSB0YWIgY2hhbmdlc1xuICBmdW5jdGlvbiB1cGRhdGVUYWJEb2N1bWVudCh0YWIpIHtcbiAgICAvLyBJZiB0aGUgdGFiIGhhcyBub3QgeWV0IGZpbmlzaGVkIGxvYWRpbmcgdGhlbiBqdXN0IHF1aWV0bHkgcmV0dXJuLlxuICAgIGlmICghc3RhdGUuZ2V0U3RhdGUodGFiLmlkKS5yZWFkeSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cblxuICAgIHZhciBpc0luc3RhbGxlZCA9IHN0YXRlLmdldFN0YXRlKHRhYi5pZCkuZXh0ZW5zaW9uU2lkZWJhckluc3RhbGxlZDtcbiAgICBpZiAoc3RhdGUuaXNUYWJBY3RpdmUodGFiLmlkKSAmJiAhaXNJbnN0YWxsZWQpIHtcbiAgICAgIC8vIG9wdGltaXN0aWNhbGx5IHNldCB0aGUgc3RhdGUgZmxhZyBpbmRpY2F0aW5nIHRoYXQgdGhlIHNpZGViYXJcbiAgICAgIC8vIGhhcyBiZWVuIGluc3RhbGxlZFxuICAgICAgc3RhdGUuc2V0U3RhdGUodGFiLmlkLCB7XG4gICAgICAgIGV4dGVuc2lvblNpZGViYXJJbnN0YWxsZWQ6IHRydWUsXG4gICAgICB9KTtcblxuICAgICAgdmFyIHsgZGlyZWN0TGlua1F1ZXJ5IH0gPSBzdGF0ZS5nZXRTdGF0ZSh0YWIuaWQpO1xuXG4gICAgICB2YXIgY29uZmlnID0ge1xuICAgICAgICAvLyBDb25maWd1cmUgY2xpZW50IHRvIGxvYWQgYXNzZXRzIGFuZCBzaWRlYmFyIGFwcCBmcm9tIGV4dGVuc2lvbi5cbiAgICAgICAgLy8gTm90ZTogRXZlbiB0aG91Z2ggdGhlIHNpZGViYXIgYXBwIFVSTCBpcyBjb3JyZWN0IGhlcmUgYW5kIHRoZSBwYWdlXG4gICAgICAgIC8vIGRvZXMgbG9hZCwgQ2hyb21lIGRldnRvb2xzIG1heSBpbmNvcnJlY3RseSByZXBvcnQgdGhhdCBpdCBmYWlsZWQgdG9cbiAgICAgICAgLy8gbG9hZC4gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTY2NzUzM1xuICAgICAgICBhc3NldFJvb3Q6IGNocm9tZUV4dGVuc2lvbi5nZXRVUkwoJy9jbGllbnQvJyksXG4gICAgICAgIHNpZGViYXJBcHBVcmw6IGNocm9tZUV4dGVuc2lvbi5nZXRVUkwoJy9jbGllbnQvYXBwLmh0bWwnKSxcbiAgICAgIH07XG5cbiAgICAgIC8vIFBhc3MgdGhlIGRpcmVjdC1saW5rIHF1ZXJ5IGFzIGNvbmZpZ3VyYXRpb24gaW50byB0aGUgY2xpZW50LlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSByZWFzb24gd2UgZG9uJ3QgcmVseSBvbiBqdXN0IHB1dHRpbmcgdGhpcyBpbnRvIHRoZSBVUkwgYW5kIGxldHRpbmdcbiAgICAgIC8vIHRoZSBjbGllbnQgcGljayBpdCB1cCBpcyB0byBtYWtlIGRpcmVjdC1saW5raW5nIHdvcmsgaW4gc2l0ZXMvYXBwc1xuICAgICAgLy8gdGhhdCBtb2RpZnkgdGhlIFVSTCBmcmFnbWVudCBhcyB0aGV5IGxvYWQuIFNlZSBjb21taXQgMzE0M2NhMjdlMDVkLlxuICAgICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGRpcmVjdExpbmtRdWVyeSk7XG5cbiAgICAgIHJldHVybiBzaWRlYmFyXG4gICAgICAgIC5pbmplY3RJbnRvVGFiKHRhYiwgY29uZmlnKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gQ2xlYXIgdGhlIGRpcmVjdCBsaW5rIG9uY2UgSCBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgaW5qZWN0ZWRcbiAgICAgICAgICBzdGF0ZS5zZXRTdGF0ZSh0YWIuaWQsIHsgZGlyZWN0TGlua1F1ZXJ5OiB1bmRlZmluZWQgfSk7XG4gICAgICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIGVycm9ycy5BbHJlYWR5SW5qZWN0ZWRFcnJvcikge1xuICAgICAgICAgICAgc3RhdGUuc2V0U3RhdGUodGFiLmlkLCB7XG4gICAgICAgICAgICAgIHN0YXRlOiBUYWJTdGF0ZS5zdGF0ZXMuSU5BQ1RJVkUsXG4gICAgICAgICAgICAgIGV4dGVuc2lvblNpZGViYXJJbnN0YWxsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZXJyb3JzLnNob3VsZElnbm9yZUluamVjdGlvbkVycm9yKGVycikpIHtcbiAgICAgICAgICAgIGVycm9ycy5yZXBvcnQoZXJyLCAnSW5qZWN0aW5nIEh5cG90aGVzaXMgc2lkZWJhcicsIHtcbiAgICAgICAgICAgICAgdXJsOiB0YWIudXJsLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHN0YXRlLmVycm9yVGFiKHRhYi5pZCwgZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5pc1RhYkluYWN0aXZlKHRhYi5pZCkgJiYgaXNJbnN0YWxsZWQpIHtcbiAgICAgIHJldHVybiBzaWRlYmFyLnJlbW92ZUZyb21UYWIodGFiKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RhdGUuc2V0U3RhdGUodGFiLmlkLCB7XG4gICAgICAgICAgZXh0ZW5zaW9uU2lkZWJhckluc3RhbGxlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVBbm5vdGF0aW9uQ291bnRJZkVuYWJsZWQodGFiSWQsIHVybCkge1xuICAgIGlmICghY2hyb21lU3RvcmFnZS5zeW5jKSB7XG4gICAgICAvLyBGaXJlZm94IDwgNTMgZG9lcyBub3Qgc3VwcG9ydCBgY2hyb21lLnN0b3JhZ2Uuc3luY2AuXG4gICAgICBzdGF0ZS51cGRhdGVBbm5vdGF0aW9uQ291bnQodGFiSWQsIHVybCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2hyb21lU3RvcmFnZS5zeW5jLmdldChcbiAgICAgIHtcbiAgICAgICAgYmFkZ2U6IHRydWUsXG4gICAgICB9LFxuICAgICAgZnVuY3Rpb24gKGl0ZW1zKSB7XG4gICAgICAgIGlmIChpdGVtcy5iYWRnZSkge1xuICAgICAgICAgIHN0YXRlLnVwZGF0ZUFubm90YXRpb25Db3VudCh0YWJJZCwgdXJsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gIH1cbn1cbiIsImltcG9ydCAqIGFzIHJhdmVuIGZyb20gJy4vcmF2ZW4nO1xuXG5pZiAod2luZG93LkVYVEVOU0lPTl9DT05GSUcucmF2ZW4pIHtcbiAgcmF2ZW4uaW5pdCh3aW5kb3cuRVhURU5TSU9OX0NPTkZJRy5yYXZlbik7XG59XG5cbmltcG9ydCAnLi9oeXBvdGhlc2lzLWNocm9tZS1leHRlbnNpb24nO1xuaW1wb3J0ICcuL2luc3RhbGwnO1xuIiwiaW1wb3J0IEh5cG90aGVzaXNDaHJvbWVFeHRlbnNpb24gZnJvbSAnLi9oeXBvdGhlc2lzLWNocm9tZS1leHRlbnNpb24nO1xuXG52YXIgYnJvd3NlckV4dGVuc2lvbjtcblxuZXhwb3J0IGZ1bmN0aW9uIGluaXQoKSB7XG4gIGJyb3dzZXJFeHRlbnNpb24gPSBuZXcgSHlwb3RoZXNpc0Nocm9tZUV4dGVuc2lvbih7XG4gICAgY2hyb21lRXh0ZW5zaW9uOiBjaHJvbWUuZXh0ZW5zaW9uLFxuICAgIGNocm9tZVRhYnM6IGNocm9tZS50YWJzLFxuICAgIGNocm9tZUJyb3dzZXJBY3Rpb246IGNocm9tZS5icm93c2VyQWN0aW9uLFxuICAgIGNocm9tZVN0b3JhZ2U6IGNocm9tZS5zdG9yYWdlLFxuICAgIGV4dGVuc2lvblVSTDogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgIHJldHVybiBjaHJvbWUuZXh0ZW5zaW9uLmdldFVSTChwYXRoKTtcbiAgICB9LFxuICAgIGlzQWxsb3dlZEZpbGVTY2hlbWVBY2Nlc3M6IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGNocm9tZS5leHRlbnNpb24uaXNBbGxvd2VkRmlsZVNjaGVtZUFjY2Vzcyhmbik7XG4gICAgfSxcbiAgfSk7XG5cbiAgYnJvd3NlckV4dGVuc2lvbi5saXN0ZW4od2luZG93KTtcbn1cblxuaWYgKCFjaHJvbWUuaXNGYWtlQ2hyb21lKSB7XG4gIGluaXQoKTtcbn1cblxuaWYgKGNocm9tZS5ydW50aW1lLm9uSW5zdGFsbGVkKSB7XG4gIGNocm9tZS5ydW50aW1lLm9uSW5zdGFsbGVkLmFkZExpc3RlbmVyKG9uSW5zdGFsbGVkKTtcbn1cblxuLy8gUmVzcG9uZCB0byBtZXNzYWdlcyBzZW50IGJ5IHRoZSBKYXZhU2NyaXB0IGZyb20gaHR0cHM6Ly9oeXAuaXMuXG4vLyBUaGlzIGlzIGhvdyBpdCBrbm93cyB3aGV0aGVyIHRoZSB1c2VyIGhhcyB0aGlzIENocm9tZSBleHRlbnNpb24gaW5zdGFsbGVkLlxuaWYgKGNocm9tZS5ydW50aW1lLm9uTWVzc2FnZUV4dGVybmFsKSB7XG4gIGNocm9tZS5ydW50aW1lLm9uTWVzc2FnZUV4dGVybmFsLmFkZExpc3RlbmVyKGZ1bmN0aW9uIChcbiAgICByZXF1ZXN0LFxuICAgIHNlbmRlcixcbiAgICBzZW5kUmVzcG9uc2VcbiAgKSB7XG4gICAgaWYgKHJlcXVlc3QudHlwZSA9PT0gJ3BpbmcnKSB7XG4gICAgICBzZW5kUmVzcG9uc2UoeyB0eXBlOiAncG9uZycgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuaWYgKGNocm9tZS5ydW50aW1lLnJlcXVlc3RVcGRhdGVDaGVjaykge1xuICBjaHJvbWUucnVudGltZS5yZXF1ZXN0VXBkYXRlQ2hlY2soZnVuY3Rpb24gKCkge1xuICAgIGNocm9tZS5ydW50aW1lLm9uVXBkYXRlQXZhaWxhYmxlLmFkZExpc3RlbmVyKG9uVXBkYXRlQXZhaWxhYmxlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG9uSW5zdGFsbGVkKGluc3RhbGxEZXRhaWxzKSB7XG4gIC8vIFRoZSBpbnN0YWxsIHJlYXNvbiBjYW4gYmUgXCJpbnN0YWxsXCIsIFwidXBkYXRlXCIsIFwiY2hyb21lX3VwZGF0ZVwiLCBvclxuICAvLyBcInNoYXJlZF9tb2R1bGVfdXBkYXRlXCIsIHNlZTpcbiAgLy9cbiAgLy8gICBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvcnVudGltZSN0eXBlLU9uSW5zdGFsbGVkUmVhc29uXG4gIC8vXG4gIC8vIElmIHdlIHdlcmUgaW5zdGFsbGVkIChyYXRoZXIgdGhhbiB1cGRhdGVkKSB0aGVuIHRyaWdnZXIgYSBcImZpcnN0UnVuXCIgZXZlbnQsXG4gIC8vIHBhc3NpbmcgaW4gdGhlIGRldGFpbHMgb2YgdGhlIGluc3RhbGxlZCBleHRlbnNpb24uIFNlZTpcbiAgLy9cbiAgLy8gICBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvbWFuYWdlbWVudCNtZXRob2QtZ2V0U2VsZlxuICAvL1xuICBpZiAoaW5zdGFsbERldGFpbHMucmVhc29uID09PSAnaW5zdGFsbCcpIHtcbiAgICBjaHJvbWUubWFuYWdlbWVudC5nZXRTZWxmKGJyb3dzZXJFeHRlbnNpb24uZmlyc3RSdW4pO1xuICB9XG5cbiAgYnJvd3NlckV4dGVuc2lvbi5pbnN0YWxsKCk7XG59XG5cbmZ1bmN0aW9uIG9uVXBkYXRlQXZhaWxhYmxlKCkge1xuICBjaHJvbWUucnVudGltZS5yZWxvYWQoKTtcbn1cbiIsIi8qKlxuICogVGhpcyBtb2R1bGUgY29uZmlndXJlcyBSYXZlbiBmb3IgcmVwb3J0aW5nIGNyYXNoZXNcbiAqIHRvIFNlbnRyeS5cbiAqXG4gKiBMb2dnaW5nIHJlcXVpcmVzIHRoZSBTZW50cnkgRFNOIGFuZCBIeXBvdGhlc2lzXG4gKiB2ZXJzaW9uIHRvIGJlIHByb3ZpZGVkIHZpYSB0aGUgYXBwJ3Mgc2V0dGluZ3Mgb2JqZWN0LlxuICovXG5cbmltcG9ydCBSYXZlbiBmcm9tICdyYXZlbi1qcyc7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW5wdXQgVVJMIGlmIGl0IGlzIGFuIEhUVFAgVVJMIG9yIHRoZSBmaWxlbmFtZSBwYXJ0IG9mIHRoZSBVUkxcbiAqIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIHNjcmlwdCBVUkwgYXNzb2NpYXRlZCB3aXRoIGFuIGV4Y2VwdGlvbiBzdGFja1xuICogICAgICAgICAgICAgICAgICAgICAgIGZyYW1lLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0TG9jYWxVUkxzVG9GaWxlbmFtZXModXJsKSB7XG4gIGlmICghdXJsKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIGlmICh1cmwubWF0Y2goL2h0dHBzPzovKSkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICAvLyBTdHJpcCB0aGUgcXVlcnkgc3RyaW5nICh3aGljaCBpcyB1c2VkIGFzIGEgY2FjaGUgYnVzdGVyKVxuICAvLyBhbmQgZXh0cmFjdCB0aGUgZmlsZW5hbWUgZnJvbSB0aGUgVVJMXG4gIHJldHVybiB1cmwucmVwbGFjZSgvXFw/LiovLCAnJykuc3BsaXQoJy8nKS5zbGljZSgtMSlbMF07XG59XG5cbi8qKlxuICogUmV0dXJuIGEgdHJhbnNmb3JtZWQgdmVyc2lvbiBvZiBgZGF0YWAgd2l0aCBsb2NhbCBVUkxzIHJlcGxhY2VkXG4gKiB3aXRoIGZpbGVuYW1lcy5cbiAqXG4gKiBJbiBlbnZpcm9ubWVudHMgd2hlcmUgdGhlIGNsaWVudCBpcyBzZXJ2ZWQgZnJvbSBhIGxvY2FsIFVSTCxcbiAqIGVnLiBjaHJvbWUtZXh0ZW5zaW9uOi8vPElEPi9zY3JpcHRzL2J1bmRsZS5qcywgdGhlIHNjcmlwdCBVUkxcbiAqIGFuZCB0aGUgc291cmNlbWFwIGl0IHJlZmVyZW5jZXMgd2lsbCBub3QgYmUgYWNjZXNzaWJsZSB0byBTZW50cnkuXG4gKlxuICogVGhlcmVmb3JlIG9uIHRoZSBjbGllbnQgd2UgcmVwbGFjZSByZWZlcmVuY2VzIHRvIHN1Y2ggVVJMcyB3aXRoIGp1c3RcbiAqIHRoZSBmaWxlbmFtZSBwYXJ0IGFuZCB0aGVuIGFzIHBhcnQgb2YgdGhlIHJlbGVhc2UgcHJvY2VzcywgdXBsb2FkIGJvdGhcbiAqIHRoZSBzb3VyY2UgZmlsZSBhbmQgdGhlIHNvdXJjZSBtYXAgdG8gU2VudHJ5LlxuICpcbiAqIFVzaW5nIGp1c3QgdGhlIGZpbGVuYW1lIGFsbG93cyB1cyB0byB1cGxvYWQgYSBzaW5nbGUgc2V0IG9mIHNvdXJjZSBmaWxlc1xuICogYW5kIHNvdXJjZW1hcHMgZm9yIGEgcmVsZWFzZSB0aG91Z2ggYSBnaXZlbiByZWxlYXNlIG9mIEggbWlnaHQgYmUgc2VydmVkXG4gKiBmcm9tIG11bHRpcGxlIGFjdHVhbCBVUkxzIChlZy4gZGlmZmVyZW50IGJyb3dzZXIgZXh0ZW5zaW9ucykuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zbGF0ZVNvdXJjZVVSTHMoZGF0YSkge1xuICB0cnkge1xuICAgIHZhciBmcmFtZXMgPSBkYXRhLmV4Y2VwdGlvbi52YWx1ZXNbMF0uc3RhY2t0cmFjZS5mcmFtZXM7XG4gICAgZnJhbWVzLmZvckVhY2goZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICBmcmFtZS5maWxlbmFtZSA9IGNvbnZlcnRMb2NhbFVSTHNUb0ZpbGVuYW1lcyhmcmFtZS5maWxlbmFtZSk7XG4gICAgfSk7XG4gICAgZGF0YS5jdWxwcml0ID0gZnJhbWVzWzBdLmZpbGVuYW1lO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBjb25zb2xlLndhcm4oJ0ZhaWxlZCB0byBub3JtYWxpemUgZXJyb3Igc3RhY2sgdHJhY2UnLCBlcnIsIGRhdGEpO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5pdChjb25maWcpIHtcbiAgUmF2ZW4uY29uZmlnKGNvbmZpZy5kc24sIHtcbiAgICByZWxlYXNlOiBjb25maWcucmVsZWFzZSxcbiAgICBkYXRhQ2FsbGJhY2s6IHRyYW5zbGF0ZVNvdXJjZVVSTHMsXG4gIH0pLmluc3RhbGwoKTtcbiAgaW5zdGFsbFVuaGFuZGxlZFByb21pc2VFcnJvckhhbmRsZXIoKTtcbn1cblxuLyoqXG4gKiBSZXBvcnQgYW4gZXJyb3IgdG8gU2VudHJ5LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIC0gQW4gZXJyb3Igb2JqZWN0IGRlc2NyaWJpbmcgd2hhdCB3ZW50IHdyb25nXG4gKiBAcGFyYW0ge3N0cmluZ30gd2hlbiAtIEEgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGNvbnRleHQgaW4gd2hpY2hcbiAqICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGVycm9yIG9jY3VycmVkLlxuICogQHBhcmFtIHtPYmplY3R9IFtjb250ZXh0XSAtIEEgSlNPTi1zZXJpYWxpemFibGUgb2JqZWN0IGNvbnRhaW5pbmcgYWRkaXRpb25hbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uIHdoaWNoIG1heSBiZSB1c2VmdWwgd2hlblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludmVzdGlnYXRpbmcgdGhlIGVycm9yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0KGVycm9yLCB3aGVuLCBjb250ZXh0KSB7XG4gIGlmICghKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgLy8gSWYgdGhlIHBhc3NlZCBvYmplY3QgaXMgbm90IGFuIEVycm9yLCByYXZlbi1qc1xuICAgIC8vIHdpbGwgc2VyaWFsaXplIGl0IHVzaW5nIHRvU3RyaW5nKCkgd2hpY2ggcHJvZHVjZXMgdW5oZWxwZnVsIHJlc3VsdHNcbiAgICAvLyBmb3Igb2JqZWN0cyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZWlyIG93biB0b1N0cmluZygpIGltcGxlbWVudGF0aW9ucy5cbiAgICAvL1xuICAgIC8vIElmIHRoZSBlcnJvciBpcyBhIHBsYWluIG9iamVjdCBvciBub24tRXJyb3Igc3ViY2xhc3Mgd2l0aCBhIG1lc3NhZ2VcbiAgICAvLyBwcm9wZXJ0eSwgc3VjaCBhcyBlcnJvcnMgcmV0dXJuZWQgYnkgY2hyb21lLmV4dGVuc2lvbi5sYXN0RXJyb3IsXG4gICAgLy8gdXNlIHRoYXQgaW5zdGVhZC5cbiAgICBpZiAodHlwZW9mIGVycm9yID09PSAnb2JqZWN0JyAmJiBlcnJvci5tZXNzYWdlKSB7XG4gICAgICBlcnJvciA9IGVycm9yLm1lc3NhZ2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIGV4dHJhID0gT2JqZWN0LmFzc2lnbih7IHdoZW46IHdoZW4gfSwgY29udGV4dCk7XG4gIFJhdmVuLmNhcHR1cmVFeGNlcHRpb24oZXJyb3IsIHsgZXh0cmE6IGV4dHJhIH0pO1xufVxuXG4vKipcbiAqIEluc3RhbGxzIGEgaGFuZGxlciB0byBjYXRjaCB1bmhhbmRsZWQgcmVqZWN0ZWQgcHJvbWlzZXMuXG4gKlxuICogRm9yIHRoaXMgdG8gd29yaywgdGhlIGJyb3dzZXIgb3IgdGhlIFByb21pc2UgcG9seWZpbGwgbXVzdCBzdXBwb3J0XG4gKiB0aGUgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uIGV2ZW50IChDaHJvbWUgPj0gNDkpLiBPbiBvdGhlciBicm93c2VycyxcbiAqIHRoZSByZWplY3Rpb25zIHdpbGwgc2ltcGx5IGdvIHVubm90aWNlZC4gVGhlcmVmb3JlLCBhcHAgY29kZSBfc2hvdWxkX1xuICogYWx3YXlzIHByb3ZpZGUgYSAuY2F0Y2goKSBoYW5kbGVyIG9uIHRoZSB0b3AtbW9zdCBwcm9taXNlIGNoYWluLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZ2V0c2VudHJ5L3JhdmVuLWpzL2lzc3Vlcy80MjRcbiAqIGFuZCBodHRwczovL3d3dy5jaHJvbWVzdGF0dXMuY29tL2ZlYXR1cmUvNDgwNTg3MjIxMTQ2MDA5NlxuICpcbiAqIEl0IGlzIHBvc3NpYmxlIHRoYXQgZnV0dXJlIHZlcnNpb25zIG9mIFJhdmVuIEpTIG1heSBoYW5kbGUgdGhlc2UgZXZlbnRzXG4gKiBhdXRvbWF0aWNhbGx5LCBpbiB3aGljaCBjYXNlIHRoaXMgY29kZSBjYW4gc2ltcGx5IGJlIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIGluc3RhbGxVbmhhbmRsZWRQcm9taXNlRXJyb3JIYW5kbGVyKCkge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndW5oYW5kbGVkcmVqZWN0aW9uJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnJlYXNvbikge1xuICAgICAgcmVwb3J0KGV2ZW50LnJlYXNvbiwgJ1VuaGFuZGxlZCBQcm9taXNlIHJlamVjdGlvbicpO1xuICAgIH1cbiAgfSk7XG59XG4iLCIvKipcbiAqIFZhbGlkYXRlIGFuZCBub3JtYWxpemUgdGhlIGdpdmVuIHNldHRpbmdzIGRhdGEuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzIFRoZSBzZXR0aW5ncyBmcm9tIHRoZSBzZXR0aW5ncy5qc29uIGZpbGUuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVNldHRpbmdzKHNldHRpbmdzKSB7XG4gIC8vIE1ha2Ugc3VyZSB0aGF0IGFwaVVybCBkb2VzIG5vdCBlbmQgd2l0aCBhIC8uXG4gIGlmIChzZXR0aW5ncy5hcGlVcmwuY2hhckF0KHNldHRpbmdzLmFwaVVybC5sZW5ndGggLSAxKSA9PT0gJy8nKSB7XG4gICAgc2V0dGluZ3MuYXBpVXJsID0gc2V0dGluZ3MuYXBpVXJsLnNsaWNlKDAsIC0xKTtcbiAgfVxuICByZXR1cm4gc2V0dGluZ3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBDaHJvbWUgZXh0ZW5zaW9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IG5vcm1hbGl6ZVNldHRpbmdzKHdpbmRvdy5FWFRFTlNJT05fQ09ORklHKTtcbiIsImltcG9ydCAqIGFzIHF1ZXJ5U3RyaW5nIGZyb20gJ3F1ZXJ5LXN0cmluZyc7XG5cbmltcG9ydCBkZXRlY3RDb250ZW50VHlwZSBmcm9tICcuL2RldGVjdC1jb250ZW50LXR5cGUnO1xuaW1wb3J0ICogYXMgZXJyb3JzIGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi91dGlsJztcblxudmFyIENPTlRFTlRfVFlQRV9IVE1MID0gJ0hUTUwnO1xudmFyIENPTlRFTlRfVFlQRV9QREYgPSAnUERGJztcblxuZnVuY3Rpb24gdG9JSUZFU3RyaW5nKGZuKSB7XG4gIHJldHVybiAnKCcgKyBmbi50b1N0cmluZygpICsgJykoKSc7XG59XG5cbi8qKlxuICogQWRkcyBhIDxzY3JpcHQ+IHRhZyBjb250YWluaW5nIEpTT04gY29uZmlnIGRhdGEgdG8gdGhlIHBhZ2UuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgc3RyaW5naWZpZWQgYW5kIGluamVjdGVkIGludG8gdGhlIHBhZ2UgdmlhIGFcbiAqIGNvbnRlbnQgc2NyaXB0LCBzbyBpdCBjYW5ub3QgcmVmZXJlbmNlIGFueSBleHRlcm5hbCB2YXJpYWJsZXMuXG4gKi9cbmZ1bmN0aW9uIGFkZEpTT05TY3JpcHRUYWdGbihuYW1lLCBjb250ZW50KSB7XG4gIHZhciBzY3JpcHRUYWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgc2NyaXB0VGFnLmNsYXNzTmFtZSA9IG5hbWU7XG4gIHNjcmlwdFRhZy50ZXh0Q29udGVudCA9IGNvbnRlbnQ7XG4gIHNjcmlwdFRhZy50eXBlID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdFRhZyk7XG59XG5cbi8qKlxuICogRXh0cmFjdCB0aGUgdmFsdWUgcmV0dXJuZWQgYnkgYSBjb250ZW50IHNjcmlwdCBpbmplY3RlZCB2aWFcbiAqIGNocm9tZS50YWJzLmV4ZWN1dGVTY3JpcHQoKSBpbnRvIHRoZSBtYWluIGZyYW1lIG9mIGEgcGFnZS5cbiAqXG4gKiBleGVjdXRlU2NyaXB0KCkgcmV0dXJucyBhbiBhcnJheSBvZiByZXN1bHRzLCBvbmUgcGVyIGZyYW1lIHdoaWNoIHRoZSBzY3JpcHRcbiAqIHdhcyBpbmplY3RlZCBpbnRvLlxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvdGFicyNtZXRob2QtZXhlY3V0ZVNjcmlwdFxuICpcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pj99IHJlc3VsdFxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29udGVudFNjcmlwdFJlc3VsdChyZXN1bHQpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSAmJiByZXN1bHQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiByZXN1bHRbMF07XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcpIHtcbiAgICAvLyBGaXJlZm94IGN1cnJlbnRseSByZXR1cm5zIGFuIG9iamVjdCBpbnN0ZWFkIG9mXG4gICAgLy8gYW4gYXJyYXkgZnJvbSBleGVjdXRlU2NyaXB0KClcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qIFRoZSBTaWRlYmFySW5qZWN0b3IgaXMgdXNlZCB0byBkZXBsb3kgYW5kIHJlbW92ZSB0aGUgSHlwb3RoZXNpcyBzaWRlYmFyXG4gKiBmcm9tIHRhYnMuIEl0IGFsc28gZGVhbHMgd2l0aCBsb2FkaW5nIFBERiBkb2N1bWVudHMgaW50byB0aGUgUERGLmpzIHZpZXdlclxuICogd2hlbiBhcHBsaWNhYmxlLlxuICpcbiAqIGNocm9tZVRhYnMgLSBBbiBpbnN0YW5jZSBvZiBjaHJvbWUudGFicy5cbiAqIGRlcGVuZGVuY2llcyAtIEFuIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgaGVscGVyIG1ldGhvZHMuXG4gKiAgIGlzQWxsb3dlZEZpbGVTY2hlbWVBY2Nlc3M6IEEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlIHVzZXJcbiAqICAgY2FuIGFjY2VzcyByZXNvdXJjZXMgb3ZlciB0aGUgZmlsZTovLyBwcm90b2NvbC4gU2VlOlxuICogICBodHRwczovL2RldmVsb3Blci5jaHJvbWUuY29tL2V4dGVuc2lvbnMvZXh0ZW5zaW9uI21ldGhvZC1pc0FsbG93ZWRGaWxlU2NoZW1lQWNjZXNzXG4gKiAgIGV4dGVuc2lvblVSTDogQSBmdW5jdGlvbiB0aGF0IHJlY2VpdmVzIGEgcGF0aCBhbmQgcmV0dXJucyBhbiBhYnNvbHV0ZVxuICogICB1cmwuIFNlZTogaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL2V4dGVuc2lvbiNtZXRob2QtZ2V0VVJMXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFNpZGViYXJJbmplY3RvcihjaHJvbWVUYWJzLCBkZXBlbmRlbmNpZXMpIHtcbiAgZGVwZW5kZW5jaWVzID0gZGVwZW5kZW5jaWVzIHx8IHt9O1xuXG4gIHZhciBpc0FsbG93ZWRGaWxlU2NoZW1lQWNjZXNzID0gZGVwZW5kZW5jaWVzLmlzQWxsb3dlZEZpbGVTY2hlbWVBY2Nlc3M7XG4gIHZhciBleHRlbnNpb25VUkwgPSBkZXBlbmRlbmNpZXMuZXh0ZW5zaW9uVVJMO1xuXG4gIHZhciBleGVjdXRlU2NyaXB0Rm4gPSB1dGlsLnByb21pc2lmeShjaHJvbWVUYWJzLmV4ZWN1dGVTY3JpcHQpO1xuXG4gIHZhciBQREZWaWV3ZXJCYXNlVVJMID0gZXh0ZW5zaW9uVVJMKCcvcGRmanMvd2ViL3ZpZXdlci5odG1sJyk7XG5cbiAgaWYgKHR5cGVvZiBleHRlbnNpb25VUkwgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleHRlbnNpb25VUkwgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGlzQWxsb3dlZEZpbGVTY2hlbWVBY2Nlc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpc0FsbG93ZWRGaWxlU2NoZW1lQWNjZXNzIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluamVjdHMgdGhlIEh5cG90aGVzaXMgc2lkZWJhciBpbnRvIHRoZSB0YWIgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7VGFifSB0YWIgLSBBIHRhYiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSB0YWIgdG8gaW5zZXJ0IHRoZSBzaWRlYmFyXG4gICAqICAgICAgICBpbnRvLlxuICAgKiBAcGFyYW0ge09iamVjdD99IGNvbmZpZyAtIEFuIG9iamVjdCBjb250YWluaW5nIGNvbmZpZ3VyYXRpb24gaW5mbyB0aGF0XG4gICAqICAgICAgICBpcyBwYXNzZWQgdG8gdGhlIGFwcCB3aGVuIGl0IGxvYWRzLlxuICAgKlxuICAgKiBSZXR1cm5zIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgaWYgdGhlIGluamVjdGlvbiBzdWNjZWVkZWRcbiAgICogb3RoZXJ3aXNlIGl0IHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvci5cbiAgICovXG4gIHRoaXMuaW5qZWN0SW50b1RhYiA9IGZ1bmN0aW9uICh0YWIsIGNvbmZpZykge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgICBpZiAoaXNGaWxlVVJMKHRhYi51cmwpKSB7XG4gICAgICByZXR1cm4gaW5qZWN0SW50b0xvY2FsRG9jdW1lbnQodGFiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGluamVjdEludG9SZW1vdGVEb2N1bWVudCh0YWIsIGNvbmZpZyk7XG4gICAgfVxuICB9O1xuXG4gIC8qIFJlbW92ZXMgdGhlIEh5cG90aGVzaXMgc2lkZWJhciBmcm9tIHRoZSB0YWIgcHJvdmlkZWQuXG4gICAqXG4gICAqIHRhYiAtIEEgdGFiIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHRhYiB0byByZW1vdmUgdGhlIHNpZGViYXIgZnJvbS5cbiAgICpcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIGlmIHRoZSByZW1vdmFsIHN1Y2NlZWRlZFxuICAgKiBvdGhlcndpc2UgaXQgd2lsbCBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxuICAgKi9cbiAgdGhpcy5yZW1vdmVGcm9tVGFiID0gZnVuY3Rpb24gKHRhYikge1xuICAgIGlmIChpc1BERlZpZXdlclVSTCh0YWIudXJsKSkge1xuICAgICAgcmV0dXJuIHJlbW92ZUZyb21QREYodGFiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlbW92ZUZyb21IVE1MKHRhYik7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldFBERlZpZXdlclVSTCh1cmwpIHtcbiAgICAvLyBFbmNvZGUgdGhlIG9yaWdpbmFsIFVSTCBidXQgcHJlc2VydmUgdGhlIGZyYWdtZW50LCBzbyB0aGF0IGFcbiAgICAvLyAnI2Fubm90YXRpb25zJyBmcmFnbWVudCBpbiB0aGUgb3JpZ2luYWwgVVJMIHdpbGwgcGVyc2lzdCBhbmQgdHJpZ2dlciB0aGVcbiAgICAvLyBzaWRlYmFyIHRvIGZvY3VzIGFuZCBzY3JvbGwgdG8gdGhhdCBhbm5vdGF0aW9uIHdoZW4gdGhlIFBERiB2aWV3ZXIgbG9hZHMuXG4gICAgdmFyIHBhcnNlZFVSTCA9IG5ldyBVUkwodXJsKTtcbiAgICB2YXIgaGFzaCA9IHBhcnNlZFVSTC5oYXNoO1xuICAgIHBhcnNlZFVSTC5oYXNoID0gJyc7XG4gICAgdmFyIGVuY29kZWRVUkwgPSBlbmNvZGVVUklDb21wb25lbnQocGFyc2VkVVJMLmhyZWYpO1xuICAgIHJldHVybiBQREZWaWV3ZXJCYXNlVVJMICsgJz9maWxlPScgKyBlbmNvZGVkVVJMICsgaGFzaDtcbiAgfVxuXG4gIC8vIHJldHVybnMgdHJ1ZSBpZiB0aGUgZXh0ZW5zaW9uIGlzIHBlcm1pdHRlZCB0byBpbmplY3RcbiAgLy8gYSBjb250ZW50IHNjcmlwdCBpbnRvIGEgdGFiIHdpdGggYSBnaXZlbiBVUkwuXG4gIGZ1bmN0aW9uIGNhbkluamVjdFNjcmlwdCh1cmwpIHtcbiAgICB2YXIgY2FuSW5qZWN0O1xuICAgIGlmIChpc1N1cHBvcnRlZFVSTCh1cmwpKSB7XG4gICAgICBjYW5JbmplY3QgPSBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgfSBlbHNlIGlmIChpc0ZpbGVVUkwodXJsKSkge1xuICAgICAgY2FuSW5qZWN0ID0gdXRpbC5wcm9taXNpZnkoaXNBbGxvd2VkRmlsZVNjaGVtZUFjY2VzcykoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuSW5qZWN0ID0gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbkluamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHdWVzcyB0aGUgY29udGVudCB0eXBlIG9mIGEgcGFnZSBmcm9tIHRoZSBVUkwgYWxvbmUuXG4gICAqXG4gICAqIFRoaXMgaXMgYSBmYWxsYmFjayBmb3Igd2hlbiBpdCBpcyBub3QgcG9zc2libGUgdG8gaW5qZWN0XG4gICAqIGEgY29udGVudCBzY3JpcHQgdG8gZGV0ZXJtaW5lIHRoZSB0eXBlIG9mIGNvbnRlbnQgaW4gdGhlIHBhZ2UuXG4gICAqL1xuICBmdW5jdGlvbiBndWVzc0NvbnRlbnRUeXBlRnJvbVVSTCh1cmwpIHtcbiAgICBpZiAodXJsLmluZGV4T2YoJy5wZGYnKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBDT05URU5UX1RZUEVfUERGO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQ09OVEVOVF9UWVBFX0hUTUw7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0ZWN0VGFiQ29udGVudFR5cGUodGFiKSB7XG4gICAgaWYgKGlzUERGVmlld2VyVVJMKHRhYi51cmwpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKENPTlRFTlRfVFlQRV9QREYpO1xuICAgIH1cblxuICAgIHJldHVybiBjYW5JbmplY3RTY3JpcHQodGFiLnVybCkudGhlbihmdW5jdGlvbiAoY2FuSW5qZWN0KSB7XG4gICAgICBpZiAoY2FuSW5qZWN0KSB7XG4gICAgICAgIHJldHVybiBleGVjdXRlU2NyaXB0Rm4odGFiLmlkLCB7XG4gICAgICAgICAgY29kZTogdG9JSUZFU3RyaW5nKGRldGVjdENvbnRlbnRUeXBlKSxcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoZnJhbWVSZXN1bHRzKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGV4dHJhY3RDb250ZW50U2NyaXB0UmVzdWx0KGZyYW1lUmVzdWx0cyk7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50eXBlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY29udGVudCBzY3JpcHQgdGhyZXcgYW4gZXhjZXB0aW9uLFxuICAgICAgICAgICAgLy8gZnJhbWVSZXN1bHRzIG1heSBiZSBudWxsIG9yIHVuZGVmaW5lZC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIGZhbGwgYmFjayB0byBndWVzc2luZyBiYXNlZCBvbiB0aGVcbiAgICAgICAgICAgIC8vIHRhYiBVUkxcbiAgICAgICAgICAgIHJldHVybiBndWVzc0NvbnRlbnRUeXBlRnJvbVVSTCh0YWIudXJsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgY2Fubm90IGluamVjdCBhIGNvbnRlbnQgc2NyaXB0IGluIG9yZGVyIHRvIGRldGVybWluZSB0aGVcbiAgICAgICAgLy8gZmlsZSB0eXBlLCBzbyBmYWxsIGJhY2sgdG8gYSBVUkwtYmFzZWQgbWVjaGFuaXNtXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZ3Vlc3NDb250ZW50VHlwZUZyb21VUkwodGFiLnVybCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIHRhYiBpcyBkaXNwbGF5aW5nIGEgUERGIHVzaW5nIHRoZSBQREYuanMtYmFzZWRcbiAgICogdmlld2VyIGJ1bmRsZWQgd2l0aCB0aGUgZXh0ZW5zaW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gaXNQREZWaWV3ZXJVUkwodXJsKSB7XG4gICAgcmV0dXJuIHVybC5pbmRleE9mKFBERlZpZXdlckJhc2VVUkwpID09PSAwO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNGaWxlVVJMKHVybCkge1xuICAgIHJldHVybiB1cmwuaW5kZXhPZignZmlsZTonKSA9PT0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3VwcG9ydGVkVVJMKHVybCkge1xuICAgIC8vIEluamVjdGlvbiBvZiBjb250ZW50IHNjcmlwdHMgaXMgbGltaXRlZCB0byBhIHNtYWxsIG51bWJlciBvZiBwcm90b2NvbHMsXG4gICAgLy8gc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vZXh0ZW5zaW9ucy9tYXRjaF9wYXR0ZXJuc1xuICAgIHZhciBwYXJzZWRVUkwgPSBuZXcgVVJMKHVybCk7XG4gICAgdmFyIFNVUFBPUlRFRF9QUk9UT0NPTFMgPSBbJ2h0dHA6JywgJ2h0dHBzOicsICdmdHA6J107XG4gICAgcmV0dXJuIFNVUFBPUlRFRF9QUk9UT0NPTFMuc29tZShmdW5jdGlvbiAocHJvdG9jb2wpIHtcbiAgICAgIHJldHVybiBwYXJzZWRVUkwucHJvdG9jb2wgPT09IHByb3RvY29sO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5qZWN0SW50b0xvY2FsRG9jdW1lbnQodGFiKSB7XG4gICAgcmV0dXJuIGRldGVjdFRhYkNvbnRlbnRUeXBlKHRhYikudGhlbihmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IENPTlRFTlRfVFlQRV9QREYpIHtcbiAgICAgICAgcmV0dXJuIGluamVjdEludG9Mb2NhbFBERih0YWIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KFxuICAgICAgICAgIG5ldyBlcnJvcnMuTG9jYWxGaWxlRXJyb3IoJ0xvY2FsIG5vbi1QREYgZmlsZXMgYXJlIG5vdCBzdXBwb3J0ZWQnKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5qZWN0SW50b1JlbW90ZURvY3VtZW50KHRhYiwgY29uZmlnKSB7XG4gICAgaWYgKGlzUERGVmlld2VyVVJMKHRhYi51cmwpKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc1N1cHBvcnRlZFVSTCh0YWIudXJsKSkge1xuICAgICAgLy8gQ2hyb21lIGRvZXMgbm90IHBlcm1pdCBleHRlbnNpb25zIHRvIGluamVjdCBjb250ZW50IHNjcmlwdHNcbiAgICAgIC8vIGludG8gKGNocm9tZSopOi8vIFVSTHMgYW5kIG90aGVyIGN1c3RvbSBzY2hlbWVzLlxuICAgICAgLy9cbiAgICAgIC8vIEEgY29tbW9uIGNhc2Ugd2hlcmUgdGhpcyBoYXBwZW5zIGlzIHdoZW4gdGhlIHVzZXIgaGFzIGFuXG4gICAgICAvLyBleHRlbnNpb24gaW5zdGFsbGVkIHRoYXQgcHJvdmlkZXMgYSBjdXN0b20gdmlld2VyIGZvciBQREZzXG4gICAgICAvLyAob3Igc29tZSBvdGhlciBmb3JtYXQpLiBJbiBzb21lIGNhc2VzIHdlIGNvdWxkIGV4dHJhY3QgdGhlIG9yaWdpbmFsXG4gICAgICAvLyBVUkwgYW5kIG9wZW4gdGhhdCBpbiB0aGUgSHlwb3RoZXNpcyB2aWV3ZXIgaW5zdGVhZC5cbiAgICAgIHZhciBwcm90b2NvbCA9IHRhYi51cmwuc3BsaXQoJzonKVswXTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChcbiAgICAgICAgbmV3IGVycm9ycy5SZXN0cmljdGVkUHJvdG9jb2xFcnJvcihcbiAgICAgICAgICAnQ2Fubm90IGxvYWQgSHlwb3RoZXNpcyBpbnRvICcgKyBwcm90b2NvbCArICcgcGFnZXMnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRldGVjdFRhYkNvbnRlbnRUeXBlKHRhYikudGhlbihmdW5jdGlvbiAodHlwZSkge1xuICAgICAgaWYgKHR5cGUgPT09IENPTlRFTlRfVFlQRV9QREYpIHtcbiAgICAgICAgcmV0dXJuIGluamVjdEludG9QREYodGFiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBpbmplY3RDb25maWcodGFiLmlkLCBjb25maWcpXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGluamVjdEludG9IVE1MKHRhYik7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGV4dHJhY3RDb250ZW50U2NyaXB0UmVzdWx0KHJlc3VsdHMpO1xuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICByZXN1bHQgJiZcbiAgICAgICAgICAgICAgdHlwZW9mIHJlc3VsdC5pbnN0YWxsZWRVUkwgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgIHJlc3VsdC5pbnN0YWxsZWRVUkwuaW5kZXhPZihleHRlbnNpb25VUkwoJy8nKSkgPT09IC0xXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9ycy5BbHJlYWR5SW5qZWN0ZWRFcnJvcihcbiAgICAgICAgICAgICAgICAnSHlwb3RoZXNpcyBpcyBhbHJlYWR5IGluamVjdGVkIGludG8gdGhpcyBwYWdlJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5qZWN0SW50b1BERih0YWIpIHtcbiAgICBpZiAoaXNQREZWaWV3ZXJVUkwodGFiLnVybCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgdmFyIHVwZGF0ZUZuID0gdXRpbC5wcm9taXNpZnkoY2hyb21lVGFicy51cGRhdGUpO1xuICAgIHJldHVybiB1cGRhdGVGbih0YWIuaWQsIHsgdXJsOiBnZXRQREZWaWV3ZXJVUkwodGFiLnVybCkgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbmplY3RJbnRvTG9jYWxQREYodGFiKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGlzQWxsb3dlZEZpbGVTY2hlbWVBY2Nlc3MoZnVuY3Rpb24gKGlzQWxsb3dlZCkge1xuICAgICAgICBpZiAoaXNBbGxvd2VkKSB7XG4gICAgICAgICAgcmVzb2x2ZShpbmplY3RJbnRvUERGKHRhYikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlamVjdChcbiAgICAgICAgICAgIG5ldyBlcnJvcnMuTm9GaWxlQWNjZXNzRXJyb3IoJ0xvY2FsIGZpbGUgc2NoZW1lIGFjY2VzcyBkZW5pZWQnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5qZWN0SW50b0hUTUwodGFiKSB7XG4gICAgcmV0dXJuIGluamVjdFNjcmlwdCh0YWIuaWQsICcvY2xpZW50L2J1aWxkL2Jvb3QuanMnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZUZyb21QREYodGFiKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICB2YXIgcGFyc2VkVVJMID0gbmV3IFVSTCh0YWIudXJsKTtcbiAgICAgIHZhciBvcmlnaW5hbFVSTCA9IHF1ZXJ5U3RyaW5nLnBhcnNlKHBhcnNlZFVSTC5zZWFyY2gpLmZpbGU7XG4gICAgICBpZiAoIW9yaWdpbmFsVVJMKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGV4dHJhY3Qgb3JpZ2luYWwgVVJMIGZyb20gJyArIHRhYi51cmwpO1xuICAgICAgfVxuICAgICAgdmFyIGhhc2ggPSBwYXJzZWRVUkwuaGFzaDtcblxuICAgICAgLy8gSWYgdGhlIG9yaWdpbmFsIFVSTCB3YXMgYSBkaXJlY3QgbGluaywgZHJvcCB0aGUgI2Fubm90YXRpb25zIGZyYWdtZW50XG4gICAgICAvLyBhcyBvdGhlcndpc2UgdGhlIENocm9tZSBleHRlbnNpb24gd2lsbCByZS1hY3RpdmF0ZSBpdHNlbGYgb24gdGhpcyB0YWJcbiAgICAgIC8vIHdoZW4gdGhlIG9yaWdpbmFsIFVSTCBsb2Fkcy5cbiAgICAgIGlmIChoYXNoLmluZGV4T2YoJyNhbm5vdGF0aW9uczonKSA9PT0gMCkge1xuICAgICAgICBoYXNoID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGNocm9tZVRhYnMudXBkYXRlKFxuICAgICAgICB0YWIuaWQsXG4gICAgICAgIHtcbiAgICAgICAgICB1cmw6IGRlY29kZVVSSUNvbXBvbmVudChvcmlnaW5hbFVSTCkgKyBoYXNoLFxuICAgICAgICB9LFxuICAgICAgICByZXNvbHZlXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlRnJvbUhUTUwodGFiKSB7XG4gICAgaWYgKCFpc1N1cHBvcnRlZFVSTCh0YWIudXJsKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gaW5qZWN0U2NyaXB0KHRhYi5pZCwgJy91bmxvYWQtY2xpZW50LmpzJyk7XG4gIH1cblxuICAvKipcbiAgICogSW5qZWN0IHRoZSBzY3JpcHQgZnJvbSB0aGUgc291cmNlIGZpbGUgYXQgYHBhdGhgIGludG8gdGhlXG4gICAqIHBhZ2UgY3VycmVudGx5IGxvYWRlZCBpbiB0aGUgdGFiIGF0IHRoZSBnaXZlbiBJRC5cbiAgICovXG4gIGZ1bmN0aW9uIGluamVjdFNjcmlwdCh0YWJJZCwgcGF0aCkge1xuICAgIHJldHVybiBleGVjdXRlU2NyaXB0Rm4odGFiSWQsIHsgZmlsZTogcGF0aCB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmplY3QgY29uZmlndXJhdGlvbiBpbmZvcm1hdGlvbiBmb3IgdGhlIEh5cG90aGVzaXMgYXBwbGljYXRpb25cbiAgICogaW50byB0aGUgcGFnZSBhcyBKU09OIGRhdGEgdmlhIGEgPG1ldGE+IHRhZy5cbiAgICpcbiAgICogQSA8bWV0YT4gdGFnIGlzIHVzZWQgYmVjYXVzZSB0aGF0IG1ha2VzIGl0IGF2YWlsYWJsZSB0byBKUyBjb250ZW50XG4gICAqIHJ1bm5pbmcgaW4gaXNvbGF0ZWQgd29ybGRzLlxuICAgKi9cbiAgZnVuY3Rpb24gaW5qZWN0Q29uZmlnKHRhYklkLCBjb25maWcpIHtcbiAgICB2YXIgY29uZmlnU3RyID0gSlNPTi5zdHJpbmdpZnkoY29uZmlnKS5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJyk7XG4gICAgdmFyIGNvbmZpZ0NvZGUgPVxuICAgICAgJ3ZhciBoeXBvdGhlc2lzQ29uZmlnID0gXCInICtcbiAgICAgIGNvbmZpZ1N0ciArXG4gICAgICAnXCI7XFxuJyArXG4gICAgICAnKCcgK1xuICAgICAgYWRkSlNPTlNjcmlwdFRhZ0ZuLnRvU3RyaW5nKCkgK1xuICAgICAgJyknICtcbiAgICAgICcoXCJqcy1oeXBvdGhlc2lzLWNvbmZpZ1wiLCBoeXBvdGhlc2lzQ29uZmlnKTtcXG4nO1xuICAgIHJldHVybiBleGVjdXRlU2NyaXB0Rm4odGFiSWQsIHsgY29kZTogY29uZmlnQ29kZSB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IGlzU2hhbGxvd0VxdWFsIGZyb20gJ2lzLWVxdWFsLXNoYWxsb3cnO1xuXG5pbXBvcnQgKiBhcyB1cmlJbmZvIGZyb20gJy4vdXJpLWluZm8nO1xuXG52YXIgc3RhdGVzID0ge1xuICBBQ1RJVkU6ICdhY3RpdmUnLFxuICBJTkFDVElWRTogJ2luYWN0aXZlJyxcbiAgRVJST1JFRDogJ2Vycm9yZWQnLFxufTtcblxuLyoqIFRoZSBkZWZhdWx0IEggc3RhdGUgZm9yIGEgbmV3IGJyb3dzZXIgdGFiICovXG52YXIgREVGQVVMVF9TVEFURSA9IHtcbiAgLyoqIFdoZXRoZXIgb3Igbm90IEggaXMgYWN0aXZlIG9uIHRoZSBwYWdlICovXG4gIHN0YXRlOiBzdGF0ZXMuSU5BQ1RJVkUsXG4gIC8qKiBUaGUgY291bnQgb2YgYW5ub3RhdGlvbnMgb24gdGhlIHBhZ2UgdmlzaWJsZSB0byB0aGUgdXNlcixcbiAgICogYXMgcmV0dXJuZWQgYnkgdGhlIGJhZGdlIEFQSVxuICAgKi9cbiAgYW5ub3RhdGlvbkNvdW50OiAwLFxuICAvKiogV2hldGhlciBvciBub3QgdGhlIEggc2lkZWJhciBoYXMgYmVlbiBpbnN0YWxsZWQgb250byB0aGUgcGFnZSBieVxuICAgKiB0aGUgZXh0ZW5zaW9uXG4gICAqL1xuICBleHRlbnNpb25TaWRlYmFySW5zdGFsbGVkOiBmYWxzZSxcbiAgLyoqIFdoZXRoZXIgdGhlIHRhYiBpcyBsb2FkZWQgYW5kIHJlYWR5IGZvciB0aGUgc2lkZWJhciB0byBiZSBpbnN0YWxsZWQuICovXG4gIHJlYWR5OiBmYWxzZSxcbiAgLyoqIFRoZSBlcnJvciBmb3IgdGhlIGN1cnJlbnQgdGFiLiAqL1xuICBlcnJvcjogdW5kZWZpbmVkLFxufTtcblxuLyoqIFRhYlN0YXRlIHN0b3JlcyB0aGUgSCBzdGF0ZSBmb3IgYSB0YWIuIFRoaXMgc3RhdGUgaW5jbHVkZXM6XG4gKlxuICogLSBXaGV0aGVyIHRoZSBleHRlbnNpb24gaGFzIGJlZW4gYWN0aXZhdGVkIG9uIGEgdGFiXG4gKiAtIFdoZXRoZXIgdGhlIHNpZGViYXIgaXMgY3VycmVudGx5IGluc3RhbGxlZCBvbiBhIHRhYlxuICogLSBUaGUgY291bnQgb2YgYW5ub3RhdGlvbnMgdmlzaWJsZSB0byB0aGUgdXNlciBvbiB0aGUgVVJMIGN1cnJlbnRseVxuICogICBkaXNwbGF5ZWQgaW4gdGhlIHRhYi5cbiAqXG4gKiBUaGUgSCBzdGF0ZSBmb3IgYSB0YWIgaXMgdXBkYXRlZCB2aWEgdGhlIHNldFN0YXRlKCkgbWV0aG9kIGFuZFxuICogcmV0cmlldmVkIHZpYSBnZXRTdGF0ZSgpLlxuICpcbiAqIFdoZW4gdGhlIEggc3RhdGUgZm9yIGEgdGFiIGNoYW5nZXMsIHRoZSBgb25jaGFuZ2UoKWAgY2FsbGJhY2sgd2lsbFxuICogYmUgdHJpZ2dlcmVkIHdpdGggdGhlIHRhYiBJRCBhbmQgY3VycmVudCBhbmQgcHJldmlvdXMgc3RhdGVzLlxuICpcbiAqIGluaXRpYWxTdGF0ZSAtIEFuIE9iamVjdCBvZiB0YWJJZC9zdGF0ZSBrZXlzLiBVc2VkIHdoZW4gbG9hZGluZyBzdGF0ZVxuICogICBmcm9tIGEgcGVyc2lzdGVkIHN0b3JlIHN1Y2ggYXMgbG9jYWxTdG9yYWdlLiBUaGlzIHdpbGwgYmUgbWVyZ2VkIHdpdGhcbiAqICAgdGhlIGRlZmF1bHQgc3RhdGUgZm9yIGEgdGFiLlxuICogb25jaGFuZ2UgICAgIC0gQSBmdW5jdGlvbiB0aGF0IHJlY2lldmVzIG9uY2hhbmdlKHRhYklkLCBjdXJyZW50KS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVGFiU3RhdGUoaW5pdGlhbFN0YXRlLCBvbmNoYW5nZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBjdXJyZW50U3RhdGU7XG5cbiAgdGhpcy5vbmNoYW5nZSA9IG9uY2hhbmdlIHx8IG51bGw7XG5cbiAgLyoqIFJlcGxhY2VzIHRoZSBIIHN0YXRlIGZvciBhbGwgdGFicyB3aXRoIHRoZSBzdGF0ZSBkYXRhXG4gICAqIGZyb20gYG5ld1N0YXRlYC5cbiAgICpcbiAgICogQHBhcmFtIG5ld1N0YXRlIC0gQSBkaWN0aW9uYXJ5IG1hcHBpbmcgdGFiIElEIHRvIHRhYiBzdGF0ZSBvYmplY3RzLlxuICAgKiAgICAgICAgICAgICAgICAgICBUaGUgcHJvdmlkZWQgc3RhdGUgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgZGVmYXVsdFxuICAgKiAgICAgICAgICAgICAgICAgICBzdGF0ZSBmb3IgYSB0YWIuXG4gICAqL1xuICB0aGlzLmxvYWQgPSBmdW5jdGlvbiAobmV3U3RhdGUpIHtcbiAgICB2YXIgbmV3Q3VycmVudFN0YXRlID0ge307XG4gICAgT2JqZWN0LmtleXMobmV3U3RhdGUpLmZvckVhY2goZnVuY3Rpb24gKHRhYklkKSB7XG4gICAgICBuZXdDdXJyZW50U3RhdGVbdGFiSWRdID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAge30sXG4gICAgICAgIERFRkFVTFRfU1RBVEUsXG4gICAgICAgIG5ld1N0YXRlW3RhYklkXVxuICAgICAgKTtcbiAgICB9KTtcbiAgICBjdXJyZW50U3RhdGUgPSBuZXdDdXJyZW50U3RhdGU7XG4gIH07XG5cbiAgdGhpcy5hY3RpdmF0ZVRhYiA9IGZ1bmN0aW9uICh0YWJJZCkge1xuICAgIHRoaXMuc2V0U3RhdGUodGFiSWQsIHsgc3RhdGU6IHN0YXRlcy5BQ1RJVkUgfSk7XG4gIH07XG5cbiAgdGhpcy5kZWFjdGl2YXRlVGFiID0gZnVuY3Rpb24gKHRhYklkKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh0YWJJZCwgeyBzdGF0ZTogc3RhdGVzLklOQUNUSVZFIH0pO1xuICB9O1xuXG4gIHRoaXMuZXJyb3JUYWIgPSBmdW5jdGlvbiAodGFiSWQsIGVycm9yKSB7XG4gICAgdGhpcy5zZXRTdGF0ZSh0YWJJZCwge1xuICAgICAgc3RhdGU6IHN0YXRlcy5FUlJPUkVELFxuICAgICAgZXJyb3I6IGVycm9yLFxuICAgIH0pO1xuICB9O1xuXG4gIHRoaXMuY2xlYXJUYWIgPSBmdW5jdGlvbiAodGFiSWQpIHtcbiAgICB0aGlzLnNldFN0YXRlKHRhYklkLCBudWxsKTtcbiAgfTtcblxuICB0aGlzLmdldFN0YXRlID0gZnVuY3Rpb24gKHRhYklkKSB7XG4gICAgaWYgKCFjdXJyZW50U3RhdGVbdGFiSWRdKSB7XG4gICAgICByZXR1cm4gREVGQVVMVF9TVEFURTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRTdGF0ZVt0YWJJZF07XG4gIH07XG5cbiAgdGhpcy5hbm5vdGF0aW9uQ291bnQgPSBmdW5jdGlvbiAodGFiSWQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSh0YWJJZCkuYW5ub3RhdGlvbkNvdW50O1xuICB9O1xuXG4gIHRoaXMuaXNUYWJBY3RpdmUgPSBmdW5jdGlvbiAodGFiSWQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSh0YWJJZCkuc3RhdGUgPT09IHN0YXRlcy5BQ1RJVkU7XG4gIH07XG5cbiAgdGhpcy5pc1RhYkluYWN0aXZlID0gZnVuY3Rpb24gKHRhYklkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RhdGUodGFiSWQpLnN0YXRlID09PSBzdGF0ZXMuSU5BQ1RJVkU7XG4gIH07XG5cbiAgdGhpcy5pc1RhYkVycm9yZWQgPSBmdW5jdGlvbiAodGFiSWQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdGF0ZSh0YWJJZCkuc3RhdGUgPT09IHN0YXRlcy5FUlJPUkVEO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBIIHN0YXRlIGZvciBhIHRhYi5cbiAgICpcbiAgICogQHBhcmFtIHRhYklkIC0gVGhlIElEIG9mIHRoZSB0YWIgYmVpbmcgdXBkYXRlZFxuICAgKiBAcGFyYW0gc3RhdGVVcGRhdGUgLSBBIGRpY3Rpb25hcnkgb2Yge2tleTp2YWx1ZX0gcHJvcGVydGllcyBmb3JcbiAgICogICAgICAgICAgICAgICAgICAgICAgc3RhdGUgcHJvcGVydGllcyB0byB1cGRhdGUgb3IgbnVsbCBpZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgICAgc3RhdGUgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAqL1xuICB0aGlzLnNldFN0YXRlID0gZnVuY3Rpb24gKHRhYklkLCBzdGF0ZVVwZGF0ZSkge1xuICAgIHZhciBuZXdTdGF0ZTtcbiAgICBpZiAoc3RhdGVVcGRhdGUpIHtcbiAgICAgIG5ld1N0YXRlID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTdGF0ZSh0YWJJZCksIHN0YXRlVXBkYXRlKTtcbiAgICAgIGlmIChuZXdTdGF0ZS5zdGF0ZSAhPT0gc3RhdGVzLkVSUk9SRUQpIHtcbiAgICAgICAgbmV3U3RhdGUuZXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzU2hhbGxvd0VxdWFsKG5ld1N0YXRlLCBjdXJyZW50U3RhdGVbdGFiSWRdKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGN1cnJlbnRTdGF0ZVt0YWJJZF0gPSBuZXdTdGF0ZTtcblxuICAgIGlmIChzZWxmLm9uY2hhbmdlKSB7XG4gICAgICBzZWxmLm9uY2hhbmdlKHRhYklkLCBuZXdTdGF0ZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBRdWVyeSB0aGUgc2VydmVyIGZvciB0aGUgYW5ub3RhdGlvbiBjb3VudCBmb3IgYSBVUkxcbiAgICogYW5kIHVwZGF0ZSB0aGUgYW5ub3RhdGlvbiBjb3VudCBmb3IgdGhlIHRhYiBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQG1ldGhvZFxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHRhYklkIFRoZSBpZCBvZiB0aGUgdGFiLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGFiVXJsIFRoZSBVUkwgb2YgdGhlIHRhYi5cbiAgICovXG4gIHRoaXMudXBkYXRlQW5ub3RhdGlvbkNvdW50ID0gZnVuY3Rpb24gKHRhYklkLCB0YWJVcmwpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHVyaUluZm9cbiAgICAgIC5xdWVyeSh0YWJVcmwpXG4gICAgICAudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHNlbGYuc2V0U3RhdGUodGFiSWQsIHsgYW5ub3RhdGlvbkNvdW50OiByZXN1bHQudG90YWwgfSk7XG4gICAgICB9KVxuICAgICAgLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgc2VsZi5zZXRTdGF0ZSh0YWJJZCwgeyBhbm5vdGF0aW9uQ291bnQ6IDAgfSk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgJ0ZhaWxlZCB0byBmZXRjaCBhbm5vdGF0aW9uIGNvdW50IGZvciAlczogJXMnLFxuICAgICAgICAgIHRhYlVybCxcbiAgICAgICAgICBlcnJcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICB9O1xuXG4gIHRoaXMubG9hZChpbml0aWFsU3RhdGUgfHwge30pO1xufVxuXG5UYWJTdGF0ZS5zdGF0ZXMgPSBzdGF0ZXM7XG4iLCIvKiogVGFiU3RvcmUgaXMgdXNlZCB0byBwZXJzaXN0IHRoZSBzdGF0ZSBvZiBIIGJyb3dzZXIgdGFicyB3aGVuXG4gKiB0aGUgZXh0ZW5zaW9uIGlzIHJlLWluc3RhbGxlZCBvciB1cGRhdGVkLlxuICpcbiAqIE5vdGU6IFRoaXMgY291bGQgYWxzbyBiZSB1c2VkIHRvIHBlcnNpc3QgdGhlIHN0YXRlIGFjcm9zcyBicm93c2VyIHNlc3Npb25zLFxuICogZm9yIHRoYXQgdG8gd29yayBob3dldmVyIHRoZSBzdG9yYWdlIGtleSB3b3VsZCBuZWVkIHRvIGJlIGNoYW5nZWQuXG4gKiBUaGUgdGFiIElEIGlzIGN1cnJlbnRseSB1c2VkIGJ1dCB0aGlzIGlzIHZhbGlkIG9ubHkgZm9yIGEgYnJvd3NlciBzZXNzaW9uLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUYWJTdG9yZShzdG9yYWdlKSB7XG4gIHZhciBrZXkgPSAnc3RhdGUnO1xuICB2YXIgbG9jYWw7XG5cbiAgdGhpcy5nZXQgPSBmdW5jdGlvbiAodGFiSWQpIHtcbiAgICB2YXIgdmFsdWUgPSBsb2NhbFt0YWJJZF07XG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUYWJTdGF0ZVN0b3JlIGNvdWxkIG5vdCBmaW5kIGVudHJ5IGZvciB0YWI6ICcgKyB0YWJJZCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICB0aGlzLnNldCA9IGZ1bmN0aW9uICh0YWJJZCwgdmFsdWUpIHtcbiAgICAvLyBjb3B5IGFjcm9zcyBvbmx5IHRoZSBwYXJ0cyBvZiB0aGUgdGFiIHN0YXRlIHRoYXQgc2hvdWxkXG4gICAgLy8gYmUgcHJlc2VydmVkXG4gICAgbG9jYWxbdGFiSWRdID0ge1xuICAgICAgc3RhdGU6IHZhbHVlLnN0YXRlLFxuICAgICAgYW5ub3RhdGlvbkNvdW50OiB2YWx1ZS5hbm5vdGF0aW9uQ291bnQsXG4gICAgfTtcbiAgICBzdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeShsb2NhbCkpO1xuICB9O1xuXG4gIHRoaXMudW5zZXQgPSBmdW5jdGlvbiAodGFiSWQpIHtcbiAgICBkZWxldGUgbG9jYWxbdGFiSWRdO1xuICAgIHN0b3JhZ2Uuc2V0SXRlbShrZXksIEpTT04uc3RyaW5naWZ5KGxvY2FsKSk7XG4gIH07XG5cbiAgdGhpcy5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxvY2FsO1xuICB9O1xuXG4gIHRoaXMucmVsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICBsb2NhbCA9IHt9O1xuICAgICAgdmFyIGxvYWRlZCA9IEpTT04ucGFyc2Uoc3RvcmFnZS5nZXRJdGVtKGtleSkpO1xuICAgICAgT2JqZWN0LmtleXMobG9hZGVkKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgLy8gaWdub3JlIHRhYiBzdGF0ZSBzYXZlZCBieSBlYXJsaWVyIHZlcnNpb25zIG9mXG4gICAgICAgIC8vIHRoZSBleHRlbnNpb24gd2hpY2ggc2F2ZWQgdGhlIHN0YXRlIGFzIGEge2tleTogPHN0YXRlIHN0cmluZz59XG4gICAgICAgIC8vIGRpY3QgcmF0aGVyIHRoYW4ge2tleTogPHN0YXRlIG9iamVjdD59XG4gICAgICAgIGlmICh0eXBlb2YgbG9hZGVkW2tleV0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbG9jYWxba2V5XSA9IHsgc3RhdGU6IGxvYWRlZFtrZXldIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9jYWxba2V5XSA9IGxvYWRlZFtrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2NhbCA9IG51bGw7XG4gICAgfVxuICAgIGxvY2FsID0gbG9jYWwgfHwge307XG4gIH07XG5cbiAgdGhpcy5yZWxvYWQoKTtcbn1cbiIsImltcG9ydCBzZXR0aW5ncyBmcm9tICcuL3NldHRpbmdzJztcblxuLyoqIGVuY29kZVVyaVF1ZXJ5IGVuY29kZXMgYSBzdHJpbmcgZm9yIHVzZSBpbiBhIHF1ZXJ5IHBhcmFtZXRlciAqL1xuZnVuY3Rpb24gZW5jb2RlVXJpUXVlcnkodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbn1cblxuLyoqXG4gKiBRdWVyaWVzIHRoZSBIeXBvdGhlc2lzIHNlcnZpY2UgdGhhdCBwcm92aWRlc1xuICogc3RhdGlzdGljcyBhYm91dCB0aGUgYW5ub3RhdGlvbnMgZm9yIGEgZ2l2ZW4gVVJMLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcXVlcnkodXJpKSB7XG4gIHJldHVybiBmZXRjaChzZXR0aW5ncy5hcGlVcmwgKyAnL2JhZGdlP3VyaT0nICsgZW5jb2RlVXJpUXVlcnkodXJpKSwge1xuICAgIGNyZWRlbnRpYWxzOiAnaW5jbHVkZScsXG4gIH0pXG4gICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgcmV0dXJuIHJlcy5qc29uKCk7XG4gICAgfSlcbiAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgaWYgKHR5cGVvZiBkYXRhLnRvdGFsICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Fubm90YXRpb24gY291bnQgaXMgbm90IGEgbnVtYmVyJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9KTtcbn1cbiIsImZ1bmN0aW9uIGdldExhc3RFcnJvcigpIHtcbiAgaWYgKHR5cGVvZiBjaHJvbWUgIT09ICd1bmRlZmluZWQnICYmIGNocm9tZS5leHRlbnNpb24pIHtcbiAgICByZXR1cm4gY2hyb21lLmV4dGVuc2lvbi5sYXN0RXJyb3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGFuIGFzeW5jIENocm9tZSBBUEkgaW50byBhIGZ1bmN0aW9uXG4gKiB3aGljaCByZXR1cm5zIGEgcHJvbWlzZS5cbiAqXG4gKiBVc2FnZTpcbiAqICAgdmFyIGFwaUZuID0gcHJvbWlzaWZ5KGNocm9tZS5zb21lTW9kdWxlLmFGdW5jdGlvbik7XG4gKiAgIGFwaUZuKGFyZzEsIGFyZzIpXG4gKiAgICAgLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyAuLi5oYW5kbGUgc3VjY2VzcyAgfSlcbiAqICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikgeyAuLi5oYW5kbGUgZXJyb3IgfSlcbiAqXG4gKlxuICogQHBhcmFtIGZuIEEgQ2hyb21lIEFQSSBmdW5jdGlvbiB3aG9zZSBsYXN0IGFyZ3VtZW50IGlzIGEgY2FsbGJhY2tcbiAqICAgICAgICAgICB3aGljaCBpcyBpbnZva2VkIHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgcXVlcnkuIFdoZW4gdGhpcyBjYWxsYmFja1xuICogICAgICAgICAgIGlzIGludm9rZWQsIHRoZSBwcm9taXNlIGlzIHJlamVjdGVkIGlmIGNocm9tZS5leHRlbnNpb24ubGFzdEVycm9yXG4gKiAgICAgICAgICAgaXMgc2V0IG9yIHJlc29sdmVkIHdpdGggdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBjYWxsYmFjayBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNpZnkoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZm4uYXBwbHkoXG4gICAgICAgIHRoaXMsXG4gICAgICAgIGFyZ3MuY29uY2F0KGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICB2YXIgbGFzdEVycm9yID0gZ2V0TGFzdEVycm9yKCk7XG4gICAgICAgICAgaWYgKGxhc3RFcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGxhc3RFcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG4iXX0=
